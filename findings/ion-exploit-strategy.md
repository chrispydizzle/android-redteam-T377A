# ION UAF Exploit Strategy: From Race to Root

## The Vulnerability

We have a Use-After-Free (UAF) in `ion_handle`.

- **Race**: `ION_IOC_FREE` (Thread A) vs `ION_IOC_SHARE` (Thread B).
- **Result**: Thread B gets a valid file descriptor (`fd`) pointing to an `ion_handle` that Thread A has already freed.

## The Path to Code Execution

### 1. The Dangling Object

The `fd` we hold points to a `struct dma_buf` in the kernel. This `dma_buf` has a private pointer `priv` which points to the **freed** `ion_handle`.

```c
struct ion_handle {
    struct kref ref;
    struct ion_client *client;
    struct ion_buffer *buffer;  // <--- CRITICAL POINTER
    struct rb_node node;
    unsigned int kmap_cnt;
};
```

### 2. Replacing the Object (Heap Spray)

After the handle is freed, we spray the kernel heap (`kmalloc-64`) with controlled data. We use `sendmsg` or `setxattr` to overwrite the freed `ion_handle` with our own fake object.

**Our Fake `ion_handle`:**

- `ref`: random junk
- `client`: valid client pointer (maybe)
- `buffer`: **POINTER TO FAKE BUFFER** (Controlled Address)

### 3. Triggering the Function Pointer

We now call a standard file operation on our dangling `fd`, like `mmap()` or `close()`.

When we call `mmap(fd, ...)`:

1. Kernel looks up `dma_buf` from `fd`.
2. `dma_buf->ops->mmap` is called (which is `ion_dma_buf_mmap`).
3. `ion_dma_buf_mmap` grabs the `ion_handle` from `dma_buf->priv`.
4. It accesses `handle->buffer` (which we overwrote).
5. It then typically calls `buffer->heap->ops->map_user`.

```c
// Simplified Kernel Logic
int ion_dma_buf_mmap(struct dma_buf *dmabuf, struct vm_area_struct *vma) {
    struct ion_handle *handle = dmabuf->priv;
    struct ion_buffer *buffer = handle->buffer; // CONTROLLED
    
    // ... validation ...
    
    return buffer->heap->ops->map_user(buffer->heap, buffer, vma); // EXECUTION!
}
```

### 4. The Exploit Chain

1. **Fake `ion_handle`** (in kernel heap) points to **Fake `ion_buffer`**.
2. **Fake `ion_buffer`** (in user space or controlled heap) points to **Fake `ion_heap`**.
3. **Fake `ion_heap`** (in user space) points to **Fake `ion_heap_ops`**.
4. **Fake `ion_heap_ops`** (in user space) contains a function pointer for `map_user`.
5. `map_user` points to our **Shellcode** (commit_creds(prepare_kernel_cred(0))).

### Why This Works on SM-T377A

1. **No SMAP/SMEP**: The kernel can read data and execute code from User Space. We can put the Fake Buffer and Shellcode directly in our process memory.
2. **No KASLR**: We know the addresses of kernel functions like `commit_creds` statically.
3. **No Kptr_restrict**: We can find the address of our own objects if needed (though user space addresses are known).
